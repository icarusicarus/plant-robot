###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         03/Nov/2021  18:48:26
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_flash.c
#    Command line      =
#        -f
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_flash.o.rsp
#        (C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_flash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries -o
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\inc\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\LCD\ -Ol -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_flash.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries\stm32f10x_flash.lst
#    Object file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_flash.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_flash.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the FLASH firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_flash.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          /** @defgroup FLASH 
     30            * @brief FLASH driver modules
     31            * @{
     32            */ 
     33          
     34          /** @defgroup FLASH_Private_TypesDefinitions
     35            * @{
     36            */
     37          
     38          /**
     39            * @}
     40            */ 
     41          
     42          /** @defgroup FLASH_Private_Defines
     43            * @{
     44            */ 
     45          
     46          /* Flash Access Control Register bits */
     47          #define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
     48          #define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
     49          #define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
     50          
     51          /* Flash Access Control Register bits */
     52          #define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) 
     53          
     54          /* Flash Control Register bits */
     55          #define CR_PG_Set                ((uint32_t)0x00000001)
     56          #define CR_PG_Reset              ((uint32_t)0x00001FFE) 
     57          #define CR_PER_Set               ((uint32_t)0x00000002)
     58          #define CR_PER_Reset             ((uint32_t)0x00001FFD)
     59          #define CR_MER_Set               ((uint32_t)0x00000004)
     60          #define CR_MER_Reset             ((uint32_t)0x00001FFB)
     61          #define CR_OPTPG_Set             ((uint32_t)0x00000010)
     62          #define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
     63          #define CR_OPTER_Set             ((uint32_t)0x00000020)
     64          #define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
     65          #define CR_STRT_Set              ((uint32_t)0x00000040)
     66          #define CR_LOCK_Set              ((uint32_t)0x00000080)
     67          
     68          /* FLASH Mask */
     69          #define RDPRT_Mask               ((uint32_t)0x00000002)
     70          #define WRP0_Mask                ((uint32_t)0x000000FF)
     71          #define WRP1_Mask                ((uint32_t)0x0000FF00)
     72          #define WRP2_Mask                ((uint32_t)0x00FF0000)
     73          #define WRP3_Mask                ((uint32_t)0xFF000000)
     74          #define OB_USER_BFB2             ((uint16_t)0x0008)
     75          
     76          /* FLASH Keys */
     77          #define RDP_Key                  ((uint16_t)0x00A5)
     78          #define FLASH_KEY1               ((uint32_t)0x45670123)
     79          #define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
     80          
     81          /* FLASH BANK address */
     82          #define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)
     83          
     84          /* Delay definition */   
     85          #define EraseTimeout          ((uint32_t)0x000B0000)
     86          #define ProgramTimeout        ((uint32_t)0x00002000)
     87          /**
     88            * @}
     89            */ 
     90          
     91          /** @defgroup FLASH_Private_Macros
     92            * @{
     93            */
     94          
     95          /**
     96            * @}
     97            */ 
     98          
     99          /** @defgroup FLASH_Private_Variables
    100            * @{
    101            */
    102          
    103          /**
    104            * @}
    105            */ 
    106          
    107          /** @defgroup FLASH_Private_FunctionPrototypes
    108            * @{
    109            */
    110            
    111          /**
    112            * @}
    113            */
    114          
    115          /** @defgroup FLASH_Private_Functions
    116            * @{
    117            */
    118          
    119          /**
    120          @code  
    121           
    122           This driver provides functions to configure and program the Flash memory of all STM32F10x devices,
    123           including the latest STM32F10x_XL density devices. 
    124          
    125           STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:
    126              - bank1: fixed size of 512 Kbytes (256 pages of 2Kbytes each)
    127              - bank2: up to 512 Kbytes (up to 256 pages of 2Kbytes each)
    128           While other STM32F10x devices features only one bank with memory up to 512 Kbytes.
    129          
    130           In version V3.3.0, some functions were updated and new ones were added to support
    131           STM32F10x_XL devices. Thus some functions manages all devices, while other are 
    132           dedicated for XL devices only.
    133           
    134           The table below presents the list of available functions depending on the used STM32F10x devices.  
    135                
    136             ***************************************************
    137             * Legacy functions used for all STM32F10x devices *
    138             ***************************************************
    139             +----------------------------------------------------------------------------------------------------------------------------------+
    140             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    141             |                                    |   devices  |  devices      |                                                                |
    142             |----------------------------------------------------------------------------------------------------------------------------------|
    143             |FLASH_SetLatency                    |    Yes     |      Yes      | No change                                                      |
    144             |----------------------------------------------------------------------------------------------------------------------------------|
    145             |FLASH_HalfCycleAccessCmd            |    Yes     |      Yes      | No change                                                      |
    146             |----------------------------------------------------------------------------------------------------------------------------------|
    147             |FLASH_PrefetchBufferCmd             |    Yes     |      Yes      | No change                                                      |
    148             |----------------------------------------------------------------------------------------------------------------------------------|
    149             |FLASH_Unlock                        |    Yes     |      Yes      | - For STM32F10X_XL devices: unlock Bank1 and Bank2.            |
    150             |                                    |            |               | - For other devices: unlock Bank1 and it is equivalent         |
    151             |                                    |            |               |   to FLASH_UnlockBank1 function.                               |
    152             |----------------------------------------------------------------------------------------------------------------------------------|
    153             |FLASH_Lock                          |    Yes     |      Yes      | - For STM32F10X_XL devices: lock Bank1 and Bank2.              |
    154             |                                    |            |               | - For other devices: lock Bank1 and it is equivalent           |
    155             |                                    |            |               |   to FLASH_LockBank1 function.                                 |
    156             |----------------------------------------------------------------------------------------------------------------------------------|
    157             |FLASH_ErasePage                     |    Yes     |      Yes      | - For STM32F10x_XL devices: erase a page in Bank1 and Bank2    |
    158             |                                    |            |               | - For other devices: erase a page in Bank1                     |
    159             |----------------------------------------------------------------------------------------------------------------------------------|
    160             |FLASH_EraseAllPages                 |    Yes     |      Yes      | - For STM32F10x_XL devices: erase all pages in Bank1 and Bank2 |
    161             |                                    |            |               | - For other devices: erase all pages in Bank1                  |
    162             |----------------------------------------------------------------------------------------------------------------------------------|
    163             |FLASH_EraseOptionBytes              |    Yes     |      Yes      | No change                                                      |
    164             |----------------------------------------------------------------------------------------------------------------------------------|
    165             |FLASH_ProgramWord                   |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
    166             |----------------------------------------------------------------------------------------------------------------------------------|
    167             |FLASH_ProgramHalfWord               |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
    168             |----------------------------------------------------------------------------------------------------------------------------------|
    169             |FLASH_ProgramOptionByteData         |    Yes     |      Yes      | No change                                                      |
    170             |----------------------------------------------------------------------------------------------------------------------------------|
    171             |FLASH_EnableWriteProtection         |    Yes     |      Yes      | No change                                                      |
    172             |----------------------------------------------------------------------------------------------------------------------------------|
    173             |FLASH_ReadOutProtection             |    Yes     |      Yes      | No change                                                      |
    174             |----------------------------------------------------------------------------------------------------------------------------------|
    175             |FLASH_UserOptionByteConfig          |    Yes     |      Yes      | No change                                                      |
    176             |----------------------------------------------------------------------------------------------------------------------------------|
    177             |FLASH_GetUserOptionByte             |    Yes     |      Yes      | No change                                                      |
    178             |----------------------------------------------------------------------------------------------------------------------------------|
    179             |FLASH_GetWriteProtectionOptionByte  |    Yes     |      Yes      | No change                                                      |
    180             |----------------------------------------------------------------------------------------------------------------------------------|
    181             |FLASH_GetReadOutProtectionStatus    |    Yes     |      Yes      | No change                                                      |
    182             |----------------------------------------------------------------------------------------------------------------------------------|
    183             |FLASH_GetPrefetchBufferStatus       |    Yes     |      Yes      | No change                                                      |
    184             |----------------------------------------------------------------------------------------------------------------------------------|
    185             |FLASH_ITConfig                      |    Yes     |      Yes      | - For STM32F10x_XL devices: enable Bank1 and Bank2's interrupts|
    186             |                                    |            |               | - For other devices: enable Bank1's interrupts                 |
    187             |----------------------------------------------------------------------------------------------------------------------------------|
    188             |FLASH_GetFlagStatus                 |    Yes     |      Yes      | - For STM32F10x_XL devices: return Bank1 and Bank2's flag status|
    189             |                                    |            |               | - For other devices: return Bank1's flag status                |
    190             |----------------------------------------------------------------------------------------------------------------------------------|
    191             |FLASH_ClearFlag                     |    Yes     |      Yes      | - For STM32F10x_XL devices: clear Bank1 and Bank2's flag       |
    192             |                                    |            |               | - For other devices: clear Bank1's flag                        |
    193             |----------------------------------------------------------------------------------------------------------------------------------|
    194             |FLASH_GetStatus                     |    Yes     |      Yes      | - Return the status of Bank1 (for all devices)                 |
    195             |                                    |            |               |   equivalent to FLASH_GetBank1Status function                  |
    196             |----------------------------------------------------------------------------------------------------------------------------------|
    197             |FLASH_WaitForLastOperation          |    Yes     |      Yes      | - Wait for Bank1 last operation (for all devices)              |
    198             |                                    |            |               |   equivalent to: FLASH_WaitForLastBank1Operation function      |
    199             +----------------------------------------------------------------------------------------------------------------------------------+
    200          
    201             ************************************************************************************************************************
    202             * New functions used for all STM32F10x devices to manage Bank1:                                                        *
    203             *   - These functions are mainly useful for STM32F10x_XL density devices, to have separate control for Bank1 and bank2 *
    204             *   - For other devices, these functions are optional (covered by functions listed above)                              *
    205             ************************************************************************************************************************
    206             +----------------------------------------------------------------------------------------------------------------------------------+
    207             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    208             |                                    |   devices  |  devices      |                                                                |
    209             |----------------------------------------------------------------------------------------------------------------------------------|
    210             | FLASH_UnlockBank1                  |    Yes     |      Yes      | - Unlock Bank1                                                 |
    211             |----------------------------------------------------------------------------------------------------------------------------------|
    212             |FLASH_LockBank1                     |    Yes     |      Yes      | - Lock Bank1                                                   |
    213             |----------------------------------------------------------------------------------------------------------------------------------|
    214             | FLASH_EraseAllBank1Pages           |    Yes     |      Yes      | - Erase all pages in Bank1                                     |
    215             |----------------------------------------------------------------------------------------------------------------------------------|
    216             | FLASH_GetBank1Status               |    Yes     |      Yes      | - Return the status of Bank1                                   |
    217             |----------------------------------------------------------------------------------------------------------------------------------|
    218             | FLASH_WaitForLastBank1Operation    |    Yes     |      Yes      | - Wait for Bank1 last operation                                |
    219             +----------------------------------------------------------------------------------------------------------------------------------+
    220          
    221             *****************************************************************************
    222             * New Functions used only with STM32F10x_XL density devices to manage Bank2 *
    223             *****************************************************************************
    224             +----------------------------------------------------------------------------------------------------------------------------------+
    225             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    226             |                                    |   devices  |  devices      |                                                                |
    227             |----------------------------------------------------------------------------------------------------------------------------------|
    228             | FLASH_UnlockBank2                  |    Yes     |      No       | - Unlock Bank2                                                 |
    229             |----------------------------------------------------------------------------------------------------------------------------------|
    230             |FLASH_LockBank2                     |    Yes     |      No       | - Lock Bank2                                                   |
    231             |----------------------------------------------------------------------------------------------------------------------------------|
    232             | FLASH_EraseAllBank2Pages           |    Yes     |      No       | - Erase all pages in Bank2                                     |
    233             |----------------------------------------------------------------------------------------------------------------------------------|
    234             | FLASH_GetBank2Status               |    Yes     |      No       | - Return the status of Bank2                                   |
    235             |----------------------------------------------------------------------------------------------------------------------------------|
    236             | FLASH_WaitForLastBank2Operation    |    Yes     |      No       | - Wait for Bank2 last operation                                |
    237             |----------------------------------------------------------------------------------------------------------------------------------|
    238             | FLASH_BootConfig                   |    Yes     |      No       | - Configure to boot from Bank1 or Bank2                        |
    239             +----------------------------------------------------------------------------------------------------------------------------------+
    240          @endcode
    241          */
    242          
    243          
    244          /**
    245            * @brief  Sets the code latency value.
    246            * @note   This function can be used for all STM32F10x devices.
    247            * @param  FLASH_Latency: specifies the FLASH Latency value.
    248            *   This parameter can be one of the following values:
    249            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
    250            *     @arg FLASH_Latency_1: FLASH One Latency cycle
    251            *     @arg FLASH_Latency_2: FLASH Two Latency cycles
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void FLASH_SetLatency(uint32_t FLASH_Latency)
    255          {
    256            uint32_t tmpreg = 0;
   \                     FLASH_SetLatency: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    257            
    258            /* Check the parameters */
    259            //assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    260            
    261            /* Read the ACR register */
    262            tmpreg = FLASH->ACR;  
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable25
   \        0x6   0x6809             LDR      R1,[R1, #+0]
    263            
    264            /* Sets the Latency value */
    265            tmpreg &= ACR_LATENCY_Mask;
   \        0x8   0xF011 0x0138      ANDS     R1,R1,#0x38
    266            tmpreg |= FLASH_Latency;
   \        0xC   0x4308             ORRS     R0,R0,R1
    267            
    268            /* Write the ACR register */
    269            FLASH->ACR = tmpreg;
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x12   0x6008             STR      R0,[R1, #+0]
    270          }
   \       0x14   0x4770             BX       LR
    271          
    272          /**
    273            * @brief  Enables or disables the Half cycle flash access.
    274            * @note   This function can be used for all STM32F10x devices.
    275            * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
    276            *   This parameter can be one of the following values:
    277            *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    278            *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
    282          {
    283            /* Check the parameters */
    284            //assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    285            
    286            /* Enable or disable the Half cycle access */
    287            FLASH->ACR &= ACR_HLFCYA_Mask;
   \                     FLASH_HalfCycleAccessCmd: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable25
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF031 0x0108      BICS     R1,R1,#0x8
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable25
   \        0xE   0x6011             STR      R1,[R2, #+0]
    288            FLASH->ACR |= FLASH_HalfCycleAccess;
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x4308             ORRS     R0,R0,R1
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    289          }
   \       0x1E   0x4770             BX       LR
    290          
    291          /**
    292            * @brief  Enables or disables the Prefetch Buffer.
    293            * @note   This function can be used for all STM32F10x devices.
    294            * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    295            *   This parameter can be one of the following values:
    296            *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    297            *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
    301          {
    302            /* Check the parameters */
    303            //assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    304            
    305            /* Enable or disable the Prefetch Buffer */
    306            FLASH->ACR &= ACR_PRFTBE_Mask;
   \                     FLASH_PrefetchBufferCmd: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable25
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF031 0x0110      BICS     R1,R1,#0x10
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable25
   \        0xE   0x6011             STR      R1,[R2, #+0]
    307            FLASH->ACR |= FLASH_PrefetchBuffer;
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x4308             ORRS     R0,R0,R1
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    308          }
   \       0x1E   0x4770             BX       LR
    309          
    310          /**
    311            * @brief  Unlocks the FLASH Program Erase Controller.
    312            * @note   This function can be used for all STM32F10x devices.
    313            *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.
    314            *         - For all other devices it unlocks Bank1 and it is equivalent 
    315            *           to FLASH_UnlockBank1 function.. 
    316            * @param  None
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void FLASH_Unlock(void)
    320          {
    321            /* Authorize the FPEC of Bank1 Access */
    322            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_Unlock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \        0x8   0x6008             STR      R0,[R1, #+0]
    323            FLASH->KEYR = FLASH_KEY2;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \       0x12   0x6008             STR      R0,[R1, #+0]
    324          
    325          #ifdef STM32F10X_XL
    326            /* Authorize the FPEC of Bank2 Access */
    327            FLASH->KEYR2 = FLASH_KEY1;
    328            FLASH->KEYR2 = FLASH_KEY2;
    329          #endif /* STM32F10X_XL */
    330          }
   \       0x14   0x4770             BX       LR
    331          /**
    332            * @brief  Unlocks the FLASH Bank1 Program Erase Controller.
    333            * @note   This function can be used for all STM32F10x devices.
    334            *         - For STM32F10X_XL devices this function unlocks Bank1.
    335            *         - For all other devices it unlocks Bank1 and it is 
    336            *           equivalent to FLASH_Unlock function.
    337            * @param  None
    338            * @retval None
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          void FLASH_UnlockBank1(void)
    341          {
    342            /* Authorize the FPEC of Bank1 Access */
    343            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_UnlockBank1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \        0x8   0x6008             STR      R0,[R1, #+0]
    344            FLASH->KEYR = FLASH_KEY2;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \       0x12   0x6008             STR      R0,[R1, #+0]
    345          }
   \       0x14   0x4770             BX       LR
    346          
    347          #ifdef STM32F10X_XL
    348          /**
    349            * @brief  Unlocks the FLASH Bank2 Program Erase Controller.
    350            * @note   This function can be used only for STM32F10X_XL density devices.
    351            * @param  None
    352            * @retval None
    353            */
    354          void FLASH_UnlockBank2(void)
    355          {
    356            /* Authorize the FPEC of Bank2 Access */
    357            FLASH->KEYR2 = FLASH_KEY1;
    358            FLASH->KEYR2 = FLASH_KEY2;
    359          
    360          }
    361          #endif /* STM32F10X_XL */
    362          
    363          /**
    364            * @brief  Locks the FLASH Program Erase Controller.
    365            * @note   This function can be used for all STM32F10x devices.
    366            *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.
    367            *         - For all other devices it Locks Bank1 and it is equivalent 
    368            *           to FLASH_LockBank1 function.
    369            * @param  None
    370            * @retval None
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          void FLASH_Lock(void)
    373          {
    374            /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
    375            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_Lock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \        0xE   0x6008             STR      R0,[R1, #+0]
    376          
    377          #ifdef STM32F10X_XL
    378            /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
    379            FLASH->CR2 |= CR_LOCK_Set;
    380          #endif /* STM32F10X_XL */
    381          }
   \       0x10   0x4770             BX       LR
    382          
    383          /**
    384            * @brief  Locks the FLASH Bank1 Program Erase Controller.
    385            * @note   this function can be used for all STM32F10x devices.
    386            *         - For STM32F10X_XL devices this function Locks Bank1.
    387            *         - For all other devices it Locks Bank1 and it is equivalent 
    388            *           to FLASH_Lock function.
    389            * @param  None
    390            * @retval None
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          void FLASH_LockBank1(void)
    393          {
    394            /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
    395            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_LockBank1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \        0xE   0x6008             STR      R0,[R1, #+0]
    396          }
   \       0x10   0x4770             BX       LR
    397          
    398          #ifdef STM32F10X_XL
    399          /**
    400            * @brief  Locks the FLASH Bank2 Program Erase Controller.
    401            * @note   This function can be used only for STM32F10X_XL density devices.
    402            * @param  None
    403            * @retval None
    404            */
    405          void FLASH_LockBank2(void)
    406          {
    407            /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
    408            FLASH->CR2 |= CR_LOCK_Set;
    409          }
    410          #endif /* STM32F10X_XL */
    411          
    412          /**
    413            * @brief  Erases a specified FLASH page.
    414            * @note   This function can be used for all STM32F10x devices.
    415            * @param  Page_Address: The page address to be erased.
    416            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
    417            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
    420          {
   \                     FLASH_ErasePage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    421            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2004             MOVS     R0,#+4
    422            /* Check the parameters */
    423            //assert_param(IS_FLASH_ADDRESS(Page_Address));
    424          
    425          #ifdef STM32F10X_XL
    426            if(Page_Address < FLASH_BANK1_END_ADDRESS)  
    427            {
    428              /* Wait for last operation to be completed */
    429              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    430              if(status == FLASH_COMPLETE)
    431              { 
    432                /* if the previous operation is completed, proceed to erase the page */
    433                FLASH->CR|= CR_PER_Set;
    434                FLASH->AR = Page_Address; 
    435                FLASH->CR|= CR_STRT_Set;
    436              
    437                /* Wait for last operation to be completed */
    438                status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    439          
    440                /* Disable the PER Bit */
    441                FLASH->CR &= CR_PER_Reset;
    442              }
    443            }
    444            else
    445            {
    446              /* Wait for last operation to be completed */
    447              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    448              if(status == FLASH_COMPLETE)
    449              { 
    450                /* if the previous operation is completed, proceed to erase the page */
    451                FLASH->CR2|= CR_PER_Set;
    452                FLASH->AR2 = Page_Address; 
    453                FLASH->CR2|= CR_STRT_Set;
    454              
    455                /* Wait for last operation to be completed */
    456                status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    457                
    458                /* Disable the PER Bit */
    459                FLASH->CR2 &= CR_PER_Reset;
    460              }
    461            }
    462          #else
    463            /* Wait for last operation to be completed */
    464            status = FLASH_WaitForLastOperation(EraseTimeout);
   \        0x6   0xF45F 0x2030      MOVS     R0,#+720896
   \        0xA   0x.... 0x....      BL       FLASH_WaitForLastOperation
    465            
    466            if(status == FLASH_COMPLETE)
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x2904             CMP      R1,#+4
   \       0x14   0xD11F             BNE.N    ??FLASH_ErasePage_0
    467            { 
    468              /* if the previous operation is completed, proceed to erase the page */
    469              FLASH->CR|= CR_PER_Set;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x24   0x6008             STR      R0,[R1, #+0]
    470              FLASH->AR = Page_Address; 
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable25_5
   \       0x2A   0x6004             STR      R4,[R0, #+0]
    471              FLASH->CR|= CR_STRT_Set;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    472              
    473              /* Wait for last operation to be completed */
    474              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x3C   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x40   0x.... 0x....      BL       FLASH_WaitForLastOperation
    475              
    476              /* Disable the PER Bit */
    477              FLASH->CR &= CR_PER_Reset;
   \       0x44   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x48   0x680A             LDR      R2,[R1, #+0]
   \       0x4A   0xF641 0x71FD      MOVW     R1,#+8189
   \       0x4E   0x400A             ANDS     R2,R1,R2
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x54   0x600A             STR      R2,[R1, #+0]
    478            }
    479          #endif /* STM32F10X_XL */
    480          
    481            /* Return the Erase Status */
    482            return status;
   \                     ??FLASH_ErasePage_0: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0xBD10             POP      {R4,PC}
    483          }
    484          
    485          /**
    486            * @brief  Erases all FLASH pages.
    487            * @note   This function can be used for all STM32F10x devices.
    488            * @param  None
    489            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    490            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          FLASH_Status FLASH_EraseAllPages(void)
    493          {
   \                     FLASH_EraseAllPages: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    494            FLASH_Status status = FLASH_COMPLETE;
   \        0x2   0x2004             MOVS     R0,#+4
    495          
    496          #ifdef STM32F10X_XL
    497            /* Wait for last operation to be completed */
    498            status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    499            
    500            if(status == FLASH_COMPLETE)
    501            {
    502              /* if the previous operation is completed, proceed to erase all pages */
    503               FLASH->CR |= CR_MER_Set;
    504               FLASH->CR |= CR_STRT_Set;
    505              
    506              /* Wait for last operation to be completed */
    507              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    508              
    509              /* Disable the MER Bit */
    510              FLASH->CR &= CR_MER_Reset;
    511            }    
    512            if(status == FLASH_COMPLETE)
    513            {
    514              /* if the previous operation is completed, proceed to erase all pages */
    515               FLASH->CR2 |= CR_MER_Set;
    516               FLASH->CR2 |= CR_STRT_Set;
    517              
    518              /* Wait for last operation to be completed */
    519              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    520              
    521              /* Disable the MER Bit */
    522              FLASH->CR2 &= CR_MER_Reset;
    523            }
    524          #else
    525            /* Wait for last operation to be completed */
    526            status = FLASH_WaitForLastOperation(EraseTimeout);
   \        0x4   0xF45F 0x2030      MOVS     R0,#+720896
   \        0x8   0x.... 0x....      BL       FLASH_WaitForLastOperation
    527            if(status == FLASH_COMPLETE)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0x2904             CMP      R1,#+4
   \       0x12   0xD11C             BNE.N    ??FLASH_EraseAllPages_0
    528            {
    529              /* if the previous operation is completed, proceed to erase all pages */
    530               FLASH->CR |= CR_MER_Set;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x22   0x6008             STR      R0,[R1, #+0]
    531               FLASH->CR |= CR_STRT_Set;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x32   0x6008             STR      R0,[R1, #+0]
    532              
    533              /* Wait for last operation to be completed */
    534              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x34   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x38   0x.... 0x....      BL       FLASH_WaitForLastOperation
    535          
    536              /* Disable the MER Bit */
    537              FLASH->CR &= CR_MER_Reset;
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x40   0x680A             LDR      R2,[R1, #+0]
   \       0x42   0xF641 0x71FB      MOVW     R1,#+8187
   \       0x46   0x400A             ANDS     R2,R1,R2
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x4C   0x600A             STR      R2,[R1, #+0]
    538            }
    539          #endif /* STM32F10X_XL */
    540          
    541            /* Return the Erase Status */
    542            return status;
   \                     ??FLASH_EraseAllPages_0: (+1)
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0xBD02             POP      {R1,PC}
    543          }
    544          
    545          /**
    546            * @brief  Erases all Bank1 FLASH pages.
    547            * @note   This function can be used for all STM32F10x devices.
    548            *         - For STM32F10X_XL devices this function erases all Bank1 pages.
    549            *         - For all other devices it erases all Bank1 pages and it is equivalent 
    550            *           to FLASH_EraseAllPages function.
    551            * @param  None
    552            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    553            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    554            */

   \                                 In section .text, align 2, keep-with-next
    555          FLASH_Status FLASH_EraseAllBank1Pages(void)
    556          {
   \                     FLASH_EraseAllBank1Pages: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    557            FLASH_Status status = FLASH_COMPLETE;
   \        0x2   0x2004             MOVS     R0,#+4
    558            /* Wait for last operation to be completed */
    559            status = FLASH_WaitForLastBank1Operation(EraseTimeout);
   \        0x4   0xF45F 0x2030      MOVS     R0,#+720896
   \        0x8   0x.... 0x....      BL       FLASH_WaitForLastBank1Operation
    560            
    561            if(status == FLASH_COMPLETE)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0x2904             CMP      R1,#+4
   \       0x12   0xD11C             BNE.N    ??FLASH_EraseAllBank1Pages_0
    562            {
    563              /* if the previous operation is completed, proceed to erase all pages */
    564               FLASH->CR |= CR_MER_Set;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x22   0x6008             STR      R0,[R1, #+0]
    565               FLASH->CR |= CR_STRT_Set;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x32   0x6008             STR      R0,[R1, #+0]
    566              
    567              /* Wait for last operation to be completed */
    568              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
   \       0x34   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x38   0x.... 0x....      BL       FLASH_WaitForLastBank1Operation
    569              
    570              /* Disable the MER Bit */
    571              FLASH->CR &= CR_MER_Reset;
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x40   0x680A             LDR      R2,[R1, #+0]
   \       0x42   0xF641 0x71FB      MOVW     R1,#+8187
   \       0x46   0x400A             ANDS     R2,R1,R2
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x4C   0x600A             STR      R2,[R1, #+0]
    572            }    
    573            /* Return the Erase Status */
    574            return status;
   \                     ??FLASH_EraseAllBank1Pages_0: (+1)
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0xBD02             POP      {R1,PC}
    575          }
    576          
    577          #ifdef STM32F10X_XL
    578          /**
    579            * @brief  Erases all Bank2 FLASH pages.
    580            * @note   This function can be used only for STM32F10x_XL density devices.
    581            * @param  None
    582            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    583            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    584            */
    585          FLASH_Status FLASH_EraseAllBank2Pages(void)
    586          {
    587            FLASH_Status status = FLASH_COMPLETE;
    588            /* Wait for last operation to be completed */
    589            status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    590            
    591            if(status == FLASH_COMPLETE)
    592            {
    593              /* if the previous operation is completed, proceed to erase all pages */
    594               FLASH->CR2 |= CR_MER_Set;
    595               FLASH->CR2 |= CR_STRT_Set;
    596              
    597              /* Wait for last operation to be completed */
    598              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    599          
    600              /* Disable the MER Bit */
    601              FLASH->CR2 &= CR_MER_Reset;
    602            }    
    603            /* Return the Erase Status */
    604            return status;
    605          }
    606          #endif /* STM32F10X_XL */
    607          
    608          /**
    609            * @brief  Erases the FLASH option bytes.
    610            * @note   This functions erases all option bytes except the Read protection (RDP). 
    611            * @note   This function can be used for all STM32F10x devices.
    612            * @param  None
    613            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    614            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          FLASH_Status FLASH_EraseOptionBytes(void)
    617          {
   \                     FLASH_EraseOptionBytes: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    618            uint16_t rdptmp = RDP_Key;
   \        0x2   0x24A5             MOVS     R4,#+165
    619          
    620            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2004             MOVS     R0,#+4
    621          
    622            /* Get the actual read protection Option Byte value */ 
    623            if(FLASH_GetReadOutProtectionStatus() != RESET)
   \        0x6   0x.... 0x....      BL       FLASH_GetReadOutProtectionStatus
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD000             BEQ.N    ??FLASH_EraseOptionBytes_0
    624            {
    625              rdptmp = 0x00;  
   \        0xE   0x2400             MOVS     R4,#+0
    626            }
    627          
    628            /* Wait for last operation to be completed */
    629            status = FLASH_WaitForLastOperation(EraseTimeout);
   \                     ??FLASH_EraseOptionBytes_0: (+1)
   \       0x10   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x14   0x.... 0x....      BL       FLASH_WaitForLastOperation
    630            if(status == FLASH_COMPLETE)
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0xB2C9             UXTB     R1,R1
   \       0x1C   0x2904             CMP      R1,#+4
   \       0x1E   0xD154             BNE.N    ??FLASH_EraseOptionBytes_1
    631            {
    632              /* Authorize the small information block programming */
    633              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x24   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \       0x28   0x6008             STR      R0,[R1, #+0]
    634              FLASH->OPTKEYR = FLASH_KEY2;
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \       0x32   0x6008             STR      R0,[R1, #+0]
    635              
    636              /* if the previous operation is completed, proceed to erase the option bytes */
    637              FLASH->CR |= CR_OPTER_Set;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x42   0x6008             STR      R0,[R1, #+0]
    638              FLASH->CR |= CR_STRT_Set;
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x52   0x6008             STR      R0,[R1, #+0]
    639              /* Wait for last operation to be completed */
    640              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x54   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x58   0x.... 0x....      BL       FLASH_WaitForLastOperation
    641              
    642              if(status == FLASH_COMPLETE)
   \       0x5C   0x0001             MOVS     R1,R0
   \       0x5E   0xB2C9             UXTB     R1,R1
   \       0x60   0x2904             CMP      R1,#+4
   \       0x62   0xD125             BNE.N    ??FLASH_EraseOptionBytes_2
    643              {
    644                /* if the erase operation is completed, disable the OPTER Bit */
    645                FLASH->CR &= CR_OPTER_Reset;
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0xF641 0x70DF      MOVW     R0,#+8159
   \       0x6E   0x4001             ANDS     R1,R0,R1
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x74   0x6001             STR      R1,[R0, #+0]
    646                 
    647                /* Enable the Option Bytes Programming operation */
    648                FLASH->CR |= CR_OPTPG_Set;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x84   0x6008             STR      R0,[R1, #+0]
    649                /* Restore the last read protection Option Byte value */
    650                OB->RDP = (uint16_t)rdptmp; 
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable25_7
   \       0x8A   0x8004             STRH     R4,[R0, #+0]
    651                /* Wait for last operation to be completed */
    652                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x8C   0xF44F 0x5000      MOV      R0,#+8192
   \       0x90   0x.... 0x....      BL       FLASH_WaitForLastOperation
    653           
    654                if(status != FLASH_TIMEOUT)
   \       0x94   0x0001             MOVS     R1,R0
   \       0x96   0xB2C9             UXTB     R1,R1
   \       0x98   0x2905             CMP      R1,#+5
   \       0x9A   0xD016             BEQ.N    ??FLASH_EraseOptionBytes_1
    655                {
    656                  /* if the program operation is completed, disable the OPTPG Bit */
    657                  FLASH->CR &= CR_OPTPG_Reset;
   \       0x9C   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0xA0   0x680A             LDR      R2,[R1, #+0]
   \       0xA2   0xF641 0x71EF      MOVW     R1,#+8175
   \       0xA6   0x400A             ANDS     R2,R1,R2
   \       0xA8   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0xAC   0x600A             STR      R2,[R1, #+0]
   \       0xAE   0xE00C             B.N      ??FLASH_EraseOptionBytes_1
    658                }
    659              }
    660              else
    661              {
    662                if (status != FLASH_TIMEOUT)
   \                     ??FLASH_EraseOptionBytes_2: (+1)
   \       0xB0   0x0001             MOVS     R1,R0
   \       0xB2   0xB2C9             UXTB     R1,R1
   \       0xB4   0x2905             CMP      R1,#+5
   \       0xB6   0xD008             BEQ.N    ??FLASH_EraseOptionBytes_1
    663                {
    664                  /* Disable the OPTPG Bit */
    665                  FLASH->CR &= CR_OPTPG_Reset;
   \       0xB8   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0xBC   0x680A             LDR      R2,[R1, #+0]
   \       0xBE   0xF641 0x71EF      MOVW     R1,#+8175
   \       0xC2   0x400A             ANDS     R2,R1,R2
   \       0xC4   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0xC8   0x600A             STR      R2,[R1, #+0]
    666                }
    667              }  
    668            }
    669            /* Return the erase status */
    670            return status;
   \                     ??FLASH_EraseOptionBytes_1: (+1)
   \       0xCA   0xB2C0             UXTB     R0,R0
   \       0xCC   0xBD10             POP      {R4,PC}
    671          }
    672          
    673          /**
    674            * @brief  Programs a word at a specified address.
    675            * @note   This function can be used for all STM32F10x devices.
    676            * @param  Address: specifies the address to be programmed.
    677            * @param  Data: specifies the data to be programmed.
    678            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    679            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    680            */

   \                                 In section .text, align 2, keep-with-next
    681          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    682          {
   \                     FLASH_ProgramWord: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    683            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2004             MOVS     R0,#+4
    684            __IO uint32_t tmp = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
    685          
    686            /* Check the parameters */
    687            //assert_param(IS_FLASH_ADDRESS(Address));
    688          
    689          #ifdef STM32F10X_XL
    690            if(Address < FLASH_BANK1_END_ADDRESS - 2)
    691            { 
    692              /* Wait for last operation to be completed */
    693              status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
    694              if(status == FLASH_COMPLETE)
    695              {
    696                /* if the previous operation is completed, proceed to program the new first 
    697                  half word */
    698                FLASH->CR |= CR_PG_Set;
    699            
    700                *(__IO uint16_t*)Address = (uint16_t)Data;
    701                /* Wait for last operation to be completed */
    702                status = FLASH_WaitForLastOperation(ProgramTimeout);
    703           
    704                if(status == FLASH_COMPLETE)
    705                {
    706                  /* if the previous operation is completed, proceed to program the new second 
    707                  half word */
    708                  tmp = Address + 2;
    709          
    710                  *(__IO uint16_t*) tmp = Data >> 16;
    711              
    712                  /* Wait for last operation to be completed */
    713                  status = FLASH_WaitForLastOperation(ProgramTimeout);
    714                  
    715                  /* Disable the PG Bit */
    716                  FLASH->CR &= CR_PG_Reset;
    717                }
    718                else
    719                {
    720                  /* Disable the PG Bit */
    721                  FLASH->CR &= CR_PG_Reset;
    722                 }
    723              }
    724            }
    725            else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
    726            {
    727              /* Wait for last operation to be completed */
    728              status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    729          
    730              if(status == FLASH_COMPLETE)
    731              {
    732                /* if the previous operation is completed, proceed to program the new first 
    733                  half word */
    734                FLASH->CR |= CR_PG_Set;
    735            
    736                *(__IO uint16_t*)Address = (uint16_t)Data;
    737          
    738                /* Wait for last operation to be completed */
    739                status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    740                
    741          	  /* Disable the PG Bit */
    742                FLASH->CR &= CR_PG_Reset;
    743              }
    744              else
    745              {
    746                /* Disable the PG Bit */
    747                FLASH->CR &= CR_PG_Reset;
    748              }
    749          
    750              /* Wait for last operation to be completed */
    751              status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    752          
    753              if(status == FLASH_COMPLETE)
    754              {
    755                /* if the previous operation is completed, proceed to program the new second 
    756                half word */
    757                FLASH->CR2 |= CR_PG_Set;
    758                tmp = Address + 2;
    759          
    760                *(__IO uint16_t*) tmp = Data >> 16;
    761              
    762                /* Wait for last operation to be completed */
    763                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    764                  
    765                /* Disable the PG Bit */
    766                FLASH->CR2 &= CR_PG_Reset;
    767              }
    768              else
    769              {
    770                /* Disable the PG Bit */
    771                FLASH->CR2 &= CR_PG_Reset;
    772              }
    773            }
    774            else
    775            {
    776              /* Wait for last operation to be completed */
    777              status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    778          
    779              if(status == FLASH_COMPLETE)
    780              {
    781                /* if the previous operation is completed, proceed to program the new first 
    782                  half word */
    783                FLASH->CR2 |= CR_PG_Set;
    784            
    785                *(__IO uint16_t*)Address = (uint16_t)Data;
    786                /* Wait for last operation to be completed */
    787                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    788           
    789                if(status == FLASH_COMPLETE)
    790                {
    791                  /* if the previous operation is completed, proceed to program the new second 
    792                  half word */
    793                  tmp = Address + 2;
    794          
    795                  *(__IO uint16_t*) tmp = Data >> 16;
    796              
    797                  /* Wait for last operation to be completed */
    798                  status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    799                  
    800                  /* Disable the PG Bit */
    801                  FLASH->CR2 &= CR_PG_Reset;
    802                }
    803                else
    804                {
    805                  /* Disable the PG Bit */
    806                  FLASH->CR2 &= CR_PG_Reset;
    807                }
    808              }
    809            }
    810          #else
    811            /* Wait for last operation to be completed */
    812            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0xC   0xF44F 0x5000      MOV      R0,#+8192
   \       0x10   0x.... 0x....      BL       FLASH_WaitForLastOperation
    813            
    814            if(status == FLASH_COMPLETE)
   \       0x14   0x0001             MOVS     R1,R0
   \       0x16   0xB2C9             UXTB     R1,R1
   \       0x18   0x2904             CMP      R1,#+4
   \       0x1A   0xD12C             BNE.N    ??FLASH_ProgramWord_0
    815            {
    816              /* if the previous operation is completed, proceed to program the new first 
    817              half word */
    818              FLASH->CR |= CR_PG_Set;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x2A   0x6008             STR      R0,[R1, #+0]
    819            
    820              *(__IO uint16_t*)Address = (uint16_t)Data;
   \       0x2C   0x8025             STRH     R5,[R4, #+0]
    821              /* Wait for last operation to be completed */
    822              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x2E   0xF44F 0x5000      MOV      R0,#+8192
   \       0x32   0x.... 0x....      BL       FLASH_WaitForLastOperation
    823           
    824              if(status == FLASH_COMPLETE)
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0xB2C9             UXTB     R1,R1
   \       0x3A   0x2904             CMP      R1,#+4
   \       0x3C   0xD112             BNE.N    ??FLASH_ProgramWord_1
    825              {
    826                /* if the previous operation is completed, proceed to program the new second 
    827                half word */
    828                tmp = Address + 2;
   \       0x3E   0x1CA4             ADDS     R4,R4,#+2
   \       0x40   0x9400             STR      R4,[SP, #+0]
    829          
    830                *(__IO uint16_t*) tmp = Data >> 16;
   \       0x42   0x0C2D             LSRS     R5,R5,#+16
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0x8005             STRH     R5,[R0, #+0]
    831              
    832                /* Wait for last operation to be completed */
    833                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x48   0xF44F 0x5000      MOV      R0,#+8192
   \       0x4C   0x.... 0x....      BL       FLASH_WaitForLastOperation
    834                  
    835                /* Disable the PG Bit */
    836                FLASH->CR &= CR_PG_Reset;
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x54   0x680A             LDR      R2,[R1, #+0]
   \       0x56   0xF641 0x71FE      MOVW     R1,#+8190
   \       0x5A   0x400A             ANDS     R2,R1,R2
   \       0x5C   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x60   0x600A             STR      R2,[R1, #+0]
   \       0x62   0xE008             B.N      ??FLASH_ProgramWord_0
    837              }
    838              else
    839              {
    840                /* Disable the PG Bit */
    841                FLASH->CR &= CR_PG_Reset;
   \                     ??FLASH_ProgramWord_1: (+1)
   \       0x64   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x68   0x680A             LDR      R2,[R1, #+0]
   \       0x6A   0xF641 0x71FE      MOVW     R1,#+8190
   \       0x6E   0x400A             ANDS     R2,R1,R2
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x74   0x600A             STR      R2,[R1, #+0]
    842              }
    843            }         
    844          #endif /* STM32F10X_XL */
    845             
    846            /* Return the Program Status */
    847            return status;
   \                     ??FLASH_ProgramWord_0: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0xBD32             POP      {R1,R4,R5,PC}
    848          }
    849          
    850          /**
    851            * @brief  Programs a half word at a specified address.
    852            * @note   This function can be used for all STM32F10x devices.
    853            * @param  Address: specifies the address to be programmed.
    854            * @param  Data: specifies the data to be programmed.
    855            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    856            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    859          {
   \                     FLASH_ProgramHalfWord: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    860            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2004             MOVS     R0,#+4
    861            /* Check the parameters */
    862            //assert_param(IS_FLASH_ADDRESS(Address));
    863          
    864          #ifdef STM32F10X_XL
    865            /* Wait for last operation to be completed */
    866            status = FLASH_WaitForLastOperation(ProgramTimeout);
    867            
    868            if(Address < FLASH_BANK1_END_ADDRESS)
    869            {
    870              if(status == FLASH_COMPLETE)
    871              {
    872                /* if the previous operation is completed, proceed to program the new data */
    873                FLASH->CR |= CR_PG_Set;
    874            
    875                *(__IO uint16_t*)Address = Data;
    876                /* Wait for last operation to be completed */
    877                status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    878          
    879                /* Disable the PG Bit */
    880                FLASH->CR &= CR_PG_Reset;
    881              }
    882            }
    883            else
    884            {
    885              if(status == FLASH_COMPLETE)
    886              {
    887                /* if the previous operation is completed, proceed to program the new data */
    888                FLASH->CR2 |= CR_PG_Set;
    889            
    890                *(__IO uint16_t*)Address = Data;
    891                /* Wait for last operation to be completed */
    892                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    893          
    894                /* Disable the PG Bit */
    895                FLASH->CR2 &= CR_PG_Reset;
    896              }
    897            }
    898          #else
    899            /* Wait for last operation to be completed */
    900            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0x8   0xF44F 0x5000      MOV      R0,#+8192
   \        0xC   0x.... 0x....      BL       FLASH_WaitForLastOperation
    901            
    902            if(status == FLASH_COMPLETE)
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0xB2C9             UXTB     R1,R1
   \       0x14   0x2904             CMP      R1,#+4
   \       0x16   0xD115             BNE.N    ??FLASH_ProgramHalfWord_0
    903            {
    904              /* if the previous operation is completed, proceed to program the new data */
    905              FLASH->CR |= CR_PG_Set;
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x26   0x6008             STR      R0,[R1, #+0]
    906            
    907              *(__IO uint16_t*)Address = Data;
   \       0x28   0x8025             STRH     R5,[R4, #+0]
    908              /* Wait for last operation to be completed */
    909              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x2A   0xF44F 0x5000      MOV      R0,#+8192
   \       0x2E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    910              
    911              /* Disable the PG Bit */
    912              FLASH->CR &= CR_PG_Reset;
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x36   0x680A             LDR      R2,[R1, #+0]
   \       0x38   0xF641 0x71FE      MOVW     R1,#+8190
   \       0x3C   0x400A             ANDS     R2,R1,R2
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x42   0x600A             STR      R2,[R1, #+0]
    913            } 
    914          #endif  /* STM32F10X_XL */
    915            
    916            /* Return the Program Status */
    917            return status;
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}
    918          }
    919          
    920          /**
    921            * @brief  Programs a half word at a specified Option Byte Data address.
    922            * @note   This function can be used for all STM32F10x devices.
    923            * @param  Address: specifies the address to be programmed.
    924            *   This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    925            * @param  Data: specifies the data to be programmed.
    926            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    927            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    928            */

   \                                 In section .text, align 2, keep-with-next
    929          FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
    930          {
   \                     FLASH_ProgramOptionByteData: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    931            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2004             MOVS     R0,#+4
    932            /* Check the parameters */
    933            //assert_param(IS_OB_DATA_ADDRESS(Address));
    934            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0x8   0xF44F 0x5000      MOV      R0,#+8192
   \        0xC   0x.... 0x....      BL       FLASH_WaitForLastOperation
    935          
    936            if(status == FLASH_COMPLETE)
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0xB2C9             UXTB     R1,R1
   \       0x14   0x2904             CMP      R1,#+4
   \       0x16   0xD123             BNE.N    ??FLASH_ProgramOptionByteData_0
    937            {
    938              /* Authorize the small information block programming */
    939              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \       0x20   0x6008             STR      R0,[R1, #+0]
    940              FLASH->OPTKEYR = FLASH_KEY2;
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \       0x2A   0x6008             STR      R0,[R1, #+0]
    941              /* Enables the Option Bytes Programming operation */
    942              FLASH->CR |= CR_OPTPG_Set; 
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    943              *(__IO uint16_t*)Address = Data;
   \       0x3C   0xB2ED             UXTB     R5,R5
   \       0x3E   0x8025             STRH     R5,[R4, #+0]
    944              
    945              /* Wait for last operation to be completed */
    946              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x40   0xF44F 0x5000      MOV      R0,#+8192
   \       0x44   0x.... 0x....      BL       FLASH_WaitForLastOperation
    947              if(status != FLASH_TIMEOUT)
   \       0x48   0x0001             MOVS     R1,R0
   \       0x4A   0xB2C9             UXTB     R1,R1
   \       0x4C   0x2905             CMP      R1,#+5
   \       0x4E   0xD007             BEQ.N    ??FLASH_ProgramOptionByteData_0
    948              {
    949                /* if the program operation is completed, disable the OPTPG Bit */
    950                FLASH->CR &= CR_OPTPG_Reset;
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x54   0x680A             LDR      R2,[R1, #+0]
   \       0x56   0xF641 0x71EF      MOVW     R1,#+8175
   \       0x5A   0x400A             ANDS     R2,R1,R2
   \       0x5C   0x....             LDR.N    R1,??DataTable25_4
   \       0x5E   0x600A             STR      R2,[R1, #+0]
    951              }
    952            }
    953            /* Return the Option Byte Data Program Status */
    954            return status;
   \                     ??FLASH_ProgramOptionByteData_0: (+1)
   \       0x60   0xB2C0             UXTB     R0,R0
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    955          }
    956          
    957          /**
    958            * @brief  Write protects the desired pages
    959            * @note   This function can be used for all STM32F10x devices.
    960            * @param  FLASH_Pages: specifies the address of the pages to be write protected.
    961            *   This parameter can be:
    962            *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31  
    963            *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
    964            *       and FLASH_WRProt_Pages124to127
    965            *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
    966            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
    967            *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
    968            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127    
    969            *     @arg For @b STM32_XL-density_devices: value between FLASH_WRProt_Pages0to1 and
    970            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to511
    971            *     @arg FLASH_WRProt_AllPages
    972            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    973            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
    976          {
   \                     FLASH_EnableWriteProtection: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    977            uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
   \        0x4   0xF64F 0x70FF      MOVW     R0,#+65535
   \        0x8   0xF64F 0x70FF      MOVW     R0,#+65535
   \        0xC   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x10   0xF64F 0x70FF      MOVW     R0,#+65535
    978            
    979            FLASH_Status status = FLASH_COMPLETE;
   \       0x14   0x2004             MOVS     R0,#+4
    980            
    981            /* Check the parameters */
    982            //assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    983            
    984            FLASH_Pages = (uint32_t)(~FLASH_Pages);
   \       0x16   0x43E4             MVNS     R4,R4
    985            WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
   \       0x18   0xF014 0x05FF      ANDS     R5,R4,#0xFF
    986            WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0xF3C0 0x2607      UBFX     R6,R0,#+8,#+8
    987            WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
   \       0x22   0x0027             MOVS     R7,R4
   \       0x24   0x0C3F             LSRS     R7,R7,#+16
   \       0x26   0xF007 0x07FF      AND      R7,R7,#0xFF
    988            WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
   \       0x2A   0x0E24             LSRS     R4,R4,#+24
    989            
    990            /* Wait for last operation to be completed */
    991            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x2C   0xF44F 0x5000      MOV      R0,#+8192
   \       0x30   0x.... 0x....      BL       FLASH_WaitForLastOperation
    992            
    993            if(status == FLASH_COMPLETE)
   \       0x34   0x0001             MOVS     R1,R0
   \       0x36   0xB2C9             UXTB     R1,R1
   \       0x38   0x2904             CMP      R1,#+4
   \       0x3A   0xD14A             BNE.N    ??FLASH_EnableWriteProtection_0
    994            {
    995              /* Authorizes the small information block programming */
    996              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x3C   0x....             LDR.N    R1,??DataTable25_1
   \       0x3E   0x....             LDR.N    R2,??DataTable25_6
   \       0x40   0x6011             STR      R1,[R2, #+0]
    997              FLASH->OPTKEYR = FLASH_KEY2;
   \       0x42   0x....             LDR.N    R1,??DataTable25_3
   \       0x44   0x....             LDR.N    R2,??DataTable25_6
   \       0x46   0x6011             STR      R1,[R2, #+0]
    998              FLASH->CR |= CR_OPTPG_Set;
   \       0x48   0x....             LDR.N    R1,??DataTable25_4
   \       0x4A   0x6809             LDR      R1,[R1, #+0]
   \       0x4C   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x50   0x....             LDR.N    R2,??DataTable25_4
   \       0x52   0x6011             STR      R1,[R2, #+0]
    999              if(WRP0_Data != 0xFF)
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0xB289             UXTH     R1,R1
   \       0x58   0x29FF             CMP      R1,#+255
   \       0x5A   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_1
   1000              {
   1001                OB->WRP0 = WRP0_Data;
   \       0x5C   0x....             LDR.N    R0,??DataTable25_8
   \       0x5E   0x8005             STRH     R5,[R0, #+0]
   1002                
   1003                /* Wait for last operation to be completed */
   1004                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x60   0xF44F 0x5000      MOV      R0,#+8192
   \       0x64   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1005              }
   1006              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_1: (+1)
   \       0x68   0x0001             MOVS     R1,R0
   \       0x6A   0xB2C9             UXTB     R1,R1
   \       0x6C   0x2904             CMP      R1,#+4
   \       0x6E   0xD109             BNE.N    ??FLASH_EnableWriteProtection_2
   \       0x70   0x0031             MOVS     R1,R6
   \       0x72   0xB289             UXTH     R1,R1
   \       0x74   0x29FF             CMP      R1,#+255
   \       0x76   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_2
   1007              {
   1008                OB->WRP1 = WRP1_Data;
   \       0x78   0x....             LDR.N    R0,??DataTable25_9
   \       0x7A   0x8006             STRH     R6,[R0, #+0]
   1009                
   1010                /* Wait for last operation to be completed */
   1011                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x7C   0xF44F 0x5000      MOV      R0,#+8192
   \       0x80   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1012              }
   1013              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_2: (+1)
   \       0x84   0x0001             MOVS     R1,R0
   \       0x86   0xB2C9             UXTB     R1,R1
   \       0x88   0x2904             CMP      R1,#+4
   \       0x8A   0xD109             BNE.N    ??FLASH_EnableWriteProtection_3
   \       0x8C   0x0039             MOVS     R1,R7
   \       0x8E   0xB289             UXTH     R1,R1
   \       0x90   0x29FF             CMP      R1,#+255
   \       0x92   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_3
   1014              {
   1015                OB->WRP2 = WRP2_Data;
   \       0x94   0x....             LDR.N    R0,??DataTable25_10
   \       0x96   0x8007             STRH     R7,[R0, #+0]
   1016                
   1017                /* Wait for last operation to be completed */
   1018                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x98   0xF44F 0x5000      MOV      R0,#+8192
   \       0x9C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1019              }
   1020              
   1021              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_3: (+1)
   \       0xA0   0x0001             MOVS     R1,R0
   \       0xA2   0xB2C9             UXTB     R1,R1
   \       0xA4   0x2904             CMP      R1,#+4
   \       0xA6   0xD109             BNE.N    ??FLASH_EnableWriteProtection_4
   \       0xA8   0x0021             MOVS     R1,R4
   \       0xAA   0xB289             UXTH     R1,R1
   \       0xAC   0x29FF             CMP      R1,#+255
   \       0xAE   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_4
   1022              {
   1023                OB->WRP3 = WRP3_Data;
   \       0xB0   0x....             LDR.N    R0,??DataTable25_11
   \       0xB2   0x8004             STRH     R4,[R0, #+0]
   1024               
   1025                /* Wait for last operation to be completed */
   1026                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0xB4   0xF44F 0x5000      MOV      R0,#+8192
   \       0xB8   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1027              }
   1028                    
   1029              if(status != FLASH_TIMEOUT)
   \                     ??FLASH_EnableWriteProtection_4: (+1)
   \       0xBC   0x0001             MOVS     R1,R0
   \       0xBE   0xB2C9             UXTB     R1,R1
   \       0xC0   0x2905             CMP      R1,#+5
   \       0xC2   0xD006             BEQ.N    ??FLASH_EnableWriteProtection_0
   1030              {
   1031                /* if the program operation is completed, disable the OPTPG Bit */
   1032                FLASH->CR &= CR_OPTPG_Reset;
   \       0xC4   0x....             LDR.N    R1,??DataTable25_4
   \       0xC6   0x680A             LDR      R2,[R1, #+0]
   \       0xC8   0xF641 0x71EF      MOVW     R1,#+8175
   \       0xCC   0x400A             ANDS     R2,R1,R2
   \       0xCE   0x....             LDR.N    R1,??DataTable25_4
   \       0xD0   0x600A             STR      R2,[R1, #+0]
   1033              }
   1034            } 
   1035            /* Return the write protection operation Status */
   1036            return status;       
   \                     ??FLASH_EnableWriteProtection_0: (+1)
   \       0xD2   0xB2C0             UXTB     R0,R0
   \       0xD4   0xBDF2             POP      {R1,R4-R7,PC}
   1037          }
   1038          
   1039          /**
   1040            * @brief  Enables or disables the read out protection.
   1041            * @note   If the user has already programmed the other option bytes before calling 
   1042            *   this function, he must re-program them since this function erases all option bytes.
   1043            * @note   This function can be used for all STM32F10x devices.
   1044            * @param  Newstate: new state of the ReadOut Protection.
   1045            *   This parameter can be: ENABLE or DISABLE.
   1046            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1047            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1048            */

   \                                 In section .text, align 2, keep-with-next
   1049          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
   1050          {
   \                     FLASH_ReadOutProtection: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1051            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2004             MOVS     R0,#+4
   1052            /* Check the parameters */
   1053            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1054            status = FLASH_WaitForLastOperation(EraseTimeout);
   \        0x6   0xF45F 0x2030      MOVS     R0,#+720896
   \        0xA   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1055            if(status == FLASH_COMPLETE)
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x2904             CMP      R1,#+4
   \       0x14   0xD14B             BNE.N    ??FLASH_ReadOutProtection_0
   1056            {
   1057              /* Authorizes the small information block programming */
   1058              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x16   0x....             LDR.N    R0,??DataTable25_1
   \       0x18   0x....             LDR.N    R1,??DataTable25_6
   \       0x1A   0x6008             STR      R0,[R1, #+0]
   1059              FLASH->OPTKEYR = FLASH_KEY2;
   \       0x1C   0x....             LDR.N    R0,??DataTable25_3
   \       0x1E   0x....             LDR.N    R1,??DataTable25_6
   \       0x20   0x6008             STR      R0,[R1, #+0]
   1060              FLASH->CR |= CR_OPTER_Set;
   \       0x22   0x....             LDR.N    R0,??DataTable25_4
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x2A   0x....             LDR.N    R1,??DataTable25_4
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1061              FLASH->CR |= CR_STRT_Set;
   \       0x2E   0x....             LDR.N    R0,??DataTable25_4
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x36   0x....             LDR.N    R1,??DataTable25_4
   \       0x38   0x6008             STR      R0,[R1, #+0]
   1062              /* Wait for last operation to be completed */
   1063              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x3A   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x3E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1064              if(status == FLASH_COMPLETE)
   \       0x42   0x0001             MOVS     R1,R0
   \       0x44   0xB2C9             UXTB     R1,R1
   \       0x46   0x2904             CMP      R1,#+4
   \       0x48   0xD126             BNE.N    ??FLASH_ReadOutProtection_1
   1065              {
   1066                /* if the erase operation is completed, disable the OPTER Bit */
   1067                FLASH->CR &= CR_OPTER_Reset;
   \       0x4A   0x....             LDR.N    R0,??DataTable25_4
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF641 0x70DF      MOVW     R0,#+8159
   \       0x52   0x4001             ANDS     R1,R0,R1
   \       0x54   0x....             LDR.N    R0,??DataTable25_4
   \       0x56   0x6001             STR      R1,[R0, #+0]
   1068                /* Enable the Option Bytes Programming operation */
   1069                FLASH->CR |= CR_OPTPG_Set; 
   \       0x58   0x....             LDR.N    R0,??DataTable25_4
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x60   0x....             LDR.N    R1,??DataTable25_4
   \       0x62   0x6008             STR      R0,[R1, #+0]
   1070                if(NewState != DISABLE)
   \       0x64   0xB2E4             UXTB     R4,R4
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD003             BEQ.N    ??FLASH_ReadOutProtection_2
   1071                {
   1072                  OB->RDP = 0x00;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x....             LDR.N    R1,??DataTable25_7
   \       0x6E   0x8008             STRH     R0,[R1, #+0]
   \       0x70   0xE002             B.N      ??FLASH_ReadOutProtection_3
   1073                }
   1074                else
   1075                {
   1076                  OB->RDP = RDP_Key;  
   \                     ??FLASH_ReadOutProtection_2: (+1)
   \       0x72   0x20A5             MOVS     R0,#+165
   \       0x74   0x....             LDR.N    R1,??DataTable25_7
   \       0x76   0x8008             STRH     R0,[R1, #+0]
   1077                }
   1078                /* Wait for last operation to be completed */
   1079                status = FLASH_WaitForLastOperation(EraseTimeout); 
   \                     ??FLASH_ReadOutProtection_3: (+1)
   \       0x78   0xF45F 0x2030      MOVS     R0,#+720896
   \       0x7C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1080              
   1081                if(status != FLASH_TIMEOUT)
   \       0x80   0x0001             MOVS     R1,R0
   \       0x82   0xB2C9             UXTB     R1,R1
   \       0x84   0x2905             CMP      R1,#+5
   \       0x86   0xD012             BEQ.N    ??FLASH_ReadOutProtection_0
   1082                {
   1083                  /* if the program operation is completed, disable the OPTPG Bit */
   1084                  FLASH->CR &= CR_OPTPG_Reset;
   \       0x88   0x....             LDR.N    R1,??DataTable25_4
   \       0x8A   0x680A             LDR      R2,[R1, #+0]
   \       0x8C   0xF641 0x71EF      MOVW     R1,#+8175
   \       0x90   0x400A             ANDS     R2,R1,R2
   \       0x92   0x....             LDR.N    R1,??DataTable25_4
   \       0x94   0x600A             STR      R2,[R1, #+0]
   \       0x96   0xE00A             B.N      ??FLASH_ReadOutProtection_0
   1085                }
   1086              }
   1087              else 
   1088              {
   1089                if(status != FLASH_TIMEOUT)
   \                     ??FLASH_ReadOutProtection_1: (+1)
   \       0x98   0x0001             MOVS     R1,R0
   \       0x9A   0xB2C9             UXTB     R1,R1
   \       0x9C   0x2905             CMP      R1,#+5
   \       0x9E   0xD006             BEQ.N    ??FLASH_ReadOutProtection_0
   1090                {
   1091                  /* Disable the OPTER Bit */
   1092                  FLASH->CR &= CR_OPTER_Reset;
   \       0xA0   0x....             LDR.N    R1,??DataTable25_4
   \       0xA2   0x680A             LDR      R2,[R1, #+0]
   \       0xA4   0xF641 0x71DF      MOVW     R1,#+8159
   \       0xA8   0x400A             ANDS     R2,R1,R2
   \       0xAA   0x....             LDR.N    R1,??DataTable25_4
   \       0xAC   0x600A             STR      R2,[R1, #+0]
   1093                }
   1094              }
   1095            }
   1096            /* Return the protection operation Status */
   1097            return status;       
   \                     ??FLASH_ReadOutProtection_0: (+1)
   \       0xAE   0xB2C0             UXTB     R0,R0
   \       0xB0   0xBD10             POP      {R4,PC}
   1098          }
   1099          
   1100          /**
   1101            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1102            * @note   This function can be used for all STM32F10x devices.
   1103            * @param  OB_IWDG: Selects the IWDG mode
   1104            *   This parameter can be one of the following values:
   1105            *     @arg OB_IWDG_SW: Software IWDG selected
   1106            *     @arg OB_IWDG_HW: Hardware IWDG selected
   1107            * @param  OB_STOP: Reset event when entering STOP mode.
   1108            *   This parameter can be one of the following values:
   1109            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1110            *     @arg OB_STOP_RST: Reset generated when entering in STOP
   1111            * @param  OB_STDBY: Reset event when entering Standby mode.
   1112            *   This parameter can be one of the following values:
   1113            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1114            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1115            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
   1116            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1117            */

   \                                 In section .text, align 2, keep-with-next
   1118          FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
   1119          {
   \                     FLASH_UserOptionByteConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1120            FLASH_Status status = FLASH_COMPLETE; 
   \        0x8   0x2004             MOVS     R0,#+4
   1121          
   1122            /* Check the parameters */
   1123            //assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1124            //assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1125            //assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1126          
   1127            /* Authorize the small information block programming */
   1128            FLASH->OPTKEYR = FLASH_KEY1;
   \        0xA   0x....             LDR.N    R0,??DataTable25_1
   \        0xC   0x....             LDR.N    R1,??DataTable25_6
   \        0xE   0x6008             STR      R0,[R1, #+0]
   1129            FLASH->OPTKEYR = FLASH_KEY2;
   \       0x10   0x....             LDR.N    R0,??DataTable25_3
   \       0x12   0x....             LDR.N    R1,??DataTable25_6
   \       0x14   0x6008             STR      R0,[R1, #+0]
   1130            
   1131            /* Wait for last operation to be completed */
   1132            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x16   0xF44F 0x5000      MOV      R0,#+8192
   \       0x1A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1133            
   1134            if(status == FLASH_COMPLETE)
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x2904             CMP      R1,#+4
   \       0x24   0xD11A             BNE.N    ??FLASH_UserOptionByteConfig_0
   1135            {  
   1136              /* Enable the Option Bytes Programming operation */
   1137              FLASH->CR |= CR_OPTPG_Set; 
   \       0x26   0x....             LDR.N    R0,??DataTable25_4
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x2E   0x....             LDR.N    R1,??DataTable25_4
   \       0x30   0x6008             STR      R0,[R1, #+0]
   1138                     
   1139              OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
   \       0x32   0x432C             ORRS     R4,R5,R4
   \       0x34   0x4334             ORRS     R4,R6,R4
   \       0x36   0xF054 0x04F8      ORRS     R4,R4,#0xF8
   \       0x3A   0x....             LDR.N    R0,??DataTable25_12
   \       0x3C   0x8004             STRH     R4,[R0, #+0]
   1140            
   1141              /* Wait for last operation to be completed */
   1142              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x3E   0xF44F 0x5000      MOV      R0,#+8192
   \       0x42   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1143              if(status != FLASH_TIMEOUT)
   \       0x46   0x0001             MOVS     R1,R0
   \       0x48   0xB2C9             UXTB     R1,R1
   \       0x4A   0x2905             CMP      R1,#+5
   \       0x4C   0xD006             BEQ.N    ??FLASH_UserOptionByteConfig_0
   1144              {
   1145                /* if the program operation is completed, disable the OPTPG Bit */
   1146                FLASH->CR &= CR_OPTPG_Reset;
   \       0x4E   0x....             LDR.N    R1,??DataTable25_4
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0xF641 0x71EF      MOVW     R1,#+8175
   \       0x56   0x400A             ANDS     R2,R1,R2
   \       0x58   0x....             LDR.N    R1,??DataTable25_4
   \       0x5A   0x600A             STR      R2,[R1, #+0]
   1147              }
   1148            }    
   1149            /* Return the Option Byte program Status */
   1150            return status;
   \                     ??FLASH_UserOptionByteConfig_0: (+1)
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0xBD70             POP      {R4-R6,PC}
   1151          }
   1152          
   1153          #ifdef STM32F10X_XL
   1154          /**
   1155            * @brief  Configures to boot from Bank1 or Bank2.  
   1156            * @note   This function can be used only for STM32F10x_XL density devices.
   1157            * @param  FLASH_BOOT: select the FLASH Bank to boot from.
   1158            *   This parameter can be one of the following values:
   1159            *     @arg FLASH_BOOT_Bank1: At startup, if boot pins are set in boot from user Flash
   1160            *        position and this parameter is selected the device will boot from Bank1(Default).
   1161            *     @arg FLASH_BOOT_Bank2: At startup, if boot pins are set in boot from user Flash
   1162            *        position and this parameter is selected the device will boot from Bank2 or Bank1,
   1163            *        depending on the activation of the bank. The active banks are checked in
   1164            *        the following order: Bank2, followed by Bank1.
   1165            *        The active bank is recognized by the value programmed at the base address
   1166            *        of the respective bank (corresponding to the initial stack pointer value
   1167            *        in the interrupt vector table).
   1168            *        For more information, please refer to AN2606 from www.st.com.    
   1169            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
   1170            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1171            */
   1172          FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)
   1173          { 
   1174            FLASH_Status status = FLASH_COMPLETE; 
   1175            //assert_param(IS_FLASH_BOOT(FLASH_BOOT));
   1176            /* Authorize the small information block programming */
   1177            FLASH->OPTKEYR = FLASH_KEY1;
   1178            FLASH->OPTKEYR = FLASH_KEY2;
   1179            
   1180            /* Wait for last operation to be completed */
   1181            status = FLASH_WaitForLastOperation(ProgramTimeout);
   1182            
   1183            if(status == FLASH_COMPLETE)
   1184            {  
   1185              /* Enable the Option Bytes Programming operation */
   1186              FLASH->CR |= CR_OPTPG_Set; 
   1187          
   1188              if(FLASH_BOOT == FLASH_BOOT_Bank1)
   1189              {
   1190                OB->USER |= OB_USER_BFB2;
   1191              }
   1192              else
   1193              {
   1194                OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
   1195              }
   1196              /* Wait for last operation to be completed */
   1197              status = FLASH_WaitForLastOperation(ProgramTimeout);
   1198              if(status != FLASH_TIMEOUT)
   1199              {
   1200                /* if the program operation is completed, disable the OPTPG Bit */
   1201                FLASH->CR &= CR_OPTPG_Reset;
   1202              }
   1203            }    
   1204            /* Return the Option Byte program Status */
   1205            return status;
   1206          }
   1207          #endif /* STM32F10X_XL */
   1208          
   1209          /**
   1210            * @brief  Returns the FLASH User Option Bytes values.
   1211            * @note   This function can be used for all STM32F10x devices.
   1212            * @param  None
   1213            * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
   1214            *         and RST_STDBY(Bit2).
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216          uint32_t FLASH_GetUserOptionByte(void)
   1217          {
   1218            /* Return the User Option Byte */
   1219            return (uint32_t)(FLASH->OBR >> 2);
   \                     FLASH_GetUserOptionByte: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable25_13
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0880             LSRS     R0,R0,#+2
   \        0x6   0x4770             BX       LR
   1220          }
   1221          
   1222          /**
   1223            * @brief  Returns the FLASH Write Protection Option Bytes Register value.
   1224            * @note   This function can be used for all STM32F10x devices.
   1225            * @param  None
   1226            * @retval The FLASH Write Protection  Option Bytes Register value
   1227            */

   \                                 In section .text, align 2, keep-with-next
   1228          uint32_t FLASH_GetWriteProtectionOptionByte(void)
   1229          {
   1230            /* Return the Flash write protection Register value */
   1231            return (uint32_t)(FLASH->WRPR);
   \                     FLASH_GetWriteProtectionOptionByte: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable25_14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   1232          }
   1233          
   1234          /**
   1235            * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
   1236            * @note   This function can be used for all STM32F10x devices.
   1237            * @param  None
   1238            * @retval FLASH ReadOut Protection Status(SET or RESET)
   1239            */

   \                                 In section .text, align 2, keep-with-next
   1240          FlagStatus FLASH_GetReadOutProtectionStatus(void)
   1241          {
   1242            FlagStatus readoutstatus = RESET;
   \                     FLASH_GetReadOutProtectionStatus: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   1243            if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
   \        0x2   0x....             LDR.N    R0,??DataTable25_13
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0780             LSLS     R0,R0,#+30
   \        0x8   0xD501             BPL.N    ??FLASH_GetReadOutProtectionStatus_0
   1244            {
   1245              readoutstatus = SET;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??FLASH_GetReadOutProtectionStatus_1
   1246            }
   1247            else
   1248            {
   1249              readoutstatus = RESET;
   \                     ??FLASH_GetReadOutProtectionStatus_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   1250            }
   1251            return readoutstatus;
   \                     ??FLASH_GetReadOutProtectionStatus_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR
   1252          }
   1253          
   1254          /**
   1255            * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
   1256            * @note   This function can be used for all STM32F10x devices.
   1257            * @param  None
   1258            * @retval FLASH Prefetch Buffer Status (SET or RESET).
   1259            */

   \                                 In section .text, align 2, keep-with-next
   1260          FlagStatus FLASH_GetPrefetchBufferStatus(void)
   1261          {
   1262            FlagStatus bitstatus = RESET;
   \                     FLASH_GetPrefetchBufferStatus: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   1263            
   1264            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
   \        0x2   0x....             LDR.N    R0,??DataTable25
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0680             LSLS     R0,R0,#+26
   \        0x8   0xD501             BPL.N    ??FLASH_GetPrefetchBufferStatus_0
   1265            {
   1266              bitstatus = SET;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??FLASH_GetPrefetchBufferStatus_1
   1267            }
   1268            else
   1269            {
   1270              bitstatus = RESET;
   \                     ??FLASH_GetPrefetchBufferStatus_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   1271            }
   1272            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
   1273            return bitstatus; 
   \                     ??FLASH_GetPrefetchBufferStatus_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR
   1274          }
   1275          
   1276          /**
   1277            * @brief  Enables or disables the specified FLASH interrupts.
   1278            * @note   This function can be used for all STM32F10x devices.
   1279            *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts
   1280                        for Bank1 and Bank2.
   1281            *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.
   1282            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
   1283            *   This parameter can be any combination of the following values:
   1284            *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
   1285            *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
   1286            * @param  NewState: new state of the specified Flash interrupts.
   1287            *   This parameter can be: ENABLE or DISABLE.      
   1288            * @retval None 
   1289            */

   \                                 In section .text, align 2, keep-with-next
   1290          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1291          {
   1292          #ifdef STM32F10X_XL
   1293            /* Check the parameters */
   1294            //assert_param(IS_FLASH_IT(FLASH_IT));
   1295            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1296          
   1297            if((FLASH_IT & 0x80000000) != 0x0)
   1298            {
   1299              if(NewState != DISABLE)
   1300              {
   1301                /* Enable the interrupt sources */
   1302                FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
   1303              }
   1304              else
   1305              {
   1306                /* Disable the interrupt sources */
   1307                FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
   1308              }
   1309            }
   1310            else
   1311            {
   1312              if(NewState != DISABLE)
   1313              {
   1314                /* Enable the interrupt sources */
   1315                FLASH->CR |= FLASH_IT;
   1316              }
   1317              else
   1318              {
   1319                /* Disable the interrupt sources */
   1320                FLASH->CR &= ~(uint32_t)FLASH_IT;
   1321              }
   1322            }
   1323          #else
   1324            /* Check the parameters */
   1325            //assert_param(IS_FLASH_IT(FLASH_IT));
   1326            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1327          
   1328            if(NewState != DISABLE)
   \                     FLASH_ITConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD005             BEQ.N    ??FLASH_ITConfig_0
   1329            {
   1330              /* Enable the interrupt sources */
   1331              FLASH->CR |= FLASH_IT;
   \        0x6   0x....             LDR.N    R1,??DataTable25_4
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0x4308             ORRS     R0,R0,R1
   \        0xC   0x....             LDR.N    R1,??DataTable25_4
   \        0xE   0x6008             STR      R0,[R1, #+0]
   \       0x10   0xE005             B.N      ??FLASH_ITConfig_1
   1332            }
   1333            else
   1334            {
   1335              /* Disable the interrupt sources */
   1336              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_0: (+1)
   \       0x12   0x....             LDR.N    R1,??DataTable25_4
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0xEA31 0x0000      BICS     R0,R1,R0
   \       0x1A   0x....             LDR.N    R1,??DataTable25_4
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   1337            }
   1338          #endif /* STM32F10X_XL */
   1339          }
   \                     ??FLASH_ITConfig_1: (+1)
   \       0x1E   0x4770             BX       LR
   1340          
   1341          /**
   1342            * @brief  Checks whether the specified FLASH flag is set or not.
   1343            * @note   This function can be used for all STM32F10x devices.
   1344            *         - For STM32F10X_XL devices, this function checks whether the specified 
   1345            *           Bank1 or Bank2 flag is set or not.
   1346            *         - For other devices, it checks whether the specified Bank1 flag is 
   1347            *           set or not.
   1348            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1349            *   This parameter can be one of the following values:
   1350            *     @arg FLASH_FLAG_BSY: FLASH Busy flag           
   1351            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
   1352            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
   1353            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
   1354            *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
   1355            * @retval The new state of FLASH_FLAG (SET or RESET).
   1356            */

   \                                 In section .text, align 2, keep-with-next
   1357          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1358          {
   1359            FlagStatus bitstatus = RESET;
   \                     FLASH_GetFlagStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1360          
   1361          #ifdef STM32F10X_XL
   1362            /* Check the parameters */
   1363            //assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
   1364            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   1365            {
   1366              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
   1367              {
   1368                bitstatus = SET;
   1369              }
   1370              else
   1371              {
   1372                bitstatus = RESET;
   1373              }
   1374            }
   1375            else
   1376            {
   1377              if((FLASH_FLAG & 0x80000000) != 0x0)
   1378              {
   1379                if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
   1380                {
   1381                  bitstatus = SET;
   1382                }
   1383                else
   1384                {
   1385                  bitstatus = RESET;
   1386                }
   1387              }
   1388              else
   1389              {
   1390                if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   1391                {
   1392                  bitstatus = SET;
   1393                }
   1394                else
   1395                {
   1396                  bitstatus = RESET;
   1397                }
   1398              }
   1399            }
   1400          #else
   1401            /* Check the parameters */
   1402            //assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
   1403            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   \        0x2   0x2801             CMP      R0,#+1
   \        0x4   0xD107             BNE.N    ??FLASH_GetFlagStatus_0
   1404            {
   1405              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
   \        0x6   0x....             LDR.N    R0,??DataTable25_13
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x07C0             LSLS     R0,R0,#+31
   \        0xC   0xD501             BPL.N    ??FLASH_GetFlagStatus_1
   1406              {
   1407                bitstatus = SET;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE008             B.N      ??FLASH_GetFlagStatus_2
   1408              }
   1409              else
   1410              {
   1411                bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE006             B.N      ??FLASH_GetFlagStatus_2
   1412              }
   1413            }
   1414            else
   1415            {
   1416             if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable25_15
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x4201             TST      R1,R0
   \       0x1C   0xD001             BEQ.N    ??FLASH_GetFlagStatus_3
   1417              {
   1418                bitstatus = SET;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??FLASH_GetFlagStatus_2
   1419              }
   1420              else
   1421              {
   1422                bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_3: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   1423              }
   1424            }
   1425          #endif /* STM32F10X_XL */
   1426          
   1427            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1428            return bitstatus;
   \                     ??FLASH_GetFlagStatus_2: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x4770             BX       LR
   1429          }
   1430          
   1431          /**
   1432            * @brief  Clears the FLASH's pending flags.
   1433            * @note   This function can be used for all STM32F10x devices.
   1434            *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2s pending flags
   1435            *         - For other devices, it clears Bank1s pending flags.
   1436            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1437            *   This parameter can be any combination of the following values:         
   1438            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
   1439            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
   1440            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
   1441            * @retval None
   1442            */

   \                                 In section .text, align 2, keep-with-next
   1443          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1444          {
   1445          #ifdef STM32F10X_XL
   1446            /* Check the parameters */
   1447            //assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
   1448          
   1449            if((FLASH_FLAG & 0x80000000) != 0x0)
   1450            {
   1451              /* Clear the flags */
   1452              FLASH->SR2 = FLASH_FLAG;
   1453            }
   1454            else
   1455            {
   1456              /* Clear the flags */
   1457              FLASH->SR = FLASH_FLAG;
   1458            }  
   1459          
   1460          #else
   1461            /* Check the parameters */
   1462            //assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
   1463            
   1464            /* Clear the flags */
   1465            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable25_15
   \        0x2   0x6008             STR      R0,[R1, #+0]
   1466          #endif /* STM32F10X_XL */
   1467          }
   \        0x4   0x4770             BX       LR
   1468          
   1469          /**
   1470            * @brief  Returns the FLASH Status.
   1471            * @note   This function can be used for all STM32F10x devices, it is equivalent
   1472            *         to FLASH_GetBank1Status function.
   1473            * @param  None
   1474            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1475            *         FLASH_ERROR_WRP or FLASH_COMPLETE
   1476            */

   \                                 In section .text, align 2, keep-with-next
   1477          FLASH_Status FLASH_GetStatus(void)
   1478          {
   1479            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \        0x0   0x2004             MOVS     R0,#+4
   1480            
   1481            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \        0x2   0x....             LDR.N    R0,??DataTable25_15
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x07C0             LSLS     R0,R0,#+31
   \        0x8   0xD501             BPL.N    ??FLASH_GetStatus_0
   1482            {
   1483              flashstatus = FLASH_BUSY;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE00C             B.N      ??FLASH_GetStatus_1
   1484            }
   1485            else 
   1486            {  
   1487              if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
   \                     ??FLASH_GetStatus_0: (+1)
   \        0xE   0x....             LDR.N    R0,??DataTable25_15
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x0740             LSLS     R0,R0,#+29
   \       0x14   0xD501             BPL.N    ??FLASH_GetStatus_2
   1488              { 
   1489                flashstatus = FLASH_ERROR_PG;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE006             B.N      ??FLASH_GetStatus_1
   1490              }
   1491              else 
   1492              {
   1493                if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
   \                     ??FLASH_GetStatus_2: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable25_15
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x06C0             LSLS     R0,R0,#+27
   \       0x20   0xD501             BPL.N    ??FLASH_GetStatus_3
   1494                {
   1495                  flashstatus = FLASH_ERROR_WRP;
   \       0x22   0x2003             MOVS     R0,#+3
   \       0x24   0xE000             B.N      ??FLASH_GetStatus_1
   1496                }
   1497                else
   1498                {
   1499                  flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_3: (+1)
   \       0x26   0x2004             MOVS     R0,#+4
   1500                }
   1501              }
   1502            }
   1503            /* Return the Flash Status */
   1504            return flashstatus;
   \                     ??FLASH_GetStatus_1: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x4770             BX       LR
   1505          }
   1506          
   1507          /**
   1508            * @brief  Returns the FLASH Bank1 Status.
   1509            * @note   This function can be used for all STM32F10x devices, it is equivalent
   1510            *         to FLASH_GetStatus function.
   1511            * @param  None
   1512            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1513            *         FLASH_ERROR_WRP or FLASH_COMPLETE
   1514            */

   \                                 In section .text, align 2, keep-with-next
   1515          FLASH_Status FLASH_GetBank1Status(void)
   1516          {
   1517            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetBank1Status: (+1)
   \        0x0   0x2004             MOVS     R0,#+4
   1518            
   1519            if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
   \        0x2   0x....             LDR.N    R0,??DataTable25_15
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x07C0             LSLS     R0,R0,#+31
   \        0x8   0xD501             BPL.N    ??FLASH_GetBank1Status_0
   1520            {
   1521              flashstatus = FLASH_BUSY;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE00C             B.N      ??FLASH_GetBank1Status_1
   1522            }
   1523            else 
   1524            {  
   1525              if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
   \                     ??FLASH_GetBank1Status_0: (+1)
   \        0xE   0x....             LDR.N    R0,??DataTable25_15
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x0740             LSLS     R0,R0,#+29
   \       0x14   0xD501             BPL.N    ??FLASH_GetBank1Status_2
   1526              { 
   1527                flashstatus = FLASH_ERROR_PG;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE006             B.N      ??FLASH_GetBank1Status_1
   1528              }
   1529              else 
   1530              {
   1531                if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
   \                     ??FLASH_GetBank1Status_2: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable25_15
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x06C0             LSLS     R0,R0,#+27
   \       0x20   0xD501             BPL.N    ??FLASH_GetBank1Status_3
   1532                {
   1533                  flashstatus = FLASH_ERROR_WRP;
   \       0x22   0x2003             MOVS     R0,#+3
   \       0x24   0xE000             B.N      ??FLASH_GetBank1Status_1
   1534                }
   1535                else
   1536                {
   1537                  flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetBank1Status_3: (+1)
   \       0x26   0x2004             MOVS     R0,#+4
   1538                }
   1539              }
   1540            }
   1541            /* Return the Flash Status */
   1542            return flashstatus;
   \                     ??FLASH_GetBank1Status_1: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x4770             BX       LR
   1543          }
   1544          
   1545          #ifdef STM32F10X_XL
   1546          /**
   1547            * @brief  Returns the FLASH Bank2 Status.
   1548            * @note   This function can be used for STM32F10x_XL density devices.
   1549            * @param  None
   1550            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1551            *        FLASH_ERROR_WRP or FLASH_COMPLETE
   1552            */
   1553          FLASH_Status FLASH_GetBank2Status(void)
   1554          {
   1555            FLASH_Status flashstatus = FLASH_COMPLETE;
   1556            
   1557            if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) 
   1558            {
   1559              flashstatus = FLASH_BUSY;
   1560            }
   1561            else 
   1562            {  
   1563              if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)
   1564              { 
   1565                flashstatus = FLASH_ERROR_PG;
   1566              }
   1567              else 
   1568              {
   1569                if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )
   1570                {
   1571                  flashstatus = FLASH_ERROR_WRP;
   1572                }
   1573                else
   1574                {
   1575                  flashstatus = FLASH_COMPLETE;
   1576                }
   1577              }
   1578            }
   1579            /* Return the Flash Status */
   1580            return flashstatus;
   1581          }
   1582          #endif /* STM32F10X_XL */
   1583          /**
   1584            * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
   1585            * @note   This function can be used for all STM32F10x devices, 
   1586            *         it is equivalent to FLASH_WaitForLastBank1Operation.
   1587            *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation
   1588            *           to complete or a TIMEOUT to occur.
   1589            *         - For all other devices it waits for a Flash operation to complete 
   1590            *           or a TIMEOUT to occur.
   1591            * @param  Timeout: FLASH programming Timeout
   1592            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1593            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1594            */

   \                                 In section .text, align 2, keep-with-next
   1595          FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
   1596          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1597            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2004             MOVS     R0,#+4
   1598             
   1599            /* Check for the Flash Status */
   1600            status = FLASH_GetBank1Status();
   \        0x6   0x.... 0x....      BL       FLASH_GetBank1Status
   \        0xA   0xE002             B.N      ??FLASH_WaitForLastOperation_0
   1601            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1602            while((status == FLASH_BUSY) && (Timeout != 0x00))
   1603            {
   1604              status = FLASH_GetBank1Status();
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \        0xC   0x.... 0x....      BL       FLASH_GetBank1Status
   1605              Timeout--;
   \       0x10   0x1E64             SUBS     R4,R4,#+1
   1606            }
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB2C9             UXTB     R1,R1
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD101             BNE.N    ??FLASH_WaitForLastOperation_2
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD1F6             BNE.N    ??FLASH_WaitForLastOperation_1
   1607            if(Timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD100             BNE.N    ??FLASH_WaitForLastOperation_3
   1608            {
   1609              status = FLASH_TIMEOUT;
   \       0x22   0x2005             MOVS     R0,#+5
   1610            }
   1611            /* Return the operation status */
   1612            return status;
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0xBD10             POP      {R4,PC}
   1613          }
   1614          
   1615          /**
   1616            * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.
   1617            * @note   This function can be used for all STM32F10x devices, 
   1618            *         it is equivalent to FLASH_WaitForLastOperation.
   1619            * @param  Timeout: FLASH programming Timeout
   1620            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1621            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1622            */

   \                                 In section .text, align 2, keep-with-next
   1623          FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
   1624          { 
   \                     FLASH_WaitForLastBank1Operation: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1625            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2004             MOVS     R0,#+4
   1626             
   1627            /* Check for the Flash Status */
   1628            status = FLASH_GetBank1Status();
   \        0x6   0x.... 0x....      BL       FLASH_GetBank1Status
   \        0xA   0xE002             B.N      ??FLASH_WaitForLastBank1Operation_0
   1629            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1630            while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
   1631            {
   1632              status = FLASH_GetBank1Status();
   \                     ??FLASH_WaitForLastBank1Operation_1: (+1)
   \        0xC   0x.... 0x....      BL       FLASH_GetBank1Status
   1633              Timeout--;
   \       0x10   0x1E64             SUBS     R4,R4,#+1
   1634            }
   \                     ??FLASH_WaitForLastBank1Operation_0: (+1)
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB2C9             UXTB     R1,R1
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD101             BNE.N    ??FLASH_WaitForLastBank1Operation_2
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD1F6             BNE.N    ??FLASH_WaitForLastBank1Operation_1
   1635            if(Timeout == 0x00 )
   \                     ??FLASH_WaitForLastBank1Operation_2: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD100             BNE.N    ??FLASH_WaitForLastBank1Operation_3
   1636            {
   1637              status = FLASH_TIMEOUT;
   \       0x22   0x2005             MOVS     R0,#+5
   1638            }
   1639            /* Return the operation status */
   1640            return status;
   \                     ??FLASH_WaitForLastBank1Operation_3: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0xBD10             POP      {R4,PC}
   1641          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x4002'2004        DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \        0x0   0x4002'2010        DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \        0x0   0x4002'2014        DC32     0x40022014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \        0x0   0x4002'2008        DC32     0x40022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \        0x0   0x1FFF'F800        DC32     0x1ffff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \        0x0   0x1FFF'F808        DC32     0x1ffff808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \        0x0   0x1FFF'F80A        DC32     0x1ffff80a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \        0x0   0x1FFF'F80C        DC32     0x1ffff80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \        0x0   0x1FFF'F80E        DC32     0x1ffff80e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \        0x0   0x1FFF'F802        DC32     0x1ffff802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \        0x0   0x4002'201C        DC32     0x4002201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \        0x0   0x4002'2020        DC32     0x40022020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \        0x0   0x4002'200C        DC32     0x4002200c
   1642          
   1643          #ifdef STM32F10X_XL
   1644          /**
   1645            * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.
   1646            * @note   This function can be used only for STM32F10x_XL density devices.
   1647            * @param  Timeout: FLASH programming Timeout
   1648            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1649            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1650            */
   1651          FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)
   1652          { 
   1653            FLASH_Status status = FLASH_COMPLETE;
   1654             
   1655            /* Check for the Flash Status */
   1656            status = FLASH_GetBank2Status();
   1657            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1658            while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))
   1659            {
   1660              status = FLASH_GetBank2Status();
   1661              Timeout--;
   1662            }
   1663            if(Timeout == 0x00 )
   1664            {
   1665              status = FLASH_TIMEOUT;
   1666            }
   1667            /* Return the operation status */
   1668            return status;
   1669          }
   1670          #endif /* STM32F10X_XL */
   1671          
   1672          /**
   1673            * @}
   1674            */
   1675          
   1676          /**
   1677            * @}
   1678            */
   1679          
   1680          /**
   1681            * @}
   1682            */
   1683          
   1684          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
      24   FLASH_EnableWriteProtection
        24   -> FLASH_WaitForLastOperation
       8   FLASH_EraseAllBank1Pages
         8   -> FLASH_WaitForLastBank1Operation
       8   FLASH_EraseAllPages
         8   -> FLASH_WaitForLastOperation
       8   FLASH_EraseOptionBytes
         8   -> FLASH_GetReadOutProtectionStatus
         8   -> FLASH_WaitForLastOperation
       8   FLASH_ErasePage
         8   -> FLASH_WaitForLastOperation
       0   FLASH_GetBank1Status
       0   FLASH_GetFlagStatus
       0   FLASH_GetPrefetchBufferStatus
       0   FLASH_GetReadOutProtectionStatus
       0   FLASH_GetStatus
       0   FLASH_GetUserOptionByte
       0   FLASH_GetWriteProtectionOptionByte
       0   FLASH_HalfCycleAccessCmd
       0   FLASH_ITConfig
       0   FLASH_Lock
       0   FLASH_LockBank1
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramOptionByteData
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
       8   FLASH_ReadOutProtection
         8   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       0   FLASH_UnlockBank1
      16   FLASH_UserOptionByteConfig
        16   -> FLASH_WaitForLastOperation
       8   FLASH_WaitForLastBank1Operation
         8   -> FLASH_GetBank1Status
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetBank1Status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
       6  FLASH_ClearFlag
     214  FLASH_EnableWriteProtection
      82  FLASH_EraseAllBank1Pages
      82  FLASH_EraseAllPages
     206  FLASH_EraseOptionBytes
      90  FLASH_ErasePage
      44  FLASH_GetBank1Status
      40  FLASH_GetFlagStatus
      20  FLASH_GetPrefetchBufferStatus
      20  FLASH_GetReadOutProtectionStatus
      44  FLASH_GetStatus
       8  FLASH_GetUserOptionByte
       6  FLASH_GetWriteProtectionOptionByte
      32  FLASH_HalfCycleAccessCmd
      32  FLASH_ITConfig
      18  FLASH_Lock
      18  FLASH_LockBank1
      32  FLASH_PrefetchBufferCmd
      72  FLASH_ProgramHalfWord
     100  FLASH_ProgramOptionByteData
     122  FLASH_ProgramWord
     178  FLASH_ReadOutProtection
      22  FLASH_SetLatency
      22  FLASH_Unlock
      22  FLASH_UnlockBank1
      96  FLASH_UserOptionByteConfig
      40  FLASH_WaitForLastBank1Operation
      40  FLASH_WaitForLastOperation

 
 1'772 bytes in section .text
 
 1'772 bytes of CODE memory

Errors: none
Warnings: none
