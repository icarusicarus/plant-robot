###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         03/Nov/2021  18:48:25
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_adc.c
#    Command line      =
#        -f
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_adc.o.rsp
#        (C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_adc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries -o
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\inc\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\LCD\ -Ol -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_adc.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries\stm32f10x_adc.lst
#    Object file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_adc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_adc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the ADC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_adc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup ADC 
     31            * @brief ADC driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup ADC_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup ADC_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ADC DISCNUM mask */
     48          #define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
     49          
     50          /* ADC DISCEN mask */
     51          #define CR1_DISCEN_Set              ((uint32_t)0x00000800)
     52          #define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
     53          
     54          /* ADC JAUTO mask */
     55          #define CR1_JAUTO_Set               ((uint32_t)0x00000400)
     56          #define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
     57          
     58          /* ADC JDISCEN mask */
     59          #define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
     60          #define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
     61          
     62          /* ADC AWDCH mask */
     63          #define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
     64          
     65          /* ADC Analog watchdog enable mode mask */
     66          #define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
     67          
     68          /* CR1 register Mask */
     69          #define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
     70          
     71          /* ADC ADON mask */
     72          #define CR2_ADON_Set                ((uint32_t)0x00000001)
     73          #define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
     74          
     75          /* ADC DMA mask */
     76          #define CR2_DMA_Set                 ((uint32_t)0x00000100)
     77          #define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
     78          
     79          /* ADC RSTCAL mask */
     80          #define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
     81          
     82          /* ADC CAL mask */
     83          #define CR2_CAL_Set                 ((uint32_t)0x00000004)
     84          
     85          /* ADC SWSTART mask */
     86          #define CR2_SWSTART_Set             ((uint32_t)0x00400000)
     87          
     88          /* ADC EXTTRIG mask */
     89          #define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
     90          #define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
     91          
     92          /* ADC Software start mask */
     93          #define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
     94          #define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
     95          
     96          /* ADC JEXTSEL mask */
     97          #define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
     98          
     99          /* ADC JEXTTRIG mask */
    100          #define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
    101          #define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
    102          
    103          /* ADC JSWSTART mask */
    104          #define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
    105          
    106          /* ADC injected software start mask */
    107          #define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
    108          #define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
    109          
    110          /* ADC TSPD mask */
    111          #define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
    112          #define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
    113          
    114          /* CR2 register Mask */
    115          #define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
    116          
    117          /* ADC SQx mask */
    118          #define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
    119          #define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
    120          #define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
    121          
    122          /* SQR1 register Mask */
    123          #define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
    124          
    125          /* ADC JSQx mask */
    126          #define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
    127          
    128          /* ADC JL mask */
    129          #define JSQR_JL_Set                 ((uint32_t)0x00300000)
    130          #define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
    131          
    132          /* ADC SMPx mask */
    133          #define SMPR1_SMP_Set               ((uint32_t)0x00000007)
    134          #define SMPR2_SMP_Set               ((uint32_t)0x00000007)
    135          
    136          /* ADC JDRx registers offset */
    137          #define JDR_Offset                  ((uint8_t)0x28)
    138          
    139          /* ADC1 DR register base address */
    140          #define DR_ADDRESS                  ((uint32_t)0x4001244C)
    141          
    142          /**
    143            * @}
    144            */
    145          
    146          /** @defgroup ADC_Private_Macros
    147            * @{
    148            */
    149          
    150          /**
    151            * @}
    152            */
    153          
    154          /** @defgroup ADC_Private_Variables
    155            * @{
    156            */
    157          
    158          /**
    159            * @}
    160            */
    161          
    162          /** @defgroup ADC_Private_FunctionPrototypes
    163            * @{
    164            */
    165          
    166          /**
    167            * @}
    168            */
    169          
    170          /** @defgroup ADC_Private_Functions
    171            * @{
    172            */
    173          
    174          /**
    175            * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
    176            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    177            * @retval None
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void ADC_DeInit(ADC_TypeDef* ADCx)
    180          {
   \                     ADC_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    181            /* Check the parameters */
    182            ////assert_param(IS_ADC_ALL_PERIPH(ADCx));
    183            
    184            if (ADCx == ADC1)
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable4
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD10A             BNE.N    ??ADC_DeInit_0
    185            {
    186              /* Enable ADC1 reset state */
    187              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xF44F 0x7000      MOV      R0,#+512
   \       0x10   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    188              /* Release ADC1 from reset state */
    189              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xF44F 0x7000      MOV      R0,#+512
   \       0x1A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \       0x1E   0xE01C             B.N      ??ADC_DeInit_1
    190            }
    191            else if (ADCx == ADC2)
   \                     ??ADC_DeInit_0: (+1)
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD10A             BNE.N    ??ADC_DeInit_2
    192            {
    193              /* Enable ADC2 reset state */
    194              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0xF44F 0x6080      MOV      R0,#+1024
   \       0x2E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    195              /* Release ADC2 from reset state */
    196              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0xF44F 0x6080      MOV      R0,#+1024
   \       0x38   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \       0x3C   0xE00D             B.N      ??ADC_DeInit_1
    197            }
    198            else
    199            {
    200              if (ADCx == ADC3)
   \                     ??ADC_DeInit_2: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD109             BNE.N    ??ADC_DeInit_1
    201              {
    202                /* Enable ADC3 reset state */
    203                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
   \       0x46   0x2101             MOVS     R1,#+1
   \       0x48   0xF44F 0x4000      MOV      R0,#+32768
   \       0x4C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    204                /* Release ADC3 from reset state */
    205                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0xF44F 0x4000      MOV      R0,#+32768
   \       0x56   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    206              }
    207            }
    208          }
   \                     ??ADC_DeInit_1: (+1)
   \       0x5A   0xBD01             POP      {R0,PC}
    209          
    210          /**
    211            * @brief  Initializes the ADCx peripheral according to the specified parameters
    212            *         in the ADC_InitStruct.
    213            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    214            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    215            *         the configuration information for the specified ADC peripheral.
    216            * @retval None
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    219          {
   \                     ADC_Init: (+1)
   \        0x0   0xB410             PUSH     {R4}
    220            uint32_t tmpreg1 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    221            uint8_t tmpreg2 = 0;
   \        0x4   0x2300             MOVS     R3,#+0
    222            /* Check the parameters */
    223            /*
    224            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    225            //assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    226            //assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    227            //assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
    228            //assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));
    229            //assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
    230            //assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    231            */
    232            /*---------------------------- ADCx CR1 Configuration -----------------*/
    233            /* Get the ADCx CR1 value */
    234            tmpreg1 = ADCx->CR1;
   \        0x6   0x6844             LDR      R4,[R0, #+4]
    235            /* Clear DUALMOD and SCAN bits */
    236            tmpreg1 &= CR1_CLEAR_Mask;
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable4_3
   \        0xC   0x4014             ANDS     R4,R2,R4
    237            /* Configure ADCx: Dual mode and scan conversion mode */
    238            /* Set DUALMOD bits according to ADC_Mode value */
    239            /* Set SCAN bit according to ADC_ScanConvMode value */
    240            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x4314             ORRS     R4,R2,R4
   \       0x12   0x790A             LDRB     R2,[R1, #+4]
   \       0x14   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
    241            /* Write to ADCx CR1 */
    242            ADCx->CR1 = tmpreg1;
   \       0x18   0x6044             STR      R4,[R0, #+4]
    243          
    244            /*---------------------------- ADCx CR2 Configuration -----------------*/
    245            /* Get the ADCx CR2 value */
    246            tmpreg1 = ADCx->CR2;
   \       0x1A   0x6884             LDR      R4,[R0, #+8]
    247            /* Clear CONT, ALIGN and EXTSEL bits */
    248            tmpreg1 &= CR2_CLEAR_Mask;
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable4_4
   \       0x20   0x4014             ANDS     R4,R2,R4
    249            /* Configure ADCx: external trigger event and continuous conversion mode */
    250            /* Set ALIGN bit according to ADC_DataAlign value */
    251            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    252            /* Set CONT bit according to ADC_ContinuousConvMode value */
    253            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
    254                      ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
   \       0x22   0x68CA             LDR      R2,[R1, #+12]
   \       0x24   0x4314             ORRS     R4,R2,R4
   \       0x26   0x688A             LDR      R2,[R1, #+8]
   \       0x28   0x4314             ORRS     R4,R2,R4
   \       0x2A   0x794A             LDRB     R2,[R1, #+5]
   \       0x2C   0xEA54 0x0442      ORRS     R4,R4,R2, LSL #+1
    255            /* Write to ADCx CR2 */
    256            ADCx->CR2 = tmpreg1;
   \       0x30   0x6084             STR      R4,[R0, #+8]
    257          
    258            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    259            /* Get the ADCx SQR1 value */
    260            tmpreg1 = ADCx->SQR1;
   \       0x32   0x6AC2             LDR      R2,[R0, #+44]
    261            /* Clear L bits */
    262            tmpreg1 &= SQR1_CLEAR_Mask;
   \       0x34   0xF432 0x0270      BICS     R2,R2,#0xF00000
    263            /* Configure ADCx: regular channel sequence length */
    264            /* Set L bits according to ADC_NbrOfChannel value */
    265            tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
   \       0x38   0x7C09             LDRB     R1,[R1, #+16]
   \       0x3A   0x1E49             SUBS     R1,R1,#+1
   \       0x3C   0x430B             ORRS     R3,R1,R3
    266            tmpreg1 |= (uint32_t)tmpreg2 << 20;
   \       0x3E   0xB2DB             UXTB     R3,R3
   \       0x40   0xEA52 0x5203      ORRS     R2,R2,R3, LSL #+20
    267            /* Write to ADCx SQR1 */
    268            ADCx->SQR1 = tmpreg1;
   \       0x44   0x62C2             STR      R2,[R0, #+44]
    269          }
   \       0x46   0xBC10             POP      {R4}
   \       0x48   0x4770             BX       LR
    270          
    271          /**
    272            * @brief  Fills each ADC_InitStruct member with its default value.
    273            * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
    274            * @retval None
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    277          {
    278            /* Reset ADC init structure parameters values */
    279            /* Initialize the ADC_Mode member */
    280            ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
   \                     ADC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    281            /* initialize the ADC_ScanConvMode member */
    282            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7101             STRB     R1,[R0, #+4]
    283            /* Initialize the ADC_ContinuousConvMode member */
    284            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x7141             STRB     R1,[R0, #+5]
    285            /* Initialize the ADC_ExternalTrigConv member */
    286            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6081             STR      R1,[R0, #+8]
    287            /* Initialize the ADC_DataAlign member */
    288            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x60C1             STR      R1,[R0, #+12]
    289            /* Initialize the ADC_NbrOfChannel member */
    290            ADC_InitStruct->ADC_NbrOfChannel = 1;
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x7401             STRB     R1,[R0, #+16]
    291          }
   \       0x18   0x4770             BX       LR
    292          
    293          /**
    294            * @brief  Enables or disables the specified ADC peripheral.
    295            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    296            * @param  NewState: new state of the ADCx peripheral.
    297            *   This parameter can be: ENABLE or DISABLE.
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    301          {
    302            /* Check the parameters */
    303           /*
    304          	//assert_param(IS_ADC_ALL_PERIPH(ADCx));
    305            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    306            */
    307            if (NewState != DISABLE)
   \                     ADC_Cmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_Cmd_0
    308            {
    309              /* Set the ADON bit to wake up the ADC from power down mode */
    310              ADCx->CR2 |= CR2_ADON_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_Cmd_1
    311            }
    312            else
    313            {
    314              /* Disable the selected ADC peripheral */
    315              ADCx->CR2 &= CR2_ADON_Reset;
   \                     ??ADC_Cmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0x0849             LSRS     R1,R1,#+1
   \       0x14   0x0049             LSLS     R1,R1,#+1
   \       0x16   0x6081             STR      R1,[R0, #+8]
    316            }
    317          }
   \                     ??ADC_Cmd_1: (+1)
   \       0x18   0x4770             BX       LR
    318          
    319          /**
    320            * @brief  Enables or disables the specified ADC DMA request.
    321            * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
    322            *   Note: ADC2 hasn't a DMA capability.
    323            * @param  NewState: new state of the selected ADC DMA transfer.
    324            *   This parameter can be: ENABLE or DISABLE.
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    328          {
    329            /* Check the parameters */
    330          	/*
    331            //assert_param(IS_ADC_DMA_PERIPH(ADCx));
    332            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    333            */
    334            if (NewState != DISABLE)
   \                     ADC_DMACmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_DMACmd_0
    335            {
    336              /* Enable the selected ADC DMA request */
    337              ADCx->CR2 |= CR2_DMA_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF451 0x7180      ORRS     R1,R1,#0x100
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_DMACmd_1
    338            }
    339            else
    340            {
    341              /* Disable the selected ADC DMA request */
    342              ADCx->CR2 &= CR2_DMA_Reset;
   \                     ??ADC_DMACmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0xF431 0x7180      BICS     R1,R1,#0x100
   \       0x16   0x6081             STR      R1,[R0, #+8]
    343            }
    344          }
   \                     ??ADC_DMACmd_1: (+1)
   \       0x18   0x4770             BX       LR
    345          
    346          /**
    347            * @brief  Enables or disables the specified ADC interrupts.
    348            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    349            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
    350            *   This parameter can be any combination of the following values:
    351            *     @arg ADC_IT_EOC: End of conversion interrupt mask
    352            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
    353            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
    354            * @param  NewState: new state of the specified ADC interrupts.
    355            *   This parameter can be: ENABLE or DISABLE.
    356            * @retval None
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
    359          {
    360            uint8_t itmask = 0;
   \                     ADC_ITConfig: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
    361            /* Check the parameters */
    362            /*
    363            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    364            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    365            //assert_param(IS_ADC_IT(ADC_IT));
    366            */
    367            /* Get the ADC IT index */
    368            itmask = (uint8_t)ADC_IT;
    369            if (NewState != DISABLE)
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD004             BEQ.N    ??ADC_ITConfig_0
    370            {
    371              /* Enable the selected ADC interrupts */
    372              ADCx->CR1 |= itmask;
   \        0x8   0x6842             LDR      R2,[R0, #+4]
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x6041             STR      R1,[R0, #+4]
   \       0x10   0xE004             B.N      ??ADC_ITConfig_1
    373            }
    374            else
    375            {
    376              /* Disable the selected ADC interrupts */
    377              ADCx->CR1 &= (~(uint32_t)itmask);
   \                     ??ADC_ITConfig_0: (+1)
   \       0x12   0x6842             LDR      R2,[R0, #+4]
   \       0x14   0xB2C9             UXTB     R1,R1
   \       0x16   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x1A   0x6041             STR      R1,[R0, #+4]
    378            }
    379          }
   \                     ??ADC_ITConfig_1: (+1)
   \       0x1C   0x4770             BX       LR
    380          
    381          /**
    382            * @brief  Resets the selected ADC calibration registers.
    383            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    384            * @retval None
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          void ADC_ResetCalibration(ADC_TypeDef* ADCx)
    387          {
    388            /* Check the parameters */
    389            ////assert_param(IS_ADC_ALL_PERIPH(ADCx));
    390            /* Resets the selected ADC calibration registers */  
    391            ADCx->CR2 |= CR2_RSTCAL_Set;
   \                     ADC_ResetCalibration: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0xF051 0x0108      ORRS     R1,R1,#0x8
   \        0x6   0x6081             STR      R1,[R0, #+8]
    392          }
   \        0x8   0x4770             BX       LR
    393          
    394          /**
    395            * @brief  Gets the selected ADC reset calibration registers status.
    396            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    397            * @retval The new state of ADC reset calibration registers (SET or RESET).
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
    400          {
    401            FlagStatus bitstatus = RESET;
   \                     ADC_GetResetCalibrationStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    402            /* Check the parameters */
    403            ////assert_param(IS_ADC_ALL_PERIPH(ADCx));
    404            /* Check the status of RSTCAL bit */
    405            if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x0700             LSLS     R0,R0,#+28
   \        0x6   0xD501             BPL.N    ??ADC_GetResetCalibrationStatus_0
    406            {
    407              /* RSTCAL bit is set */
    408              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ADC_GetResetCalibrationStatus_1
    409            }
    410            else
    411            {
    412              /* RSTCAL bit is reset */
    413              bitstatus = RESET;
   \                     ??ADC_GetResetCalibrationStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    414            }
    415            /* Return the RSTCAL bit status */
    416            return  bitstatus;
   \                     ??ADC_GetResetCalibrationStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    417          }
    418          
    419          /**
    420            * @brief  Starts the selected ADC calibration process.
    421            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    422            * @retval None
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          void ADC_StartCalibration(ADC_TypeDef* ADCx)
    425          {
    426            /* Check the parameters */
    427           // //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    428            /* Enable the selected ADC calibration process */  
    429            ADCx->CR2 |= CR2_CAL_Set;
   \                     ADC_StartCalibration: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x6   0x6081             STR      R1,[R0, #+8]
    430          }
   \        0x8   0x4770             BX       LR
    431          
    432          /**
    433            * @brief  Gets the selected ADC calibration status.
    434            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    435            * @retval The new state of ADC calibration (SET or RESET).
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
    438          {
    439            FlagStatus bitstatus = RESET;
   \                     ADC_GetCalibrationStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    440            /* Check the parameters */
    441            ////assert_param(IS_ADC_ALL_PERIPH(ADCx));
    442            /* Check the status of CAL bit */
    443            if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x0740             LSLS     R0,R0,#+29
   \        0x6   0xD501             BPL.N    ??ADC_GetCalibrationStatus_0
    444            {
    445              /* CAL bit is set: calibration on going */
    446              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ADC_GetCalibrationStatus_1
    447            }
    448            else
    449            {
    450              /* CAL bit is reset: end of calibration */
    451              bitstatus = RESET;
   \                     ??ADC_GetCalibrationStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    452            }
    453            /* Return the CAL bit status */
    454            return  bitstatus;
   \                     ??ADC_GetCalibrationStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    455          }
    456          
    457          /**
    458            * @brief  Enables or disables the selected ADC software start conversion .
    459            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    460            * @param  NewState: new state of the selected ADC software start conversion.
    461            *   This parameter can be: ENABLE or DISABLE.
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    465          {
    466            /* Check the parameters */
    467            ////assert_param(IS_ADC_ALL_PERIPH(ADCx));
    468            ////assert_param(IS_FUNCTIONAL_STATE(NewState));
    469            if (NewState != DISABLE)
   \                     ADC_SoftwareStartConvCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_SoftwareStartConvCmd_0
    470            {
    471              /* Enable the selected ADC conversion on external event and start the selected
    472                 ADC conversion */
    473              ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF451 0x01A0      ORRS     R1,R1,#0x500000
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_SoftwareStartConvCmd_1
    474            }
    475            else
    476            {
    477              /* Disable the selected ADC conversion on external event and stop the selected
    478                 ADC conversion */
    479              ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
   \                     ??ADC_SoftwareStartConvCmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0xF431 0x01A0      BICS     R1,R1,#0x500000
   \       0x16   0x6081             STR      R1,[R0, #+8]
    480            }
    481          }
   \                     ??ADC_SoftwareStartConvCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    482          
    483          /**
    484            * @brief  Gets the selected ADC Software start conversion Status.
    485            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    486            * @retval The new state of ADC software start conversion (SET or RESET).
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    489          {
    490            FlagStatus bitstatus = RESET;
   \                     ADC_GetSoftwareStartConvStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    491            /* Check the parameters */
    492            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    493            /* Check the status of SWSTART bit */
    494            if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x0240             LSLS     R0,R0,#+9
   \        0x6   0xD501             BPL.N    ??ADC_GetSoftwareStartConvStatus_0
    495            {
    496              /* SWSTART bit is set */
    497              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ADC_GetSoftwareStartConvStatus_1
    498            }
    499            else
    500            {
    501              /* SWSTART bit is reset */
    502              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartConvStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    503            }
    504            /* Return the SWSTART bit status */
    505            return  bitstatus;
   \                     ??ADC_GetSoftwareStartConvStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    506          }
    507          
    508          /**
    509            * @brief  Configures the discontinuous mode for the selected ADC regular
    510            *         group channel.
    511            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    512            * @param  Number: specifies the discontinuous mode regular channel
    513            *         count value. This number must be between 1 and 8.
    514            * @retval None
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    517          {
    518            uint32_t tmpreg1 = 0;
   \                     ADC_DiscModeChannelCountConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    519            uint32_t tmpreg2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    520            /* Check the parameters */
    521            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    522            //assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    523            /* Get the old register value */
    524            tmpreg1 = ADCx->CR1;
   \        0x4   0x6842             LDR      R2,[R0, #+4]
    525            /* Clear the old discontinuous mode channel count */
    526            tmpreg1 &= CR1_DISCNUM_Reset;
   \        0x6   0xF432 0x4260      BICS     R2,R2,#0xE000
    527            /* Set the discontinuous mode channel count */
    528            tmpreg2 = Number - 1;
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x1E49             SUBS     R1,R1,#+1
    529            tmpreg1 |= tmpreg2 << 13;
   \        0xE   0xEA52 0x3241      ORRS     R2,R2,R1, LSL #+13
    530            /* Store the new register value */
    531            ADCx->CR1 = tmpreg1;
   \       0x12   0x6042             STR      R2,[R0, #+4]
    532          }
   \       0x14   0x4770             BX       LR
    533          
    534          /**
    535            * @brief  Enables or disables the discontinuous mode on regular group
    536            *         channel for the specified ADC
    537            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    538            * @param  NewState: new state of the selected ADC discontinuous mode
    539            *         on regular group channel.
    540            *         This parameter can be: ENABLE or DISABLE.
    541            * @retval None
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    544          {
    545            /* Check the parameters */
    546            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    547            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    548            if (NewState != DISABLE)
   \                     ADC_DiscModeCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_DiscModeCmd_0
    549            {
    550              /* Enable the selected ADC regular discontinuous mode */
    551              ADCx->CR1 |= CR1_DISCEN_Set;
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF451 0x6100      ORRS     R1,R1,#0x800
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0xE003             B.N      ??ADC_DiscModeCmd_1
    552            }
    553            else
    554            {
    555              /* Disable the selected ADC regular discontinuous mode */
    556              ADCx->CR1 &= CR1_DISCEN_Reset;
   \                     ??ADC_DiscModeCmd_0: (+1)
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0xF431 0x6100      BICS     R1,R1,#0x800
   \       0x16   0x6041             STR      R1,[R0, #+4]
    557            }
    558          }
   \                     ??ADC_DiscModeCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    559          
    560          /**
    561            * @brief  Configures for the selected ADC regular channel its corresponding
    562            *         rank in the sequencer and its sample time.
    563            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    564            * @param  ADC_Channel: the ADC channel to configure. 
    565            *   This parameter can be one of the following values:
    566            *     @arg ADC_Channel_0: ADC Channel0 selected
    567            *     @arg ADC_Channel_1: ADC Channel1 selected
    568            *     @arg ADC_Channel_2: ADC Channel2 selected
    569            *     @arg ADC_Channel_3: ADC Channel3 selected
    570            *     @arg ADC_Channel_4: ADC Channel4 selected
    571            *     @arg ADC_Channel_5: ADC Channel5 selected
    572            *     @arg ADC_Channel_6: ADC Channel6 selected
    573            *     @arg ADC_Channel_7: ADC Channel7 selected
    574            *     @arg ADC_Channel_8: ADC Channel8 selected
    575            *     @arg ADC_Channel_9: ADC Channel9 selected
    576            *     @arg ADC_Channel_10: ADC Channel10 selected
    577            *     @arg ADC_Channel_11: ADC Channel11 selected
    578            *     @arg ADC_Channel_12: ADC Channel12 selected
    579            *     @arg ADC_Channel_13: ADC Channel13 selected
    580            *     @arg ADC_Channel_14: ADC Channel14 selected
    581            *     @arg ADC_Channel_15: ADC Channel15 selected
    582            *     @arg ADC_Channel_16: ADC Channel16 selected
    583            *     @arg ADC_Channel_17: ADC Channel17 selected
    584            * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
    585            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    586            *   This parameter can be one of the following values:
    587            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    588            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    589            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    590            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    591            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    592            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    593            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    594            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    598          {
   \                     ADC_RegularChannelConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    599            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
    600            /* Check the parameters */
    601            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    602            //assert_param(IS_ADC_CHANNEL(ADC_Channel));
    603            //assert_param(IS_ADC_REGULAR_RANK(Rank));
    604            //assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    605            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    606            if (ADC_Channel > ADC_Channel_9)
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0xB2E4             UXTB     R4,R4
   \        0xA   0x2C0A             CMP      R4,#+10
   \        0xC   0xDB11             BLT.N    ??ADC_RegularChannelConfig_0
    607            {
    608              /* Get the old register value */
    609              tmpreg1 = ADCx->SMPR1;
   \        0xE   0x68C5             LDR      R5,[R0, #+12]
    610              /* Calculate the mask to clear */
    611              tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
   \       0x10   0x2707             MOVS     R7,#+7
   \       0x12   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \       0x16   0x2403             MOVS     R4,#+3
   \       0x18   0x4366             MULS     R6,R4,R6
   \       0x1A   0xFA17 0xF606      LSLS     R6,R7,R6
    612              /* Clear the old channel sample time */
    613              tmpreg1 &= ~tmpreg2;
   \       0x1E   0x43B5             BICS     R5,R5,R6
    614              /* Calculate the mask to set */
    615              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \       0x20   0xB2DB             UXTB     R3,R3
   \       0x22   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \       0x26   0x2403             MOVS     R4,#+3
   \       0x28   0x4366             MULS     R6,R4,R6
   \       0x2A   0x40B3             LSLS     R3,R3,R6
    616              /* Set the new channel sample time */
    617              tmpreg1 |= tmpreg2;
   \       0x2C   0x432B             ORRS     R3,R3,R5
    618              /* Store the new register value */
    619              ADCx->SMPR1 = tmpreg1;
   \       0x2E   0x60C3             STR      R3,[R0, #+12]
   \       0x30   0xE00E             B.N      ??ADC_RegularChannelConfig_1
    620            }
    621            else /* ADC_Channel include in ADC_Channel_[0..9] */
    622            {
    623              /* Get the old register value */
    624              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_RegularChannelConfig_0: (+1)
   \       0x32   0x6904             LDR      R4,[R0, #+16]
    625              /* Calculate the mask to clear */
    626              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   \       0x34   0x2607             MOVS     R6,#+7
   \       0x36   0x2503             MOVS     R5,#+3
   \       0x38   0xFB05 0xF501      MUL      R5,R5,R1
   \       0x3C   0xFA16 0xF505      LSLS     R5,R6,R5
    627              /* Clear the old channel sample time */
    628              tmpreg1 &= ~tmpreg2;
   \       0x40   0x43AC             BICS     R4,R4,R5
    629              /* Calculate the mask to set */
    630              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \       0x42   0xB2DB             UXTB     R3,R3
   \       0x44   0x2503             MOVS     R5,#+3
   \       0x46   0xFB05 0xF501      MUL      R5,R5,R1
   \       0x4A   0x40AB             LSLS     R3,R3,R5
    631              /* Set the new channel sample time */
    632              tmpreg1 |= tmpreg2;
   \       0x4C   0x4323             ORRS     R3,R3,R4
    633              /* Store the new register value */
    634              ADCx->SMPR2 = tmpreg1;
   \       0x4E   0x6103             STR      R3,[R0, #+16]
    635            }
    636            /* For Rank 1 to 6 */
    637            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_1: (+1)
   \       0x50   0x0013             MOVS     R3,R2
   \       0x52   0xB2DB             UXTB     R3,R3
   \       0x54   0x2B07             CMP      R3,#+7
   \       0x56   0xDA0F             BGE.N    ??ADC_RegularChannelConfig_2
    638            {
    639              /* Get the old register value */
    640              tmpreg1 = ADCx->SQR3;
   \       0x58   0x6B44             LDR      R4,[R0, #+52]
    641              /* Calculate the mask to clear */
    642              tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
   \       0x5A   0x261F             MOVS     R6,#+31
   \       0x5C   0x1E55             SUBS     R5,R2,#+1
   \       0x5E   0x2305             MOVS     R3,#+5
   \       0x60   0x435D             MULS     R5,R3,R5
   \       0x62   0xFA16 0xF505      LSLS     R5,R6,R5
    643              /* Clear the old SQx bits for the selected rank */
    644              tmpreg1 &= ~tmpreg2;
   \       0x66   0x43AC             BICS     R4,R4,R5
    645              /* Calculate the mask to set */
    646              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
   \       0x68   0xB2C9             UXTB     R1,R1
   \       0x6A   0x1E53             SUBS     R3,R2,#+1
   \       0x6C   0x2205             MOVS     R2,#+5
   \       0x6E   0x4353             MULS     R3,R2,R3
   \       0x70   0x4099             LSLS     R1,R1,R3
    647              /* Set the SQx bits for the selected rank */
    648              tmpreg1 |= tmpreg2;
   \       0x72   0x4321             ORRS     R1,R1,R4
    649              /* Store the new register value */
    650              ADCx->SQR3 = tmpreg1;
   \       0x74   0x6341             STR      R1,[R0, #+52]
   \       0x76   0xE024             B.N      ??ADC_RegularChannelConfig_3
    651            }
    652            /* For Rank 7 to 12 */
    653            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_2: (+1)
   \       0x78   0x0013             MOVS     R3,R2
   \       0x7A   0xB2DB             UXTB     R3,R3
   \       0x7C   0x2B0D             CMP      R3,#+13
   \       0x7E   0xDA0F             BGE.N    ??ADC_RegularChannelConfig_4
    654            {
    655              /* Get the old register value */
    656              tmpreg1 = ADCx->SQR2;
   \       0x80   0x6B04             LDR      R4,[R0, #+48]
    657              /* Calculate the mask to clear */
    658              tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
   \       0x82   0x261F             MOVS     R6,#+31
   \       0x84   0x1FD5             SUBS     R5,R2,#+7
   \       0x86   0x2305             MOVS     R3,#+5
   \       0x88   0x435D             MULS     R5,R3,R5
   \       0x8A   0xFA16 0xF505      LSLS     R5,R6,R5
    659              /* Clear the old SQx bits for the selected rank */
    660              tmpreg1 &= ~tmpreg2;
   \       0x8E   0x43AC             BICS     R4,R4,R5
    661              /* Calculate the mask to set */
    662              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
   \       0x90   0xB2C9             UXTB     R1,R1
   \       0x92   0x1FD3             SUBS     R3,R2,#+7
   \       0x94   0x2205             MOVS     R2,#+5
   \       0x96   0x4353             MULS     R3,R2,R3
   \       0x98   0x4099             LSLS     R1,R1,R3
    663              /* Set the SQx bits for the selected rank */
    664              tmpreg1 |= tmpreg2;
   \       0x9A   0x4321             ORRS     R1,R1,R4
    665              /* Store the new register value */
    666              ADCx->SQR2 = tmpreg1;
   \       0x9C   0x6301             STR      R1,[R0, #+48]
   \       0x9E   0xE010             B.N      ??ADC_RegularChannelConfig_3
    667            }
    668            /* For Rank 13 to 16 */
    669            else
    670            {
    671              /* Get the old register value */
    672              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_4: (+1)
   \       0xA0   0x6AC4             LDR      R4,[R0, #+44]
    673              /* Calculate the mask to clear */
    674              tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
   \       0xA2   0x261F             MOVS     R6,#+31
   \       0xA4   0xF1B2 0x050D      SUBS     R5,R2,#+13
   \       0xA8   0x2305             MOVS     R3,#+5
   \       0xAA   0x435D             MULS     R5,R3,R5
   \       0xAC   0xFA16 0xF505      LSLS     R5,R6,R5
    675              /* Clear the old SQx bits for the selected rank */
    676              tmpreg1 &= ~tmpreg2;
   \       0xB0   0x43AC             BICS     R4,R4,R5
    677              /* Calculate the mask to set */
    678              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
   \       0xB2   0xB2C9             UXTB     R1,R1
   \       0xB4   0xF1B2 0x030D      SUBS     R3,R2,#+13
   \       0xB8   0x2205             MOVS     R2,#+5
   \       0xBA   0x4353             MULS     R3,R2,R3
   \       0xBC   0x4099             LSLS     R1,R1,R3
    679              /* Set the SQx bits for the selected rank */
    680              tmpreg1 |= tmpreg2;
   \       0xBE   0x4321             ORRS     R1,R1,R4
    681              /* Store the new register value */
    682              ADCx->SQR1 = tmpreg1;
   \       0xC0   0x62C1             STR      R1,[R0, #+44]
    683            }
    684          }
   \                     ??ADC_RegularChannelConfig_3: (+1)
   \       0xC2   0xBCF0             POP      {R4-R7}
   \       0xC4   0x4770             BX       LR
    685          
    686          /**
    687            * @brief  Enables or disables the ADCx conversion through external trigger.
    688            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    689            * @param  NewState: new state of the selected ADC external trigger start of conversion.
    690            *   This parameter can be: ENABLE or DISABLE.
    691            * @retval None
    692            */

   \                                 In section .text, align 2, keep-with-next
    693          void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    694          {
    695            /* Check the parameters */
    696            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    697            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    698            if (NewState != DISABLE)
   \                     ADC_ExternalTrigConvCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_ExternalTrigConvCmd_0
    699            {
    700              /* Enable the selected ADC conversion on external event */
    701              ADCx->CR2 |= CR2_EXTTRIG_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_ExternalTrigConvCmd_1
    702            }
    703            else
    704            {
    705              /* Disable the selected ADC conversion on external event */
    706              ADCx->CR2 &= CR2_EXTTRIG_Reset;
   \                     ??ADC_ExternalTrigConvCmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0xF431 0x1180      BICS     R1,R1,#0x100000
   \       0x16   0x6081             STR      R1,[R0, #+8]
    707            }
    708          }
   \                     ??ADC_ExternalTrigConvCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    709          
    710          /**
    711            * @brief  Returns the last ADCx conversion result data for regular channel.
    712            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    713            * @retval The Data conversion value.
    714            */

   \                                 In section .text, align 2, keep-with-next
    715          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    716          {
    717            /* Check the parameters */
    718            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    719            /* Return the selected ADC conversion value */
    720            return (uint16_t) ADCx->DR;
   \                     ADC_GetConversionValue: (+1)
   \        0x0   0x6CC0             LDR      R0,[R0, #+76]
   \        0x2   0xB280             UXTH     R0,R0
   \        0x4   0x4770             BX       LR
    721          }
    722          
    723          /**
    724            * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
    725            * @retval The Data conversion value.
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          uint32_t ADC_GetDualModeConversionValue(void)
    728          {
    729            /* Return the dual mode conversion value */
    730            return (*(__IO uint32_t *) DR_ADDRESS);
   \                     ADC_GetDualModeConversionValue: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable4_5
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    731          }
    732          
    733          /**
    734            * @brief  Enables or disables the selected ADC automatic injected group
    735            *         conversion after regular one.
    736            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    737            * @param  NewState: new state of the selected ADC auto injected conversion
    738            *   This parameter can be: ENABLE or DISABLE.
    739            * @retval None
    740            */

   \                                 In section .text, align 2, keep-with-next
    741          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    742          {
    743            /* Check the parameters */
    744            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    745            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    746            if (NewState != DISABLE)
   \                     ADC_AutoInjectedConvCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_0
    747            {
    748              /* Enable the selected ADC automatic injected group conversion */
    749              ADCx->CR1 |= CR1_JAUTO_Set;
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0xE003             B.N      ??ADC_AutoInjectedConvCmd_1
    750            }
    751            else
    752            {
    753              /* Disable the selected ADC automatic injected group conversion */
    754              ADCx->CR1 &= CR1_JAUTO_Reset;
   \                     ??ADC_AutoInjectedConvCmd_0: (+1)
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0xF431 0x6180      BICS     R1,R1,#0x400
   \       0x16   0x6041             STR      R1,[R0, #+4]
    755            }
    756          }
   \                     ??ADC_AutoInjectedConvCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    757          
    758          /**
    759            * @brief  Enables or disables the discontinuous mode for injected group
    760            *         channel for the specified ADC
    761            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    762            * @param  NewState: new state of the selected ADC discontinuous mode
    763            *         on injected group channel.
    764            *   This parameter can be: ENABLE or DISABLE.
    765            * @retval None
    766            */

   \                                 In section .text, align 2, keep-with-next
    767          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    768          {
    769            /* Check the parameters */
    770            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    771            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    772            if (NewState != DISABLE)
   \                     ADC_InjectedDiscModeCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_0
    773            {
    774              /* Enable the selected ADC injected discontinuous mode */
    775              ADCx->CR1 |= CR1_JDISCEN_Set;
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0xE003             B.N      ??ADC_InjectedDiscModeCmd_1
    776            }
    777            else
    778            {
    779              /* Disable the selected ADC injected discontinuous mode */
    780              ADCx->CR1 &= CR1_JDISCEN_Reset;
   \                     ??ADC_InjectedDiscModeCmd_0: (+1)
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0xF431 0x5180      BICS     R1,R1,#0x1000
   \       0x16   0x6041             STR      R1,[R0, #+4]
    781            }
    782          }
   \                     ??ADC_InjectedDiscModeCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    783          
    784          /**
    785            * @brief  Configures the ADCx external trigger for injected channels conversion.
    786            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    787            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
    788            *   This parameter can be one of the following values:
    789            *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
    790            *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
    791            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
    792            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
    793            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
    794            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
    795            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
    796            *                                                       capture compare4 event selected (for ADC1 and ADC2)                       
    797            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
    798            *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)                         
    799            *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
    800            *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)                         
    801            *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)                        
    802            *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
    803            *                                          by external trigger (for ADC1, ADC2 and ADC3)
    804            * @retval None
    805            */

   \                                 In section .text, align 2, keep-with-next
    806          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
    807          {
    808            uint32_t tmpreg = 0;
   \                     ADC_ExternalTrigInjectedConvConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    809            /* Check the parameters */
    810            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    811            //assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
    812            /* Get the old register value */
    813            tmpreg = ADCx->CR2;
   \        0x2   0x6882             LDR      R2,[R0, #+8]
    814            /* Clear the old external event selection for injected group */
    815            tmpreg &= CR2_JEXTSEL_Reset;
   \        0x4   0xF432 0x42E0      BICS     R2,R2,#0x7000
    816            /* Set the external event selection for injected group */
    817            tmpreg |= ADC_ExternalTrigInjecConv;
   \        0x8   0x4311             ORRS     R1,R1,R2
    818            /* Store the new register value */
    819            ADCx->CR2 = tmpreg;
   \        0xA   0x6081             STR      R1,[R0, #+8]
    820          }
   \        0xC   0x4770             BX       LR
    821          
    822          /**
    823            * @brief  Enables or disables the ADCx injected channels conversion through
    824            *         external trigger
    825            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    826            * @param  NewState: new state of the selected ADC external trigger start of
    827            *         injected conversion.
    828            *   This parameter can be: ENABLE or DISABLE.
    829            * @retval None
    830            */

   \                                 In section .text, align 2, keep-with-next
    831          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    832          {
    833            /* Check the parameters */
    834            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    835            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    836            if (NewState != DISABLE)
   \                     ADC_ExternalTrigInjectedConvCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_ExternalTrigInjectedConvCmd_0
    837            {
    838              /* Enable the selected ADC external event selection for injected group */
    839              ADCx->CR2 |= CR2_JEXTTRIG_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_ExternalTrigInjectedConvCmd_1
    840            }
    841            else
    842            {
    843              /* Disable the selected ADC external event selection for injected group */
    844              ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   \                     ??ADC_ExternalTrigInjectedConvCmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x16   0x6081             STR      R1,[R0, #+8]
    845            }
    846          }
   \                     ??ADC_ExternalTrigInjectedConvCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    847          
    848          /**
    849            * @brief  Enables or disables the selected ADC start of the injected 
    850            *         channels conversion.
    851            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    852            * @param  NewState: new state of the selected ADC software start injected conversion.
    853            *   This parameter can be: ENABLE or DISABLE.
    854            * @retval None
    855            */

   \                                 In section .text, align 2, keep-with-next
    856          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    857          {
    858            /* Check the parameters */
    859            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    860            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    861            if (NewState != DISABLE)
   \                     ADC_SoftwareStartInjectedConvCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??ADC_SoftwareStartInjectedConvCmd_0
    862            {
    863              /* Enable the selected ADC conversion for injected group on external event and start the selected
    864                 ADC injected conversion */
    865              ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0xF451 0x1102      ORRS     R1,R1,#0x208000
   \        0xC   0x6081             STR      R1,[R0, #+8]
   \        0xE   0xE003             B.N      ??ADC_SoftwareStartInjectedConvCmd_1
    866            }
    867            else
    868            {
    869              /* Disable the selected ADC conversion on external event for injected group and stop the selected
    870                 ADC injected conversion */
    871              ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   \                     ??ADC_SoftwareStartInjectedConvCmd_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0xF431 0x1102      BICS     R1,R1,#0x208000
   \       0x16   0x6081             STR      R1,[R0, #+8]
    872            }
    873          }
   \                     ??ADC_SoftwareStartInjectedConvCmd_1: (+1)
   \       0x18   0x4770             BX       LR
    874          
    875          /**
    876            * @brief  Gets the selected ADC Software start injected conversion Status.
    877            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    878            * @retval The new state of ADC software start injected conversion (SET or RESET).
    879            */

   \                                 In section .text, align 2, keep-with-next
    880          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
    881          {
    882            FlagStatus bitstatus = RESET;
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    883            /* Check the parameters */
    884            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    885            /* Check the status of JSWSTART bit */
    886            if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x0280             LSLS     R0,R0,#+10
   \        0x6   0xD501             BPL.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
    887            {
    888              /* JSWSTART bit is set */
    889              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ADC_GetSoftwareStartInjectedConvCmdStatus_1
    890            }
    891            else
    892            {
    893              /* JSWSTART bit is reset */
    894              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    895            }
    896            /* Return the JSWSTART bit status */
    897            return  bitstatus;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    898          }
    899          
    900          /**
    901            * @brief  Configures for the selected ADC injected channel its corresponding
    902            *         rank in the sequencer and its sample time.
    903            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    904            * @param  ADC_Channel: the ADC channel to configure. 
    905            *   This parameter can be one of the following values:
    906            *     @arg ADC_Channel_0: ADC Channel0 selected
    907            *     @arg ADC_Channel_1: ADC Channel1 selected
    908            *     @arg ADC_Channel_2: ADC Channel2 selected
    909            *     @arg ADC_Channel_3: ADC Channel3 selected
    910            *     @arg ADC_Channel_4: ADC Channel4 selected
    911            *     @arg ADC_Channel_5: ADC Channel5 selected
    912            *     @arg ADC_Channel_6: ADC Channel6 selected
    913            *     @arg ADC_Channel_7: ADC Channel7 selected
    914            *     @arg ADC_Channel_8: ADC Channel8 selected
    915            *     @arg ADC_Channel_9: ADC Channel9 selected
    916            *     @arg ADC_Channel_10: ADC Channel10 selected
    917            *     @arg ADC_Channel_11: ADC Channel11 selected
    918            *     @arg ADC_Channel_12: ADC Channel12 selected
    919            *     @arg ADC_Channel_13: ADC Channel13 selected
    920            *     @arg ADC_Channel_14: ADC Channel14 selected
    921            *     @arg ADC_Channel_15: ADC Channel15 selected
    922            *     @arg ADC_Channel_16: ADC Channel16 selected
    923            *     @arg ADC_Channel_17: ADC Channel17 selected
    924            * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
    925            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    926            *   This parameter can be one of the following values:
    927            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    928            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    929            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    930            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    931            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    932            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    933            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    934            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    935            * @retval None
    936            */

   \                                 In section .text, align 2, keep-with-next
    937          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    938          {
   \                     ADC_InjectedChannelConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    939            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2400             MOVS     R4,#+0
    940            /* Check the parameters */
    941            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
    942            //assert_param(IS_ADC_CHANNEL(ADC_Channel));
    943            //assert_param(IS_ADC_INJECTED_RANK(Rank));
    944            //assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    945            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    946            if (ADC_Channel > ADC_Channel_9)
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0xB2E4             UXTB     R4,R4
   \        0xC   0x2C0A             CMP      R4,#+10
   \        0xE   0xDB11             BLT.N    ??ADC_InjectedChannelConfig_0
    947            {
    948              /* Get the old register value */
    949              tmpreg1 = ADCx->SMPR1;
   \       0x10   0x68C5             LDR      R5,[R0, #+12]
    950              /* Calculate the mask to clear */
    951              tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   \       0x12   0x2707             MOVS     R7,#+7
   \       0x14   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \       0x18   0x2403             MOVS     R4,#+3
   \       0x1A   0x4366             MULS     R6,R4,R6
   \       0x1C   0xFA17 0xF606      LSLS     R6,R7,R6
    952              /* Clear the old channel sample time */
    953              tmpreg1 &= ~tmpreg2;
   \       0x20   0x43B5             BICS     R5,R5,R6
    954              /* Calculate the mask to set */
    955              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   \       0x22   0xB2DB             UXTB     R3,R3
   \       0x24   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \       0x28   0x2403             MOVS     R4,#+3
   \       0x2A   0x4366             MULS     R6,R4,R6
   \       0x2C   0x40B3             LSLS     R3,R3,R6
    956              /* Set the new channel sample time */
    957              tmpreg1 |= tmpreg2;
   \       0x2E   0x432B             ORRS     R3,R3,R5
    958              /* Store the new register value */
    959              ADCx->SMPR1 = tmpreg1;
   \       0x30   0x60C3             STR      R3,[R0, #+12]
   \       0x32   0xE00E             B.N      ??ADC_InjectedChannelConfig_1
    960            }
    961            else /* ADC_Channel include in ADC_Channel_[0..9] */
    962            {
    963              /* Get the old register value */
    964              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_InjectedChannelConfig_0: (+1)
   \       0x34   0x6904             LDR      R4,[R0, #+16]
    965              /* Calculate the mask to clear */
    966              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   \       0x36   0x2607             MOVS     R6,#+7
   \       0x38   0x2503             MOVS     R5,#+3
   \       0x3A   0xFB05 0xF501      MUL      R5,R5,R1
   \       0x3E   0xFA16 0xF505      LSLS     R5,R6,R5
    967              /* Clear the old channel sample time */
    968              tmpreg1 &= ~tmpreg2;
   \       0x42   0x43AC             BICS     R4,R4,R5
    969              /* Calculate the mask to set */
    970              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \       0x44   0xB2DB             UXTB     R3,R3
   \       0x46   0x2503             MOVS     R5,#+3
   \       0x48   0xFB05 0xF501      MUL      R5,R5,R1
   \       0x4C   0x40AB             LSLS     R3,R3,R5
    971              /* Set the new channel sample time */
    972              tmpreg1 |= tmpreg2;
   \       0x4E   0x4323             ORRS     R3,R3,R4
    973              /* Store the new register value */
    974              ADCx->SMPR2 = tmpreg1;
   \       0x50   0x6103             STR      R3,[R0, #+16]
    975            }
    976            /* Rank configuration */
    977            /* Get the old register value */
    978            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_1: (+1)
   \       0x52   0x6B84             LDR      R4,[R0, #+56]
    979            /* Get JL value: Number = JL+1 */
    980            tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
   \       0x54   0xF3C4 0x5601      UBFX     R6,R4,#+20,#+2
    981            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
    982            tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \       0x58   0x271F             MOVS     R7,#+31
   \       0x5A   0x1CD3             ADDS     R3,R2,#+3
   \       0x5C   0x1B9B             SUBS     R3,R3,R6
   \       0x5E   0x1E5D             SUBS     R5,R3,#+1
   \       0x60   0x2305             MOVS     R3,#+5
   \       0x62   0x435D             MULS     R5,R3,R5
   \       0x64   0xFA17 0xF505      LSLS     R5,R7,R5
    983            /* Clear the old JSQx bits for the selected rank */
    984            tmpreg1 &= ~tmpreg2;
   \       0x68   0x43AC             BICS     R4,R4,R5
    985            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
    986            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \       0x6A   0xB2C9             UXTB     R1,R1
   \       0x6C   0x1CD2             ADDS     R2,R2,#+3
   \       0x6E   0x1B92             SUBS     R2,R2,R6
   \       0x70   0x1E53             SUBS     R3,R2,#+1
   \       0x72   0x2205             MOVS     R2,#+5
   \       0x74   0x4353             MULS     R3,R2,R3
   \       0x76   0x4099             LSLS     R1,R1,R3
    987            /* Set the JSQx bits for the selected rank */
    988            tmpreg1 |= tmpreg2;
   \       0x78   0x4321             ORRS     R1,R1,R4
    989            /* Store the new register value */
    990            ADCx->JSQR = tmpreg1;
   \       0x7A   0x6381             STR      R1,[R0, #+56]
    991          }
   \       0x7C   0xBCF0             POP      {R4-R7}
   \       0x7E   0x4770             BX       LR
    992          
    993          /**
    994            * @brief  Configures the sequencer length for injected channels
    995            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    996            * @param  Length: The sequencer length. 
    997            *   This parameter must be a number between 1 to 4.
    998            * @retval None
    999            */

   \                                 In section .text, align 2, keep-with-next
   1000          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1001          {
   1002            uint32_t tmpreg1 = 0;
   \                     ADC_InjectedSequencerLengthConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1003            uint32_t tmpreg2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   1004            /* Check the parameters */
   1005            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1006            //assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1007            
   1008            /* Get the old register value */
   1009            tmpreg1 = ADCx->JSQR;
   \        0x4   0x6B82             LDR      R2,[R0, #+56]
   1010            /* Clear the old injected sequnence lenght JL bits */
   1011            tmpreg1 &= JSQR_JL_Reset;
   \        0x6   0xF432 0x1240      BICS     R2,R2,#0x300000
   1012            /* Set the injected sequnence lenght JL bits */
   1013            tmpreg2 = Length - 1; 
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x1E49             SUBS     R1,R1,#+1
   1014            tmpreg1 |= tmpreg2 << 20;
   \        0xE   0xEA52 0x5201      ORRS     R2,R2,R1, LSL #+20
   1015            /* Store the new register value */
   1016            ADCx->JSQR = tmpreg1;
   \       0x12   0x6382             STR      R2,[R0, #+56]
   1017          }
   \       0x14   0x4770             BX       LR
   1018          
   1019          /**
   1020            * @brief  Set the injected channels conversion value offset
   1021            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1022            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1023            *   This parameter can be one of the following values:
   1024            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1025            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1026            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1027            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1028            * @param  Offset: the offset value for the selected ADC injected channel
   1029            *   This parameter must be a 12bit value.
   1030            * @retval None
   1031            */

   \                                 In section .text, align 2, keep-with-next
   1032          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1033          {
   \                     ADC_SetInjectedOffset: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   1034            __IO uint32_t tmp = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x9300             STR      R3,[SP, #+0]
   1035            
   1036            /* Check the parameters */
   1037            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1038            //assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1039            //assert_param(IS_ADC_OFFSET(Offset));
   1040            
   1041            tmp = (uint32_t)ADCx;
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1042            tmp += ADC_InjectedChannel;
   \        0x8   0x9800             LDR      R0,[SP, #+0]
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x1809             ADDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   1043            
   1044            /* Set the selected injected channel data offset */
   1045            *(__IO uint32_t *) tmp = (uint32_t)Offset;
   \       0x10   0xB292             UXTH     R2,R2
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x6002             STR      R2,[R0, #+0]
   1046          }
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR
   1047          
   1048          /**
   1049            * @brief  Returns the ADC injected channel conversion result
   1050            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1051            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1052            *   This parameter can be one of the following values:
   1053            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1054            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1055            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1056            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1057            * @retval The Data conversion value.
   1058            */

   \                                 In section .text, align 2, keep-with-next
   1059          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1060          {
   \                     ADC_GetInjectedConversionValue: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   1061            __IO uint32_t tmp = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x9200             STR      R2,[SP, #+0]
   1062            
   1063            /* Check the parameters */
   1064            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1065            //assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1066          
   1067            tmp = (uint32_t)ADCx;
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1068            tmp += ADC_InjectedChannel + JDR_Offset;
   \        0x8   0x9800             LDR      R0,[SP, #+0]
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x3128             ADDS     R1,R1,#+40
   \        0xE   0x1809             ADDS     R1,R1,R0
   \       0x10   0x9100             STR      R1,[SP, #+0]
   1069            
   1070            /* Returns the selected injected channel conversion data value */
   1071            return (uint16_t) (*(__IO uint32_t*)  tmp);   
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR
   1072          }
   1073          
   1074          /**
   1075            * @brief  Enables or disables the analog watchdog on single/all regular
   1076            *         or injected channels
   1077            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1078            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1079            *   This parameter can be one of the following values:
   1080            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
   1081            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
   1082            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
   1083            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
   1084            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
   1085            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
   1086            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
   1087            * @retval None	  
   1088            */

   \                                 In section .text, align 2, keep-with-next
   1089          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
   1090          {
   1091            uint32_t tmpreg = 0;
   \                     ADC_AnalogWatchdogCmd: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1092            /* Check the parameters */
   1093            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1094            //assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1095            /* Get the old register value */
   1096            tmpreg = ADCx->CR1;
   \        0x2   0x6843             LDR      R3,[R0, #+4]
   1097            /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1098            tmpreg &= CR1_AWDMode_Reset;
   \        0x4   0x....             LDR.N    R2,??DataTable4_6
   \        0x6   0x4013             ANDS     R3,R2,R3
   1099            /* Set the analog watchdog enable mode */
   1100            tmpreg |= ADC_AnalogWatchdog;
   \        0x8   0x4319             ORRS     R1,R1,R3
   1101            /* Store the new register value */
   1102            ADCx->CR1 = tmpreg;
   \        0xA   0x6041             STR      R1,[R0, #+4]
   1103          }
   \        0xC   0x4770             BX       LR
   1104          
   1105          /**
   1106            * @brief  Configures the high and low thresholds of the analog watchdog.
   1107            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1108            * @param  HighThreshold: the ADC analog watchdog High threshold value.
   1109            *   This parameter must be a 12bit value.
   1110            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
   1111            *   This parameter must be a 12bit value.
   1112            * @retval None
   1113            */

   \                                 In section .text, align 2, keep-with-next
   1114          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
   1115                                                  uint16_t LowThreshold)
   1116          {
   1117            /* Check the parameters */
   1118            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1119            //assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1120            //assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1121            /* Set the ADCx high threshold */
   1122            ADCx->HTR = HighThreshold;
   \                     ADC_AnalogWatchdogThresholdsConfig: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2   0x6241             STR      R1,[R0, #+36]
   1123            /* Set the ADCx low threshold */
   1124            ADCx->LTR = LowThreshold;
   \        0x4   0xB292             UXTH     R2,R2
   \        0x6   0x6282             STR      R2,[R0, #+40]
   1125          }
   \        0x8   0x4770             BX       LR
   1126          
   1127          /**
   1128            * @brief  Configures the analog watchdog guarded single channel
   1129            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1130            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
   1131            *   This parameter can be one of the following values:
   1132            *     @arg ADC_Channel_0: ADC Channel0 selected
   1133            *     @arg ADC_Channel_1: ADC Channel1 selected
   1134            *     @arg ADC_Channel_2: ADC Channel2 selected
   1135            *     @arg ADC_Channel_3: ADC Channel3 selected
   1136            *     @arg ADC_Channel_4: ADC Channel4 selected
   1137            *     @arg ADC_Channel_5: ADC Channel5 selected
   1138            *     @arg ADC_Channel_6: ADC Channel6 selected
   1139            *     @arg ADC_Channel_7: ADC Channel7 selected
   1140            *     @arg ADC_Channel_8: ADC Channel8 selected
   1141            *     @arg ADC_Channel_9: ADC Channel9 selected
   1142            *     @arg ADC_Channel_10: ADC Channel10 selected
   1143            *     @arg ADC_Channel_11: ADC Channel11 selected
   1144            *     @arg ADC_Channel_12: ADC Channel12 selected
   1145            *     @arg ADC_Channel_13: ADC Channel13 selected
   1146            *     @arg ADC_Channel_14: ADC Channel14 selected
   1147            *     @arg ADC_Channel_15: ADC Channel15 selected
   1148            *     @arg ADC_Channel_16: ADC Channel16 selected
   1149            *     @arg ADC_Channel_17: ADC Channel17 selected
   1150            * @retval None
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
   1153          {
   1154            uint32_t tmpreg = 0;
   \                     ADC_AnalogWatchdogSingleChannelConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1155            /* Check the parameters */
   1156            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1157            //assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1158            /* Get the old register value */
   1159            tmpreg = ADCx->CR1;
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   1160            /* Clear the Analog watchdog channel select bits */
   1161            tmpreg &= CR1_AWDCH_Reset;
   \        0x4   0x0952             LSRS     R2,R2,#+5
   \        0x6   0x0152             LSLS     R2,R2,#+5
   1162            /* Set the Analog watchdog channel */
   1163            tmpreg |= ADC_Channel;
   \        0x8   0xB2C9             UXTB     R1,R1
   \        0xA   0x4311             ORRS     R1,R1,R2
   1164            /* Store the new register value */
   1165            ADCx->CR1 = tmpreg;
   \        0xC   0x6041             STR      R1,[R0, #+4]
   1166          }
   \        0xE   0x4770             BX       LR
   1167          
   1168          /**
   1169            * @brief  Enables or disables the temperature sensor and Vrefint channel.
   1170            * @param  NewState: new state of the temperature sensor.
   1171            *   This parameter can be: ENABLE or DISABLE.
   1172            * @retval None
   1173            */

   \                                 In section .text, align 2, keep-with-next
   1174          void ADC_TempSensorVrefintCmd(FunctionalState NewState)
   1175          {
   1176            /* Check the parameters */
   1177            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1178            if (NewState != DISABLE)
   \                     ADC_TempSensorVrefintCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   1179            {
   1180              /* Enable the temperature sensor and Vrefint channel*/
   1181              ADC1->CR2 |= CR2_TSVREFE_Set;
   \        0x6   0x....             LDR.N    R0,??DataTable4_7
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \        0xE   0x....             LDR.N    R1,??DataTable4_7
   \       0x10   0x6008             STR      R0,[R1, #+0]
   \       0x12   0xE005             B.N      ??ADC_TempSensorVrefintCmd_1
   1182            }
   1183            else
   1184            {
   1185              /* Disable the temperature sensor and Vrefint channel*/
   1186              ADC1->CR2 &= CR2_TSVREFE_Reset;
   \                     ??ADC_TempSensorVrefintCmd_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable4_7
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF430 0x0000      BICS     R0,R0,#0x800000
   \       0x1C   0x....             LDR.N    R1,??DataTable4_7
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   1187            }
   1188          }
   \                     ??ADC_TempSensorVrefintCmd_1: (+1)
   \       0x20   0x4770             BX       LR
   1189          
   1190          /**
   1191            * @brief  Checks whether the specified ADC flag is set or not.
   1192            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1193            * @param  ADC_FLAG: specifies the flag to check. 
   1194            *   This parameter can be one of the following values:
   1195            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1196            *     @arg ADC_FLAG_EOC: End of conversion flag
   1197            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1198            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1199            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1200            * @retval The new state of ADC_FLAG (SET or RESET).
   1201            */

   \                                 In section .text, align 2, keep-with-next
   1202          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1203          {
   1204            FlagStatus bitstatus = RESET;
   \                     ADC_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1205            /* Check the parameters */
   1206            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1207            //assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1208            /* Check the status of the specified ADC flag */
   1209            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xB2C9             UXTB     R1,R1
   \        0x6   0x4208             TST      R0,R1
   \        0x8   0xD001             BEQ.N    ??ADC_GetFlagStatus_0
   1210            {
   1211              /* ADC_FLAG is set */
   1212              bitstatus = SET;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??ADC_GetFlagStatus_1
   1213            }
   1214            else
   1215            {
   1216              /* ADC_FLAG is reset */
   1217              bitstatus = RESET;
   \                     ??ADC_GetFlagStatus_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   1218            }
   1219            /* Return the ADC_FLAG status */
   1220            return  bitstatus;
   \                     ??ADC_GetFlagStatus_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR
   1221          }
   1222          
   1223          /**
   1224            * @brief  Clears the ADCx's pending flags.
   1225            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1226            * @param  ADC_FLAG: specifies the flag to clear. 
   1227            *   This parameter can be any combination of the following values:
   1228            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1229            *     @arg ADC_FLAG_EOC: End of conversion flag
   1230            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1231            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1232            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1233            * @retval None
   1234            */

   \                                 In section .text, align 2, keep-with-next
   1235          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1236          {
   1237            /* Check the parameters */
   1238            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1239            //assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1240            /* Clear the selected ADC flags */
   1241            ADCx->SR = ~(uint32_t)ADC_FLAG;
   \                     ADC_ClearFlag: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x43C9             MVNS     R1,R1
   \        0x4   0x6001             STR      R1,[R0, #+0]
   1242          }
   \        0x6   0x4770             BX       LR
   1243          
   1244          /**
   1245            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1246            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1247            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1248            *   This parameter can be one of the following values:
   1249            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1250            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1251            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1252            * @retval The new state of ADC_IT (SET or RESET).
   1253            */

   \                                 In section .text, align 2, keep-with-next
   1254          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1255          {
   1256            ITStatus bitstatus = RESET;
   \                     ADC_GetITStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1257            uint32_t itmask = 0, enablestatus = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   1258            /* Check the parameters */
   1259            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1260            //assert_param(IS_ADC_GET_IT(ADC_IT));
   1261            /* Get the ADC IT index */
   1262            itmask = ADC_IT >> 8;
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0xB292             UXTH     R2,R2
   \        0xA   0x0A12             LSRS     R2,R2,#+8
   \        0xC   0xB292             UXTH     R2,R2
   1263            /* Get the ADC_IT enable bit status */
   1264            enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
   \        0xE   0x6843             LDR      R3,[R0, #+4]
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x4019             ANDS     R1,R1,R3
   1265            /* Check the status of the specified ADC interrupt */
   1266            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4210             TST      R0,R2
   \       0x18   0xD003             BEQ.N    ??ADC_GetITStatus_0
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD001             BEQ.N    ??ADC_GetITStatus_0
   1267            {
   1268              /* ADC_IT is set */
   1269              bitstatus = SET;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??ADC_GetITStatus_1
   1270            }
   1271            else
   1272            {
   1273              /* ADC_IT is reset */
   1274              bitstatus = RESET;
   \                     ??ADC_GetITStatus_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   1275            }
   1276            /* Return the ADC_IT status */
   1277            return  bitstatus;
   \                     ??ADC_GetITStatus_1: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x4770             BX       LR
   1278          }
   1279          
   1280          /**
   1281            * @brief  Clears the ADCx's interrupt pending bits.
   1282            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1283            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1284            *   This parameter can be any combination of the following values:
   1285            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1286            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1287            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1288            * @retval None
   1289            */

   \                                 In section .text, align 2, keep-with-next
   1290          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1291          {
   1292            uint8_t itmask = 0;
   \                     ADC_ClearITPendingBit: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1293            /* Check the parameters */
   1294            //assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1295            //assert_param(IS_ADC_IT(ADC_IT));
   1296            /* Get the ADC IT index */
   1297            itmask = (uint8_t)(ADC_IT >> 8);
   \        0x2   0xB289             UXTH     R1,R1
   \        0x4   0x0A09             LSRS     R1,R1,#+8
   1298            /* Clear the selected ADC interrupt pending bits */
   1299            ADCx->SR = ~(uint32_t)itmask;
   \        0x6   0xB2C9             UXTB     R1,R1
   \        0x8   0x43C9             MVNS     R1,R1
   \        0xA   0x6001             STR      R1,[R0, #+0]
   1300          }
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x4001'2800        DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x4001'3C00        DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0xFFF0'FEFF        DC32     0xfff0feff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0xFFF1'F7FD        DC32     0xfff1f7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x4001'244C        DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0xFF3F'FDFF        DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x4001'2408        DC32     0x40012408
   1301          
   1302          /**
   1303            * @}
   1304            */
   1305          
   1306          /**
   1307            * @}
   1308            */
   1309          
   1310          /**
   1311            * @}
   1312            */
   1313          
   1314          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_DMACmd
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_ExternalTrigConvCmd
       0   ADC_ExternalTrigInjectedConvCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_GetCalibrationStatus
       0   ADC_GetConversionValue
       0   ADC_GetDualModeConversionValue
       0   ADC_GetFlagStatus
       0   ADC_GetITStatus
       4   ADC_GetInjectedConversionValue
       0   ADC_GetResetCalibrationStatus
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       0   ADC_ITConfig
       4   ADC_Init
      16   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       0   ADC_InjectedSequencerLengthConfig
      16   ADC_RegularChannelConfig
       0   ADC_ResetCalibration
       4   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConvCmd
       0   ADC_SoftwareStartInjectedConvCmd
       0   ADC_StartCalibration
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      14  ADC_AnalogWatchdogCmd
      16  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      14  ADC_ClearITPendingBit
      26  ADC_Cmd
      26  ADC_DMACmd
      92  ADC_DeInit
      22  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_ExternalTrigConvCmd
      26  ADC_ExternalTrigInjectedConvCmd
      14  ADC_ExternalTrigInjectedConvConfig
      18  ADC_GetCalibrationStatus
       6  ADC_GetConversionValue
       6  ADC_GetDualModeConversionValue
      20  ADC_GetFlagStatus
      40  ADC_GetITStatus
      28  ADC_GetInjectedConversionValue
      18  ADC_GetResetCalibrationStatus
      18  ADC_GetSoftwareStartConvStatus
      18  ADC_GetSoftwareStartInjectedConvCmdStatus
      30  ADC_ITConfig
      74  ADC_Init
     128  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      22  ADC_InjectedSequencerLengthConfig
     198  ADC_RegularChannelConfig
      10  ADC_ResetCalibration
      26  ADC_SetInjectedOffset
      26  ADC_SoftwareStartConvCmd
      26  ADC_SoftwareStartInjectedConvCmd
      10  ADC_StartCalibration
      26  ADC_StructInit
      34  ADC_TempSensorVrefintCmd

 
 1'186 bytes in section .text
 
 1'186 bytes of CODE memory

Errors: none
Warnings: none
