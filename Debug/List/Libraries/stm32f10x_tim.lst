###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         03/Nov/2021  18:48:27
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_tim.c
#    Command line      =
#        -f
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_tim.o.rsp
#        (C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_tim.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries -o
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\inc\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\LCD\ -Ol -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_tim.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries\stm32f10x_tim.lst
#    Object file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_tim.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the TIM firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_tim.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup TIM 
     31            * @brief TIM driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup TIM_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup TIM_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ---------------------- TIM registers bit mask ------------------------ */
     48          #define SMCR_ETR_Mask               ((uint16_t)0x00FF) 
     49          #define CCMR_Offset                 ((uint16_t)0x0018)
     50          #define CCER_CCE_Set                ((uint16_t)0x0001)  
     51          #define	CCER_CCNE_Set               ((uint16_t)0x0004) 
     52          
     53          /**
     54            * @}
     55            */
     56          
     57          /** @defgroup TIM_Private_Macros
     58            * @{
     59            */
     60          
     61          /**
     62            * @}
     63            */
     64          
     65          /** @defgroup TIM_Private_Variables
     66            * @{
     67            */
     68          
     69          /**
     70            * @}
     71            */
     72          
     73          /** @defgroup TIM_Private_FunctionPrototypes
     74            * @{
     75            */
     76          
     77          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     78                                 uint16_t TIM_ICFilter);
     79          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     80                                 uint16_t TIM_ICFilter);
     81          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     82                                 uint16_t TIM_ICFilter);
     83          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     84                                 uint16_t TIM_ICFilter);
     85          /**
     86            * @}
     87            */
     88          
     89          /** @defgroup TIM_Private_Macros
     90            * @{
     91            */
     92          
     93          /**
     94            * @}
     95            */
     96          
     97          /** @defgroup TIM_Private_Variables
     98            * @{
     99            */
    100          
    101          /**
    102            * @}
    103            */
    104          
    105          /** @defgroup TIM_Private_FunctionPrototypes
    106            * @{
    107            */
    108          
    109          /**
    110            * @}
    111            */
    112          
    113          /** @defgroup TIM_Private_Functions
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    119            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    120            * @retval None
    121            */

   \                                 In section .text, align 2, keep-with-next
    122          void TIM_DeInit(TIM_TypeDef* TIMx)
    123          {
   \                     TIM_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    124            /* Check the parameters */
    125            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
    126           
    127            if (TIMx == TIM1)
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable6
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD10A             BNE.N    ??TIM_DeInit_0
    128            {
    129              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xF44F 0x6000      MOV      R0,#+2048
   \       0x10   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    130              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xF44F 0x6000      MOV      R0,#+2048
   \       0x1A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \       0x1E   0xE0DD             B.N      ??TIM_DeInit_1
    131            }     
    132            else if (TIMx == TIM2)
   \                     ??TIM_DeInit_0: (+1)
   \       0x20   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x24   0xD108             BNE.N    ??TIM_DeInit_2
    133            {
    134              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    135              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0x36   0xE0D1             B.N      ??TIM_DeInit_1
    136            }
    137            else if (TIMx == TIM3)
   \                     ??TIM_DeInit_2: (+1)
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable7
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD108             BNE.N    ??TIM_DeInit_3
    138            {
    139              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    140              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x2002             MOVS     R0,#+2
   \       0x4C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0x50   0xE0C4             B.N      ??TIM_DeInit_1
    141            }
    142            else if (TIMx == TIM4)
   \                     ??TIM_DeInit_3: (+1)
   \       0x52   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD108             BNE.N    ??TIM_DeInit_4
    143            {
    144              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x2004             MOVS     R0,#+4
   \       0x5E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    145              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x2004             MOVS     R0,#+4
   \       0x66   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0x6A   0xE0B7             B.N      ??TIM_DeInit_1
    146            } 
    147            else if (TIMx == TIM5)
   \                     ??TIM_DeInit_4: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD108             BNE.N    ??TIM_DeInit_5
    148            {
    149              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
   \       0x74   0x2101             MOVS     R1,#+1
   \       0x76   0x2008             MOVS     R0,#+8
   \       0x78   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    150              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x2008             MOVS     R0,#+8
   \       0x80   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0x84   0xE0AA             B.N      ??TIM_DeInit_1
    151            } 
    152            else if (TIMx == TIM6)
   \                     ??TIM_DeInit_5: (+1)
   \       0x86   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \       0x8A   0x4288             CMP      R0,R1
   \       0x8C   0xD108             BNE.N    ??TIM_DeInit_6
    153            {
    154              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \       0x8E   0x2101             MOVS     R1,#+1
   \       0x90   0x2010             MOVS     R0,#+16
   \       0x92   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    155              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0x2010             MOVS     R0,#+16
   \       0x9A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0x9E   0xE09D             B.N      ??TIM_DeInit_1
    156            } 
    157            else if (TIMx == TIM7)
   \                     ??TIM_DeInit_6: (+1)
   \       0xA0   0x.... 0x....      LDR.W    R1,??DataTable7_4
   \       0xA4   0x4288             CMP      R0,R1
   \       0xA6   0xD108             BNE.N    ??TIM_DeInit_7
    158            {
    159              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \       0xA8   0x2101             MOVS     R1,#+1
   \       0xAA   0x2020             MOVS     R0,#+32
   \       0xAC   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    160              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x2020             MOVS     R0,#+32
   \       0xB4   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \       0xB8   0xE090             B.N      ??TIM_DeInit_1
    161            } 
    162            else if (TIMx == TIM8)
   \                     ??TIM_DeInit_7: (+1)
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable8
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD10A             BNE.N    ??TIM_DeInit_8
    163            {
    164              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
   \       0xC2   0x2101             MOVS     R1,#+1
   \       0xC4   0xF44F 0x5000      MOV      R0,#+8192
   \       0xC8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    165              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
   \       0xCC   0x2100             MOVS     R1,#+0
   \       0xCE   0xF44F 0x5000      MOV      R0,#+8192
   \       0xD2   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \       0xD6   0xE081             B.N      ??TIM_DeInit_1
    166            }
    167            else if (TIMx == TIM9)
   \                     ??TIM_DeInit_8: (+1)
   \       0xD8   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \       0xDC   0x4288             CMP      R0,R1
   \       0xDE   0xD10A             BNE.N    ??TIM_DeInit_9
    168            {      
    169              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
   \       0xE0   0x2101             MOVS     R1,#+1
   \       0xE2   0xF45F 0x2000      MOVS     R0,#+524288
   \       0xE6   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    170              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
   \       0xEA   0x2100             MOVS     R1,#+0
   \       0xEC   0xF45F 0x2000      MOVS     R0,#+524288
   \       0xF0   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \       0xF4   0xE072             B.N      ??TIM_DeInit_1
    171             }  
    172            else if (TIMx == TIM10)
   \                     ??TIM_DeInit_9: (+1)
   \       0xF6   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \       0xFA   0x4288             CMP      R0,R1
   \       0xFC   0xD10A             BNE.N    ??TIM_DeInit_10
    173            {      
    174              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
   \       0xFE   0x2101             MOVS     R1,#+1
   \      0x100   0xF45F 0x1080      MOVS     R0,#+1048576
   \      0x104   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    175              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
   \      0x108   0x2100             MOVS     R1,#+0
   \      0x10A   0xF45F 0x1080      MOVS     R0,#+1048576
   \      0x10E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \      0x112   0xE063             B.N      ??TIM_DeInit_1
    176            }  
    177            else if (TIMx == TIM11) 
   \                     ??TIM_DeInit_10: (+1)
   \      0x114   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \      0x118   0x4288             CMP      R0,R1
   \      0x11A   0xD10A             BNE.N    ??TIM_DeInit_11
    178            {     
    179              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
   \      0x11C   0x2101             MOVS     R1,#+1
   \      0x11E   0xF45F 0x1000      MOVS     R0,#+2097152
   \      0x122   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    180              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
   \      0x126   0x2100             MOVS     R1,#+0
   \      0x128   0xF45F 0x1000      MOVS     R0,#+2097152
   \      0x12C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \      0x130   0xE054             B.N      ??TIM_DeInit_1
    181            }  
    182            else if (TIMx == TIM12)
   \                     ??TIM_DeInit_11: (+1)
   \      0x132   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \      0x136   0x4288             CMP      R0,R1
   \      0x138   0xD108             BNE.N    ??TIM_DeInit_12
    183            {      
    184              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
   \      0x13A   0x2101             MOVS     R1,#+1
   \      0x13C   0x2040             MOVS     R0,#+64
   \      0x13E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    185              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
   \      0x142   0x2100             MOVS     R1,#+0
   \      0x144   0x2040             MOVS     R0,#+64
   \      0x146   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \      0x14A   0xE047             B.N      ??TIM_DeInit_1
    186            }  
    187            else if (TIMx == TIM13) 
   \                     ??TIM_DeInit_12: (+1)
   \      0x14C   0x.... 0x....      LDR.W    R1,??DataTable9
   \      0x150   0x4288             CMP      R0,R1
   \      0x152   0xD108             BNE.N    ??TIM_DeInit_13
    188            {       
    189              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
   \      0x154   0x2101             MOVS     R1,#+1
   \      0x156   0x2080             MOVS     R0,#+128
   \      0x158   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    190              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
   \      0x15C   0x2100             MOVS     R1,#+0
   \      0x15E   0x2080             MOVS     R0,#+128
   \      0x160   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \      0x164   0xE03A             B.N      ??TIM_DeInit_1
    191            }
    192            else if (TIMx == TIM14) 
   \                     ??TIM_DeInit_13: (+1)
   \      0x166   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \      0x16A   0x4288             CMP      R0,R1
   \      0x16C   0xD10A             BNE.N    ??TIM_DeInit_14
    193            {       
    194              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
   \      0x16E   0x2101             MOVS     R1,#+1
   \      0x170   0xF44F 0x7080      MOV      R0,#+256
   \      0x174   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    195              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
   \      0x178   0x2100             MOVS     R1,#+0
   \      0x17A   0xF44F 0x7080      MOV      R0,#+256
   \      0x17E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \      0x182   0xE02B             B.N      ??TIM_DeInit_1
    196            }        
    197            else if (TIMx == TIM15)
   \                     ??TIM_DeInit_14: (+1)
   \      0x184   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \      0x188   0x4288             CMP      R0,R1
   \      0x18A   0xD10A             BNE.N    ??TIM_DeInit_15
    198            {
    199              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
   \      0x18C   0x2101             MOVS     R1,#+1
   \      0x18E   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x192   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    200              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
   \      0x196   0x2100             MOVS     R1,#+0
   \      0x198   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x19C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \      0x1A0   0xE01C             B.N      ??TIM_DeInit_1
    201            } 
    202            else if (TIMx == TIM16)
   \                     ??TIM_DeInit_15: (+1)
   \      0x1A2   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \      0x1A6   0x4288             CMP      R0,R1
   \      0x1A8   0xD10A             BNE.N    ??TIM_DeInit_16
    203            {
    204              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
   \      0x1AA   0x2101             MOVS     R1,#+1
   \      0x1AC   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x1B0   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    205              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
   \      0x1B4   0x2100             MOVS     R1,#+0
   \      0x1B6   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x1BA   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \      0x1BE   0xE00D             B.N      ??TIM_DeInit_1
    206            } 
    207            else
    208            {
    209              if (TIMx == TIM17)
   \                     ??TIM_DeInit_16: (+1)
   \      0x1C0   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \      0x1C4   0x4288             CMP      R0,R1
   \      0x1C6   0xD109             BNE.N    ??TIM_DeInit_1
    210              {
    211                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
   \      0x1C8   0x2101             MOVS     R1,#+1
   \      0x1CA   0xF45F 0x2080      MOVS     R0,#+262144
   \      0x1CE   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    212                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
   \      0x1D2   0x2100             MOVS     R1,#+0
   \      0x1D4   0xF45F 0x2080      MOVS     R0,#+262144
   \      0x1D8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    213              }  
    214            }
    215          }
   \                     ??TIM_DeInit_1: (+1)
   \      0x1DC   0xBD01             POP      {R0,PC}
    216          
    217          /**
    218            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    219            *         the specified parameters in the TIM_TimeBaseInitStruct.
    220            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    221            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    222            *         structure that contains the configuration information for the 
    223            *         specified TIM peripheral.
    224            * @retval None
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    227          {
    228            uint16_t tmpcr1 = 0;
   \                     TIM_TimeBaseInit: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    229          
    230            /* Check the parameters */
    231            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
    232            //assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    233            //assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    234          
    235            tmpcr1 = TIMx->CR1;  
   \        0x2   0x8803             LDRH     R3,[R0, #+0]
    236          
    237            if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
    238               (TIMx == TIM4) || (TIMx == TIM5)) 
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable6
   \        0x8   0x4290             CMP      R0,R2
   \        0xA   0xD012             BEQ.N    ??TIM_TimeBaseInit_0
   \        0xC   0x.... 0x....      LDR.W    R2,??DataTable8
   \       0x10   0x4290             CMP      R0,R2
   \       0x12   0xD00E             BEQ.N    ??TIM_TimeBaseInit_0
   \       0x14   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x18   0xD00B             BEQ.N    ??TIM_TimeBaseInit_0
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable7
   \       0x1E   0x4290             CMP      R0,R2
   \       0x20   0xD007             BEQ.N    ??TIM_TimeBaseInit_0
   \       0x22   0x.... 0x....      LDR.W    R2,??DataTable7_1
   \       0x26   0x4290             CMP      R0,R2
   \       0x28   0xD003             BEQ.N    ??TIM_TimeBaseInit_0
   \       0x2A   0x.... 0x....      LDR.W    R2,??DataTable7_2
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD104             BNE.N    ??TIM_TimeBaseInit_1
    239            {
    240              /* Select the Counter Mode */
    241              tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   \                     ??TIM_TimeBaseInit_0: (+1)
   \       0x32   0xF64F 0x728F      MOVW     R2,#+65423
   \       0x36   0x4013             ANDS     R3,R2,R3
    242              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
   \       0x38   0x884A             LDRH     R2,[R1, #+2]
   \       0x3A   0x4313             ORRS     R3,R2,R3
    243            }
    244           
    245            if((TIMx != TIM6) && (TIMx != TIM7))
   \                     ??TIM_TimeBaseInit_1: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD008             BEQ.N    ??TIM_TimeBaseInit_2
   \       0x44   0x.... 0x....      LDR.W    R2,??DataTable7_4
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD004             BEQ.N    ??TIM_TimeBaseInit_2
    246            {
    247              /* Set the clock division */
    248              tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
   \       0x4C   0xF64F 0x42FF      MOVW     R2,#+64767
   \       0x50   0x4013             ANDS     R3,R2,R3
    249              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
   \       0x52   0x88CA             LDRH     R2,[R1, #+6]
   \       0x54   0x4313             ORRS     R3,R2,R3
    250            }
    251          
    252            TIMx->CR1 = tmpcr1;
   \                     ??TIM_TimeBaseInit_2: (+1)
   \       0x56   0x8003             STRH     R3,[R0, #+0]
    253          
    254            /* Set the Autoreload value */
    255            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \       0x58   0x888A             LDRH     R2,[R1, #+4]
   \       0x5A   0x8582             STRH     R2,[R0, #+44]
    256           
    257            /* Set the Prescaler value */
    258            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \       0x5C   0x880A             LDRH     R2,[R1, #+0]
   \       0x5E   0x8502             STRH     R2,[R0, #+40]
    259              
    260            if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
   \       0x60   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x64   0x4290             CMP      R0,R2
   \       0x66   0xD00F             BEQ.N    ??TIM_TimeBaseInit_3
   \       0x68   0x.... 0x....      LDR.W    R2,??DataTable8
   \       0x6C   0x4290             CMP      R0,R2
   \       0x6E   0xD00B             BEQ.N    ??TIM_TimeBaseInit_3
   \       0x70   0x.... 0x....      LDR.W    R2,??DataTable9_2
   \       0x74   0x4290             CMP      R0,R2
   \       0x76   0xD007             BEQ.N    ??TIM_TimeBaseInit_3
   \       0x78   0x.... 0x....      LDR.W    R2,??DataTable9_3
   \       0x7C   0x4290             CMP      R0,R2
   \       0x7E   0xD003             BEQ.N    ??TIM_TimeBaseInit_3
   \       0x80   0x.... 0x....      LDR.W    R2,??DataTable9_4
   \       0x84   0x4290             CMP      R0,R2
   \       0x86   0xD101             BNE.N    ??TIM_TimeBaseInit_4
    261            {
    262              /* Set the Repetition Counter value */
    263              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
   \                     ??TIM_TimeBaseInit_3: (+1)
   \       0x88   0x7A09             LDRB     R1,[R1, #+8]
   \       0x8A   0x8601             STRH     R1,[R0, #+48]
    264            }
    265          
    266            /* Generate an update event to reload the Prescaler and the Repetition counter
    267               values immediately */
    268            TIMx->EGR = TIM_PSCReloadMode_Immediate;           
   \                     ??TIM_TimeBaseInit_4: (+1)
   \       0x8C   0x2101             MOVS     R1,#+1
   \       0x8E   0x8281             STRH     R1,[R0, #+20]
    269          }
   \       0x90   0x4770             BX       LR
    270          
    271          /**
    272            * @brief  Initializes the TIMx Channel1 according to the specified
    273            *         parameters in the TIM_OCInitStruct.
    274            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    275            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    276            *         that contains the configuration information for the specified TIM peripheral.
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    280          {
   \                     TIM_OC1Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    281            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    282             
    283            /* Check the parameters */
    284            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    285            //assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    286            //assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    287            //assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    288           /* Disable the Channel 1: Reset the CC1E Bit */
    289            TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
   \        0x8   0x8C03             LDRH     R3,[R0, #+32]
   \        0xA   0xF64F 0x72FE      MOVW     R2,#+65534
   \        0xE   0x4013             ANDS     R3,R2,R3
   \       0x10   0x8403             STRH     R3,[R0, #+32]
    290            /* Get the TIMx CCER register value */
    291            tmpccer = TIMx->CCER;
   \       0x12   0x8C05             LDRH     R5,[R0, #+32]
    292            /* Get the TIMx CR2 register value */
    293            tmpcr2 =  TIMx->CR2;
   \       0x14   0x8883             LDRH     R3,[R0, #+4]
    294            
    295            /* Get the TIMx CCMR1 register value */
    296            tmpccmrx = TIMx->CCMR1;
   \       0x16   0x8B04             LDRH     R4,[R0, #+24]
    297              
    298            /* Reset the Output Compare Mode Bits */
    299            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
   \       0x18   0xF64F 0x728F      MOVW     R2,#+65423
   \       0x1C   0x4014             ANDS     R4,R2,R4
    300            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
   \       0x1E   0xF64F 0x72FC      MOVW     R2,#+65532
   \       0x22   0x4014             ANDS     R4,R2,R4
    301          
    302            /* Select the Output Compare Mode */
    303            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \       0x24   0x880A             LDRH     R2,[R1, #+0]
   \       0x26   0x4314             ORRS     R4,R2,R4
    304            
    305            /* Reset the Output Polarity level */
    306            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
   \       0x28   0xF64F 0x72FD      MOVW     R2,#+65533
   \       0x2C   0x4015             ANDS     R5,R2,R5
    307            /* Set the Output Compare Polarity */
    308            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
   \       0x2E   0x890A             LDRH     R2,[R1, #+8]
   \       0x30   0x4315             ORRS     R5,R2,R5
    309            
    310            /* Set the Output State */
    311            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \       0x32   0x884A             LDRH     R2,[R1, #+2]
   \       0x34   0x4315             ORRS     R5,R2,R5
    312              
    313            if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
    314               (TIMx == TIM16)|| (TIMx == TIM17))
   \       0x36   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x3A   0x4290             CMP      R0,R2
   \       0x3C   0xD00F             BEQ.N    ??TIM_OC1Init_0
   \       0x3E   0x.... 0x....      LDR.W    R2,??DataTable8
   \       0x42   0x4290             CMP      R0,R2
   \       0x44   0xD00B             BEQ.N    ??TIM_OC1Init_0
   \       0x46   0x.... 0x....      LDR.W    R2,??DataTable9_2
   \       0x4A   0x4290             CMP      R0,R2
   \       0x4C   0xD007             BEQ.N    ??TIM_OC1Init_0
   \       0x4E   0x.... 0x....      LDR.W    R2,??DataTable9_3
   \       0x52   0x4290             CMP      R0,R2
   \       0x54   0xD003             BEQ.N    ??TIM_OC1Init_0
   \       0x56   0x.... 0x....      LDR.W    R2,??DataTable9_4
   \       0x5A   0x4290             CMP      R0,R2
   \       0x5C   0xD113             BNE.N    ??TIM_OC1Init_1
    315            {
    316              //assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    317              //assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    318              //assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    319              //assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    320              
    321              /* Reset the Output N Polarity level */
    322              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
   \                     ??TIM_OC1Init_0: (+1)
   \       0x5E   0xF64F 0x72F7      MOVW     R2,#+65527
   \       0x62   0x4015             ANDS     R5,R2,R5
    323              /* Set the Output N Polarity */
    324              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
   \       0x64   0x894A             LDRH     R2,[R1, #+10]
   \       0x66   0x4315             ORRS     R5,R2,R5
    325              
    326              /* Reset the Output N State */
    327              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
   \       0x68   0xF64F 0x72FB      MOVW     R2,#+65531
   \       0x6C   0x4015             ANDS     R5,R2,R5
    328              /* Set the Output N State */
    329              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
   \       0x6E   0x888A             LDRH     R2,[R1, #+4]
   \       0x70   0x4315             ORRS     R5,R2,R5
    330              
    331              /* Reset the Output Compare and Output Compare N IDLE State */
    332              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
   \       0x72   0xF64F 0x62FF      MOVW     R2,#+65279
   \       0x76   0x4013             ANDS     R3,R2,R3
    333              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
   \       0x78   0xF64F 0x52FF      MOVW     R2,#+65023
   \       0x7C   0x4013             ANDS     R3,R2,R3
    334              
    335              /* Set the Output Idle state */
    336              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
   \       0x7E   0x898A             LDRH     R2,[R1, #+12]
   \       0x80   0x4313             ORRS     R3,R2,R3
    337              /* Set the Output N Idle state */
    338              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
   \       0x82   0x89CA             LDRH     R2,[R1, #+14]
   \       0x84   0x4313             ORRS     R3,R2,R3
    339            }
    340            /* Write to TIMx CR2 */
    341            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1Init_1: (+1)
   \       0x86   0x8083             STRH     R3,[R0, #+4]
    342            
    343            /* Write to TIMx CCMR1 */
    344            TIMx->CCMR1 = tmpccmrx;
   \       0x88   0x8304             STRH     R4,[R0, #+24]
    345          
    346            /* Set the Capture Compare Register value */
    347            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
   \       0x8A   0x88C9             LDRH     R1,[R1, #+6]
   \       0x8C   0x8681             STRH     R1,[R0, #+52]
    348           
    349            /* Write to TIMx CCER */
    350            TIMx->CCER = tmpccer;
   \       0x8E   0x8405             STRH     R5,[R0, #+32]
    351          }
   \       0x90   0xBC30             POP      {R4,R5}
   \       0x92   0x4770             BX       LR
    352          
    353          /**
    354            * @brief  Initializes the TIMx Channel2 according to the specified
    355            *         parameters in the TIM_OCInitStruct.
    356            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
    357            *         the TIM peripheral.
    358            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    359            *         that contains the configuration information for the specified TIM peripheral.
    360            * @retval None
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    363          {
   \                     TIM_OC2Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    364            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    365             
    366            /* Check the parameters */
    367            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    368            //assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    369            //assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    370            //assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    371             /* Disable the Channel 2: Reset the CC2E Bit */
    372            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
   \        0x8   0x8C03             LDRH     R3,[R0, #+32]
   \        0xA   0xF64F 0x72EF      MOVW     R2,#+65519
   \        0xE   0x4013             ANDS     R3,R2,R3
   \       0x10   0x8403             STRH     R3,[R0, #+32]
    373            
    374            /* Get the TIMx CCER register value */  
    375            tmpccer = TIMx->CCER;
   \       0x12   0x8C05             LDRH     R5,[R0, #+32]
    376            /* Get the TIMx CR2 register value */
    377            tmpcr2 =  TIMx->CR2;
   \       0x14   0x8883             LDRH     R3,[R0, #+4]
    378            
    379            /* Get the TIMx CCMR1 register value */
    380            tmpccmrx = TIMx->CCMR1;
   \       0x16   0x8B04             LDRH     R4,[R0, #+24]
    381              
    382            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    383            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
   \       0x18   0xF648 0x72FF      MOVW     R2,#+36863
   \       0x1C   0x4014             ANDS     R4,R2,R4
    384            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
   \       0x1E   0xF64F 0x42FF      MOVW     R2,#+64767
   \       0x22   0x4014             ANDS     R4,R2,R4
    385            
    386            /* Select the Output Compare Mode */
    387            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \       0x24   0x880A             LDRH     R2,[R1, #+0]
   \       0x26   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
    388            
    389            /* Reset the Output Polarity level */
    390            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
   \       0x2A   0xF64F 0x72DF      MOVW     R2,#+65503
   \       0x2E   0x4015             ANDS     R5,R2,R5
    391            /* Set the Output Compare Polarity */
    392            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
   \       0x30   0x890A             LDRH     R2,[R1, #+8]
   \       0x32   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
    393            
    394            /* Set the Output State */
    395            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
   \       0x36   0x884A             LDRH     R2,[R1, #+2]
   \       0x38   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
    396              
    397            if((TIMx == TIM1) || (TIMx == TIM8))
   \       0x3C   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD003             BEQ.N    ??TIM_OC2Init_0
   \       0x44   0x.... 0x....      LDR.W    R2,??DataTable9_5
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD117             BNE.N    ??TIM_OC2Init_1
    398            {
    399              //assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    400              //assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    401              //assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    402              //assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    403              
    404              /* Reset the Output N Polarity level */
    405              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
   \                     ??TIM_OC2Init_0: (+1)
   \       0x4C   0xF64F 0x727F      MOVW     R2,#+65407
   \       0x50   0x4015             ANDS     R5,R2,R5
    406              /* Set the Output N Polarity */
    407              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
   \       0x52   0x894A             LDRH     R2,[R1, #+10]
   \       0x54   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
    408              
    409              /* Reset the Output N State */
    410              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
   \       0x58   0xF64F 0x72BF      MOVW     R2,#+65471
   \       0x5C   0x4015             ANDS     R5,R2,R5
    411              /* Set the Output N State */
    412              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
   \       0x5E   0x888A             LDRH     R2,[R1, #+4]
   \       0x60   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
    413              
    414              /* Reset the Output Compare and Output Compare N IDLE State */
    415              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
   \       0x64   0xF64F 0x32FF      MOVW     R2,#+64511
   \       0x68   0x4013             ANDS     R3,R2,R3
    416              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
   \       0x6A   0xF24F 0x72FF      MOVW     R2,#+63487
   \       0x6E   0x4013             ANDS     R3,R2,R3
    417              
    418              /* Set the Output Idle state */
    419              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
   \       0x70   0x898A             LDRH     R2,[R1, #+12]
   \       0x72   0xEA53 0x0382      ORRS     R3,R3,R2, LSL #+2
    420              /* Set the Output N Idle state */
    421              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
   \       0x76   0x89CA             LDRH     R2,[R1, #+14]
   \       0x78   0xEA53 0x0382      ORRS     R3,R3,R2, LSL #+2
    422            }
    423            /* Write to TIMx CR2 */
    424            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2Init_1: (+1)
   \       0x7C   0x8083             STRH     R3,[R0, #+4]
    425            
    426            /* Write to TIMx CCMR1 */
    427            TIMx->CCMR1 = tmpccmrx;
   \       0x7E   0x8304             STRH     R4,[R0, #+24]
    428          
    429            /* Set the Capture Compare Register value */
    430            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \       0x80   0x88C9             LDRH     R1,[R1, #+6]
   \       0x82   0x8701             STRH     R1,[R0, #+56]
    431            
    432            /* Write to TIMx CCER */
    433            TIMx->CCER = tmpccer;
   \       0x84   0x8405             STRH     R5,[R0, #+32]
    434          }
   \       0x86   0xBC30             POP      {R4,R5}
   \       0x88   0x4770             BX       LR
    435          
    436          /**
    437            * @brief  Initializes the TIMx Channel3 according to the specified
    438            *         parameters in the TIM_OCInitStruct.
    439            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    440            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    441            *         that contains the configuration information for the specified TIM peripheral.
    442            * @retval None
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    445          {
   \                     TIM_OC3Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    446            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    447             
    448            /* Check the parameters */
    449            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    450            //assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    451            //assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    452            //assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    453            /* Disable the Channel 2: Reset the CC2E Bit */
    454            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
   \        0x8   0x8C03             LDRH     R3,[R0, #+32]
   \        0xA   0xF64F 0x62FF      MOVW     R2,#+65279
   \        0xE   0x4013             ANDS     R3,R2,R3
   \       0x10   0x8403             STRH     R3,[R0, #+32]
    455            
    456            /* Get the TIMx CCER register value */
    457            tmpccer = TIMx->CCER;
   \       0x12   0x8C05             LDRH     R5,[R0, #+32]
    458            /* Get the TIMx CR2 register value */
    459            tmpcr2 =  TIMx->CR2;
   \       0x14   0x8883             LDRH     R3,[R0, #+4]
    460            
    461            /* Get the TIMx CCMR2 register value */
    462            tmpccmrx = TIMx->CCMR2;
   \       0x16   0x8B84             LDRH     R4,[R0, #+28]
    463              
    464            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    465            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
   \       0x18   0xF64F 0x728F      MOVW     R2,#+65423
   \       0x1C   0x4014             ANDS     R4,R2,R4
    466            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
   \       0x1E   0xF64F 0x72FC      MOVW     R2,#+65532
   \       0x22   0x4014             ANDS     R4,R2,R4
    467            /* Select the Output Compare Mode */
    468            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \       0x24   0x880A             LDRH     R2,[R1, #+0]
   \       0x26   0x4314             ORRS     R4,R2,R4
    469            
    470            /* Reset the Output Polarity level */
    471            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
   \       0x28   0xF64F 0x52FF      MOVW     R2,#+65023
   \       0x2C   0x4015             ANDS     R5,R2,R5
    472            /* Set the Output Compare Polarity */
    473            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
   \       0x2E   0x890A             LDRH     R2,[R1, #+8]
   \       0x30   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
    474            
    475            /* Set the Output State */
    476            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
   \       0x34   0x884A             LDRH     R2,[R1, #+2]
   \       0x36   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
    477              
    478            if((TIMx == TIM1) || (TIMx == TIM8))
   \       0x3A   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x3E   0x4290             CMP      R0,R2
   \       0x40   0xD003             BEQ.N    ??TIM_OC3Init_0
   \       0x42   0x.... 0x....      LDR.W    R2,??DataTable9_5
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xD117             BNE.N    ??TIM_OC3Init_1
    479            {
    480              //assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    481              //assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    482              //assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    483              //assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    484              
    485              /* Reset the Output N Polarity level */
    486              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
   \                     ??TIM_OC3Init_0: (+1)
   \       0x4A   0xF24F 0x72FF      MOVW     R2,#+63487
   \       0x4E   0x4015             ANDS     R5,R2,R5
    487              /* Set the Output N Polarity */
    488              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
   \       0x50   0x894A             LDRH     R2,[R1, #+10]
   \       0x52   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
    489              /* Reset the Output N State */
    490              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
   \       0x56   0xF64F 0x32FF      MOVW     R2,#+64511
   \       0x5A   0x4015             ANDS     R5,R2,R5
    491              
    492              /* Set the Output N State */
    493              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
   \       0x5C   0x888A             LDRH     R2,[R1, #+4]
   \       0x5E   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
    494              /* Reset the Output Compare and Output Compare N IDLE State */
    495              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
   \       0x62   0xF64E 0x72FF      MOVW     R2,#+61439
   \       0x66   0x4013             ANDS     R3,R2,R3
    496              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
   \       0x68   0xF64D 0x72FF      MOVW     R2,#+57343
   \       0x6C   0x4013             ANDS     R3,R2,R3
    497              /* Set the Output Idle state */
    498              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
   \       0x6E   0x898A             LDRH     R2,[R1, #+12]
   \       0x70   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
    499              /* Set the Output N Idle state */
    500              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
   \       0x74   0x89CA             LDRH     R2,[R1, #+14]
   \       0x76   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
    501            }
    502            /* Write to TIMx CR2 */
    503            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3Init_1: (+1)
   \       0x7A   0x8083             STRH     R3,[R0, #+4]
    504            
    505            /* Write to TIMx CCMR2 */
    506            TIMx->CCMR2 = tmpccmrx;
   \       0x7C   0x8384             STRH     R4,[R0, #+28]
    507          
    508            /* Set the Capture Compare Register value */
    509            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \       0x7E   0x88C9             LDRH     R1,[R1, #+6]
   \       0x80   0x8781             STRH     R1,[R0, #+60]
    510            
    511            /* Write to TIMx CCER */
    512            TIMx->CCER = tmpccer;
   \       0x82   0x8405             STRH     R5,[R0, #+32]
    513          }
   \       0x84   0xBC30             POP      {R4,R5}
   \       0x86   0x4770             BX       LR
    514          
    515          /**
    516            * @brief  Initializes the TIMx Channel4 according to the specified
    517            *         parameters in the TIM_OCInitStruct.
    518            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    519            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    520            *         that contains the configuration information for the specified TIM peripheral.
    521            * @retval None
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    524          {
   \                     TIM_OC4Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    525            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    526             
    527            /* Check the parameters */
    528            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    529            //assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    530            //assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    531            //assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    532            /* Disable the Channel 2: Reset the CC4E Bit */
    533            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
   \        0x8   0x8C03             LDRH     R3,[R0, #+32]
   \        0xA   0xF64E 0x72FF      MOVW     R2,#+61439
   \        0xE   0x4013             ANDS     R3,R2,R3
   \       0x10   0x8403             STRH     R3,[R0, #+32]
    534            
    535            /* Get the TIMx CCER register value */
    536            tmpccer = TIMx->CCER;
   \       0x12   0x8C04             LDRH     R4,[R0, #+32]
    537            /* Get the TIMx CR2 register value */
    538            tmpcr2 =  TIMx->CR2;
   \       0x14   0x8885             LDRH     R5,[R0, #+4]
    539            
    540            /* Get the TIMx CCMR2 register value */
    541            tmpccmrx = TIMx->CCMR2;
   \       0x16   0x8B83             LDRH     R3,[R0, #+28]
    542              
    543            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    544            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
   \       0x18   0xF648 0x72FF      MOVW     R2,#+36863
   \       0x1C   0x4013             ANDS     R3,R2,R3
    545            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
   \       0x1E   0xF64F 0x42FF      MOVW     R2,#+64767
   \       0x22   0x4013             ANDS     R3,R2,R3
    546            
    547            /* Select the Output Compare Mode */
    548            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \       0x24   0x880A             LDRH     R2,[R1, #+0]
   \       0x26   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
    549            
    550            /* Reset the Output Polarity level */
    551            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
   \       0x2A   0xF64D 0x72FF      MOVW     R2,#+57343
   \       0x2E   0x4014             ANDS     R4,R2,R4
    552            /* Set the Output Compare Polarity */
    553            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
   \       0x30   0x890A             LDRH     R2,[R1, #+8]
   \       0x32   0xEA54 0x3402      ORRS     R4,R4,R2, LSL #+12
    554            
    555            /* Set the Output State */
    556            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
   \       0x36   0x884A             LDRH     R2,[R1, #+2]
   \       0x38   0xEA54 0x3402      ORRS     R4,R4,R2, LSL #+12
    557              
    558            if((TIMx == TIM1) || (TIMx == TIM8))
   \       0x3C   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD003             BEQ.N    ??TIM_OC4Init_0
   \       0x44   0x.... 0x....      LDR.W    R2,??DataTable9_5
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD105             BNE.N    ??TIM_OC4Init_1
    559            {
    560              //assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    561              /* Reset the Output Compare IDLE State */
    562              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
   \                     ??TIM_OC4Init_0: (+1)
   \       0x4C   0xF64B 0x72FF      MOVW     R2,#+49151
   \       0x50   0x4015             ANDS     R5,R2,R5
    563              /* Set the Output Idle state */
    564              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
   \       0x52   0x898A             LDRH     R2,[R1, #+12]
   \       0x54   0xEA55 0x1582      ORRS     R5,R5,R2, LSL #+6
    565            }
    566            /* Write to TIMx CR2 */
    567            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4Init_1: (+1)
   \       0x58   0x8085             STRH     R5,[R0, #+4]
    568            
    569            /* Write to TIMx CCMR2 */  
    570            TIMx->CCMR2 = tmpccmrx;
   \       0x5A   0x8383             STRH     R3,[R0, #+28]
    571          
    572            /* Set the Capture Compare Register value */
    573            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \       0x5C   0x88C9             LDRH     R1,[R1, #+6]
   \       0x5E   0xF8A0 0x1040      STRH     R1,[R0, #+64]
    574            
    575            /* Write to TIMx CCER */
    576            TIMx->CCER = tmpccer;
   \       0x62   0x8404             STRH     R4,[R0, #+32]
    577          }
   \       0x64   0xBC30             POP      {R4,R5}
   \       0x66   0x4770             BX       LR
    578          
    579          /**
    580            * @brief  Initializes the TIM peripheral according to the specified
    581            *         parameters in the TIM_ICInitStruct.
    582            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    583            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    584            *         that contains the configuration information for the specified TIM peripheral.
    585            * @retval None
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    588          {
   \                     TIM_ICInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    589            /* Check the parameters */
    590            //assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    591            //assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    592            //assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    593            //assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    594            
    595            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
    596               (TIMx == TIM4) ||(TIMx == TIM5))
    597            {
    598              //assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    599            }
    600            else
    601            {
    602              //assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
    603            }
    604            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \        0x6   0x8828             LDRH     R0,[R5, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD10A             BNE.N    ??TIM_ICInit_0
    605            {
    606              //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    607              /* TI1 Configuration */
    608              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    609                         TIM_ICInitStruct->TIM_ICSelection,
    610                         TIM_ICInitStruct->TIM_ICFilter);
   \        0xC   0x892B             LDRH     R3,[R5, #+8]
   \        0xE   0x88AA             LDRH     R2,[R5, #+4]
   \       0x10   0x8869             LDRH     R1,[R5, #+2]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       TI1_Config
    611              /* Set the Input Capture Prescaler value */
    612              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x18   0x88E9             LDRH     R1,[R5, #+6]
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       TIM_SetIC1Prescaler
   \       0x20   0xE025             B.N      ??TIM_ICInit_1
    613            }
    614            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0: (+1)
   \       0x22   0x8828             LDRH     R0,[R5, #+0]
   \       0x24   0x2804             CMP      R0,#+4
   \       0x26   0xD10A             BNE.N    ??TIM_ICInit_2
    615            {
    616              //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    617              /* TI2 Configuration */
    618              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    619                         TIM_ICInitStruct->TIM_ICSelection,
    620                         TIM_ICInitStruct->TIM_ICFilter);
   \       0x28   0x892B             LDRH     R3,[R5, #+8]
   \       0x2A   0x88AA             LDRH     R2,[R5, #+4]
   \       0x2C   0x8869             LDRH     R1,[R5, #+2]
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       TI2_Config
    621              /* Set the Input Capture Prescaler value */
    622              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x34   0x88E9             LDRH     R1,[R5, #+6]
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \       0x3C   0xE017             B.N      ??TIM_ICInit_1
    623            }
    624            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_2: (+1)
   \       0x3E   0x8828             LDRH     R0,[R5, #+0]
   \       0x40   0x2808             CMP      R0,#+8
   \       0x42   0xD10A             BNE.N    ??TIM_ICInit_3
    625            {
    626              //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    627              /* TI3 Configuration */
    628              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    629                         TIM_ICInitStruct->TIM_ICSelection,
    630                         TIM_ICInitStruct->TIM_ICFilter);
   \       0x44   0x892B             LDRH     R3,[R5, #+8]
   \       0x46   0x88AA             LDRH     R2,[R5, #+4]
   \       0x48   0x8869             LDRH     R1,[R5, #+2]
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       TI3_Config
    631              /* Set the Input Capture Prescaler value */
    632              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x50   0x88E9             LDRH     R1,[R5, #+6]
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       TIM_SetIC3Prescaler
   \       0x58   0xE009             B.N      ??TIM_ICInit_1
    633            }
    634            else
    635            {
    636              //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    637              /* TI4 Configuration */
    638              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    639                         TIM_ICInitStruct->TIM_ICSelection,
    640                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_3: (+1)
   \       0x5A   0x892B             LDRH     R3,[R5, #+8]
   \       0x5C   0x88AA             LDRH     R2,[R5, #+4]
   \       0x5E   0x8869             LDRH     R1,[R5, #+2]
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       TI4_Config
    641              /* Set the Input Capture Prescaler value */
    642              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x66   0x88E9             LDRH     R1,[R5, #+6]
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       TIM_SetIC4Prescaler
    643            }
    644          }
   \                     ??TIM_ICInit_1: (+1)
   \       0x6E   0xBD31             POP      {R0,R4,R5,PC}
    645          
    646          /**
    647            * @brief  Configures the TIM peripheral according to the specified
    648            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
    649            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
    650            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    651            *         that contains the configuration information for the specified TIM peripheral.
    652            * @retval None
    653            */

   \                                 In section .text, align 2, keep-with-next
    654          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    655          {
   \                     TIM_PWMIConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    656            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   \        0x6   0x2000             MOVS     R0,#+0
    657            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   \        0x8   0x2001             MOVS     R0,#+1
    658            /* Check the parameters */
    659            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    660            /* Select the Opposite Input Polarity */
    661            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \        0xA   0x8868             LDRH     R0,[R5, #+2]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??TIM_PWMIConfig_0
    662            {
    663              icoppositepolarity = TIM_ICPolarity_Falling;
   \       0x10   0x2602             MOVS     R6,#+2
   \       0x12   0xE000             B.N      ??TIM_PWMIConfig_1
    664            }
    665            else
    666            {
    667              icoppositepolarity = TIM_ICPolarity_Rising;
   \                     ??TIM_PWMIConfig_0: (+1)
   \       0x14   0x2600             MOVS     R6,#+0
    668            }
    669            /* Select the Opposite Input */
    670            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_1: (+1)
   \       0x16   0x88A8             LDRH     R0,[R5, #+4]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD101             BNE.N    ??TIM_PWMIConfig_2
    671            {
    672              icoppositeselection = TIM_ICSelection_IndirectTI;
   \       0x1C   0x2702             MOVS     R7,#+2
   \       0x1E   0xE000             B.N      ??TIM_PWMIConfig_3
    673            }
    674            else
    675            {
    676              icoppositeselection = TIM_ICSelection_DirectTI;
   \                     ??TIM_PWMIConfig_2: (+1)
   \       0x20   0x2701             MOVS     R7,#+1
    677            }
    678            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_PWMIConfig_3: (+1)
   \       0x22   0x8828             LDRH     R0,[R5, #+0]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD116             BNE.N    ??TIM_PWMIConfig_4
    679            {
    680              /* TI1 Configuration */
    681              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    682                         TIM_ICInitStruct->TIM_ICFilter);
   \       0x28   0x892B             LDRH     R3,[R5, #+8]
   \       0x2A   0x88AA             LDRH     R2,[R5, #+4]
   \       0x2C   0x8869             LDRH     R1,[R5, #+2]
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       TI1_Config
    683              /* Set the Input Capture Prescaler value */
    684              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x34   0x88E9             LDRH     R1,[R5, #+6]
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       TIM_SetIC1Prescaler
    685              /* TI2 Configuration */
    686              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \       0x3C   0x892B             LDRH     R3,[R5, #+8]
   \       0x3E   0x003A             MOVS     R2,R7
   \       0x40   0xB292             UXTH     R2,R2
   \       0x42   0x0031             MOVS     R1,R6
   \       0x44   0xB289             UXTH     R1,R1
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       TI2_Config
    687              /* Set the Input Capture Prescaler value */
    688              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x4C   0x88E9             LDRH     R1,[R5, #+6]
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \       0x54   0xE015             B.N      ??TIM_PWMIConfig_5
    689            }
    690            else
    691            { 
    692              /* TI2 Configuration */
    693              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    694                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_4: (+1)
   \       0x56   0x892B             LDRH     R3,[R5, #+8]
   \       0x58   0x88AA             LDRH     R2,[R5, #+4]
   \       0x5A   0x8869             LDRH     R1,[R5, #+2]
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       TI2_Config
    695              /* Set the Input Capture Prescaler value */
    696              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x62   0x88E9             LDRH     R1,[R5, #+6]
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       TIM_SetIC2Prescaler
    697              /* TI1 Configuration */
    698              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \       0x6A   0x892B             LDRH     R3,[R5, #+8]
   \       0x6C   0x003A             MOVS     R2,R7
   \       0x6E   0xB292             UXTH     R2,R2
   \       0x70   0x0031             MOVS     R1,R6
   \       0x72   0xB289             UXTH     R1,R1
   \       0x74   0x0020             MOVS     R0,R4
   \       0x76   0x.... 0x....      BL       TI1_Config
    699              /* Set the Input Capture Prescaler value */
    700              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \       0x7A   0x88E9             LDRH     R1,[R5, #+6]
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x.... 0x....      BL       TIM_SetIC1Prescaler
    701            }
    702          }
   \                     ??TIM_PWMIConfig_5: (+1)
   \       0x82   0xBDF1             POP      {R0,R4-R7,PC}
    703          
    704          /**
    705            * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
    706            *         the OSSR State and the AOE(automatic output enable).
    707            * @param  TIMx: where x can be  1 or 8 to select the TIM 
    708            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
    709            *         contains the BDTR Register configuration  information for the TIM peripheral.
    710            * @retval None
    711            */

   \                                 In section .text, align 2, keep-with-next
    712          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    713          {
    714            /* Check the parameters */
    715            //assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    716            //assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    717            //assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    718            //assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    719            //assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    720            //assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    721            //assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    722            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    723               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    724            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    725                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    726                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    727                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   \                     TIM_BDTRConfig: (+1)
   \        0x0   0x880B             LDRH     R3,[R1, #+0]
   \        0x2   0x884A             LDRH     R2,[R1, #+2]
   \        0x4   0x4313             ORRS     R3,R2,R3
   \        0x6   0x888A             LDRH     R2,[R1, #+4]
   \        0x8   0x4313             ORRS     R3,R2,R3
   \        0xA   0x88CA             LDRH     R2,[R1, #+6]
   \        0xC   0x4313             ORRS     R3,R2,R3
   \        0xE   0x890A             LDRH     R2,[R1, #+8]
   \       0x10   0x4313             ORRS     R3,R2,R3
   \       0x12   0x894A             LDRH     R2,[R1, #+10]
   \       0x14   0x4313             ORRS     R3,R2,R3
   \       0x16   0x8989             LDRH     R1,[R1, #+12]
   \       0x18   0x430B             ORRS     R3,R1,R3
   \       0x1A   0xF8A0 0x3044      STRH     R3,[R0, #+68]
    728          }
   \       0x1E   0x4770             BX       LR
    729          
    730          /**
    731            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    732            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    733            *         structure which will be initialized.
    734            * @retval None
    735            */

   \                                 In section .text, align 2, keep-with-next
    736          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    737          {
    738            /* Set the default configuration */
    739            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit: (+1)
   \        0x0   0xF64F 0x71FF      MOVW     R1,#+65535
   \        0x4   0x8081             STRH     R1,[R0, #+4]
    740            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x8001             STRH     R1,[R0, #+0]
    741            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x80C1             STRH     R1,[R0, #+6]
    742            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x8041             STRH     R1,[R0, #+2]
    743            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x7201             STRB     R1,[R0, #+8]
    744          }
   \       0x16   0x4770             BX       LR
    745          
    746          /**
    747            * @brief  Fills each TIM_OCInitStruct member with its default value.
    748            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    749            *         be initialized.
    750            * @retval None
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    753          {
    754            /* Set the default configuration */
    755            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    756            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x8041             STRH     R1,[R0, #+2]
    757            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    758            TIM_OCInitStruct->TIM_Pulse = 0x0000;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x80C1             STRH     R1,[R0, #+6]
    759            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x8101             STRH     R1,[R0, #+8]
    760            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x8141             STRH     R1,[R0, #+10]
    761            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x8181             STRH     R1,[R0, #+12]
    762            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x81C1             STRH     R1,[R0, #+14]
    763          }
   \       0x20   0x4770             BX       LR
    764          
    765          /**
    766            * @brief  Fills each TIM_ICInitStruct member with its default value.
    767            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
    768            *         be initialized.
    769            * @retval None
    770            */

   \                                 In section .text, align 2, keep-with-next
    771          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    772          {
    773            /* Set the default configuration */
    774            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    775            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x8041             STRH     R1,[R0, #+2]
    776            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    777            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x80C1             STRH     R1,[R0, #+6]
    778            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x8101             STRH     R1,[R0, #+8]
    779          }
   \       0x14   0x4770             BX       LR
    780          
    781          /**
    782            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
    783            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
    784            *         will be initialized.
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    788          {
    789            /* Set the default configuration */
    790            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   \                     TIM_BDTRStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    791            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x8041             STRH     R1,[R0, #+2]
    792            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    793            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x80C1             STRH     R1,[R0, #+6]
    794            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x8101             STRH     R1,[R0, #+8]
    795            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x8141             STRH     R1,[R0, #+10]
    796            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x8181             STRH     R1,[R0, #+12]
    797          }
   \       0x1C   0x4770             BX       LR
    798          
    799          /**
    800            * @brief  Enables or disables the specified TIM peripheral.
    801            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    802            * @param  NewState: new state of the TIMx peripheral.
    803            *   This parameter can be: ENABLE or DISABLE.
    804            * @retval None
    805            */

   \                                 In section .text, align 2, keep-with-next
    806          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    807          {
    808            /* Check the parameters */
    809            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
    810            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    811            
    812            if (NewState != DISABLE)
   \                     TIM_Cmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_Cmd_0
    813            {
    814              /* Enable the TIM Counter */
    815              TIMx->CR1 |= TIM_CR1_CEN;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??TIM_Cmd_1
    816            }
    817            else
    818            {
    819              /* Disable the TIM Counter */
    820              TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
   \                     ??TIM_Cmd_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
    821            }
    822          }
   \                     ??TIM_Cmd_1: (+1)
   \       0x1A   0x4770             BX       LR
    823          
    824          /**
    825            * @brief  Enables or disables the TIM peripheral Main Outputs.
    826            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
    827            * @param  NewState: new state of the TIM peripheral Main Outputs.
    828            *   This parameter can be: ENABLE or DISABLE.
    829            * @retval None
    830            */

   \                                 In section .text, align 2, keep-with-next
    831          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    832          {
    833            /* Check the parameters */
    834            //assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    835            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    836            if (NewState != DISABLE)
   \                     TIM_CtrlPWMOutputs: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD006             BEQ.N    ??TIM_CtrlPWMOutputs_0
    837            {
    838              /* Enable the TIM Main Output */
    839              TIMx->BDTR |= TIM_BDTR_MOE;
   \        0x6   0xF8B0 0x1044      LDRH     R1,[R0, #+68]
   \        0xA   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \        0xE   0xF8A0 0x1044      STRH     R1,[R0, #+68]
   \       0x12   0xE005             B.N      ??TIM_CtrlPWMOutputs_1
    840            }
    841            else
    842            {
    843              /* Disable the TIM Main Output */
    844              TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
   \                     ??TIM_CtrlPWMOutputs_0: (+1)
   \       0x14   0xF8B0 0x1044      LDRH     R1,[R0, #+68]
   \       0x18   0x0449             LSLS     R1,R1,#+17
   \       0x1A   0x0C49             LSRS     R1,R1,#+17
   \       0x1C   0xF8A0 0x1044      STRH     R1,[R0, #+68]
    845            }  
    846          }
   \                     ??TIM_CtrlPWMOutputs_1: (+1)
   \       0x20   0x4770             BX       LR
    847          
    848          /**
    849            * @brief  Enables or disables the specified TIM interrupts.
    850            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    851            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
    852            *   This parameter can be any combination of the following values:
    853            *     @arg TIM_IT_Update: TIM update Interrupt source
    854            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    855            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    856            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    857            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    858            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
    859            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
    860            *     @arg TIM_IT_Break: TIM Break Interrupt source
    861            * @note 
    862            *   - TIM6 and TIM7 can only generate an update interrupt.
    863            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
    864            *      TIM_IT_CC2 or TIM_IT_Trigger. 
    865            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
    866            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
    867            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
    868            * @param  NewState: new state of the TIM interrupts.
    869            *   This parameter can be: ENABLE or DISABLE.
    870            * @retval None
    871            */

   \                                 In section .text, align 2, keep-with-next
    872          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
    873          {  
    874            /* Check the parameters */
    875            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
    876            //assert_param(IS_TIM_IT(TIM_IT));
    877            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    878            
    879            if (NewState != DISABLE)
   \                     TIM_ITConfig: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD003             BEQ.N    ??TIM_ITConfig_0
    880            {
    881              /* Enable the Interrupt sources */
    882              TIMx->DIER |= TIM_IT;
   \        0x6   0x8982             LDRH     R2,[R0, #+12]
   \        0x8   0x4311             ORRS     R1,R1,R2
   \        0xA   0x8181             STRH     R1,[R0, #+12]
   \        0xC   0xE003             B.N      ??TIM_ITConfig_1
    883            }
    884            else
    885            {
    886              /* Disable the Interrupt sources */
    887              TIMx->DIER &= (uint16_t)~TIM_IT;
   \                     ??TIM_ITConfig_0: (+1)
   \        0xE   0x8982             LDRH     R2,[R0, #+12]
   \       0x10   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x14   0x8181             STRH     R1,[R0, #+12]
    888            }
    889          }
   \                     ??TIM_ITConfig_1: (+1)
   \       0x16   0x4770             BX       LR
    890          
    891          /**
    892            * @brief  Configures the TIMx event to be generate by software.
    893            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    894            * @param  TIM_EventSource: specifies the event source.
    895            *   This parameter can be one or more of the following values:	   
    896            *     @arg TIM_EventSource_Update: Timer update Event source
    897            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    898            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    899            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    900            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    901            *     @arg TIM_EventSource_COM: Timer COM event source  
    902            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
    903            *     @arg TIM_EventSource_Break: Timer Break event source
    904            * @note 
    905            *   - TIM6 and TIM7 can only generate an update event. 
    906            *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
    907            * @retval None
    908            */

   \                                 In section .text, align 2, keep-with-next
    909          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
    910          { 
    911            /* Check the parameters */
    912            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
    913            //assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    914            
    915            /* Set the event sources */
    916            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent: (+1)
   \        0x0   0x8281             STRH     R1,[R0, #+20]
    917          }
   \        0x2   0x4770             BX       LR
    918          
    919          /**
    920            * @brief  Configures the TIMx's DMA interface.
    921            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
    922            *   the TIM peripheral.
    923            * @param  TIM_DMABase: DMA Base address.
    924            *   This parameter can be one of the following values:
    925            *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    926            *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    927            *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    928            *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    929            *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    930            *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    931            *          TIM_DMABase_DCR.
    932            * @param  TIM_DMABurstLength: DMA Burst length.
    933            *   This parameter can be one value between:
    934            *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
    935            * @retval None
    936            */

   \                                 In section .text, align 2, keep-with-next
    937          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
    938          {
    939            /* Check the parameters */
    940            //assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    941            //assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    942            //assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    943            /* Set the DMA Base and the DMA Burst Length */
    944            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     TIM_DMAConfig: (+1)
   \        0x0   0x4311             ORRS     R1,R2,R1
   \        0x2   0xF8A0 0x1048      STRH     R1,[R0, #+72]
    945          }
   \        0x6   0x4770             BX       LR
    946          
    947          /**
    948            * @brief  Enables or disables the TIMx's DMA Requests.
    949            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17 
    950            *   to select the TIM peripheral. 
    951            * @param  TIM_DMASource: specifies the DMA Request sources.
    952            *   This parameter can be any combination of the following values:
    953            *     @arg TIM_DMA_Update: TIM update Interrupt source
    954            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    955            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    956            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    957            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    958            *     @arg TIM_DMA_COM: TIM Commutation DMA source
    959            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
    960            * @param  NewState: new state of the DMA Request sources.
    961            *   This parameter can be: ENABLE or DISABLE.
    962            * @retval None
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
    965          { 
    966            /* Check the parameters */
    967            //assert_param(IS_TIM_LIST9_PERIPH(TIMx));
    968            //assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    969            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    970            
    971            if (NewState != DISABLE)
   \                     TIM_DMACmd: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD003             BEQ.N    ??TIM_DMACmd_0
    972            {
    973              /* Enable the DMA sources */
    974              TIMx->DIER |= TIM_DMASource; 
   \        0x6   0x8982             LDRH     R2,[R0, #+12]
   \        0x8   0x4311             ORRS     R1,R1,R2
   \        0xA   0x8181             STRH     R1,[R0, #+12]
   \        0xC   0xE003             B.N      ??TIM_DMACmd_1
    975            }
    976            else
    977            {
    978              /* Disable the DMA sources */
    979              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   \                     ??TIM_DMACmd_0: (+1)
   \        0xE   0x8982             LDRH     R2,[R0, #+12]
   \       0x10   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x14   0x8181             STRH     R1,[R0, #+12]
    980            }
    981          }
   \                     ??TIM_DMACmd_1: (+1)
   \       0x16   0x4770             BX       LR
    982          
    983          /**
    984            * @brief  Configures the TIMx internal Clock
    985            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
    986            *         to select the TIM peripheral.
    987            * @retval None
    988            */

   \                                 In section .text, align 2, keep-with-next
    989          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    990          {
    991            /* Check the parameters */
    992            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    993            /* Disable slave mode to clock the prescaler directly with the internal clock */
    994            TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \                     TIM_InternalClockConfig: (+1)
   \        0x0   0x8902             LDRH     R2,[R0, #+8]
   \        0x2   0xF64F 0x71F8      MOVW     R1,#+65528
   \        0x6   0x400A             ANDS     R2,R1,R2
   \        0x8   0x8102             STRH     R2,[R0, #+8]
    995          }
   \        0xA   0x4770             BX       LR
    996          
    997          /**
    998            * @brief  Configures the TIMx Internal Trigger as External Clock
    999            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
   1000            * @param  TIM_ITRSource: Trigger source.
   1001            *   This parameter can be one of the following values:
   1002            * @param  TIM_TS_ITR0: Internal Trigger 0
   1003            * @param  TIM_TS_ITR1: Internal Trigger 1
   1004            * @param  TIM_TS_ITR2: Internal Trigger 2
   1005            * @param  TIM_TS_ITR3: Internal Trigger 3
   1006            * @retval None
   1007            */

   \                                 In section .text, align 2, keep-with-next
   1008          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   1009          {
   \                     TIM_ITRxExternalClockConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1010            /* Check the parameters */
   1011            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1012            //assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1013            /* Select the Internal Trigger */
   1014            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \        0x4   0xB289             UXTH     R1,R1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       TIM_SelectInputTrigger
   1015            /* Select the External clock mode1 */
   1016            TIMx->SMCR |= TIM_SlaveMode_External1;
   \        0xC   0x8920             LDRH     R0,[R4, #+8]
   \        0xE   0xF050 0x0007      ORRS     R0,R0,#0x7
   \       0x12   0x8120             STRH     R0,[R4, #+8]
   1017          }
   \       0x14   0xBD10             POP      {R4,PC}
   1018          
   1019          /**
   1020            * @brief  Configures the TIMx Trigger as External Clock
   1021            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
   1022            * @param  TIM_TIxExternalCLKSource: Trigger source.
   1023            *   This parameter can be one of the following values:
   1024            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1025            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1026            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1027            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   1028            *   This parameter can be one of the following values:
   1029            *     @arg TIM_ICPolarity_Rising
   1030            *     @arg TIM_ICPolarity_Falling
   1031            * @param  ICFilter : specifies the filter value.
   1032            *   This parameter must be a value between 0x0 and 0xF.
   1033            * @retval None
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   1036                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   1037          {
   \                     TIM_TIxExternalClockConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0011             MOVS     R1,R2
   1038            /* Check the parameters */
   1039            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1040            //assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
   1041            //assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1042            //assert_param(IS_TIM_IC_FILTER(ICFilter));
   1043            /* Configure the Timer Input Clock Source */
   1044            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x2860             CMP      R0,#+96
   \        0xE   0xD106             BNE.N    ??TIM_TIxExternalClockConfig_0
   1045            {
   1046              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \       0x10   0xB29B             UXTH     R3,R3
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0xB289             UXTH     R1,R1
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       TI2_Config
   \       0x1C   0xE005             B.N      ??TIM_TIxExternalClockConfig_1
   1047            }
   1048            else
   1049            {
   1050              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0: (+1)
   \       0x1E   0xB29B             UXTH     R3,R3
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0xB289             UXTH     R1,R1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       TI1_Config
   1051            }
   1052            /* Select the Trigger source */
   1053            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_1: (+1)
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0xB289             UXTH     R1,R1
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       TIM_SelectInputTrigger
   1054            /* Select the External clock mode1 */
   1055            TIMx->SMCR |= TIM_SlaveMode_External1;
   \       0x34   0x8920             LDRH     R0,[R4, #+8]
   \       0x36   0xF050 0x0007      ORRS     R0,R0,#0x7
   \       0x3A   0x8120             STRH     R0,[R4, #+8]
   1056          }
   \       0x3C   0xBD31             POP      {R0,R4,R5,PC}
   1057          
   1058          /**
   1059            * @brief  Configures the External clock Mode1
   1060            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1061            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1062            *   This parameter can be one of the following values:
   1063            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1064            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1065            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1066            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1067            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1068            *   This parameter can be one of the following values:
   1069            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1070            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1071            * @param  ExtTRGFilter: External Trigger Filter.
   1072            *   This parameter must be a value between 0x00 and 0x0F
   1073            * @retval None
   1074            */

   \                                 In section .text, align 2, keep-with-next
   1075          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1076                                       uint16_t ExtTRGFilter)
   1077          {
   \                     TIM_ETRClockMode1Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1078            uint16_t tmpsmcr = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   1079            /* Check the parameters */
   1080            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1081            //assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1082            //assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1083            //assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1084            /* Configure the ETR Clock source */
   1085            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \        0x6   0xB29B             UXTH     R3,R3
   \        0x8   0xB292             UXTH     R2,R2
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       TIM_ETRConfig
   1086            
   1087            /* Get the TIMx SMCR register value */
   1088            tmpsmcr = TIMx->SMCR;
   \       0x12   0x8921             LDRH     R1,[R4, #+8]
   1089            /* Reset the SMS Bits */
   1090            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \       0x14   0xF64F 0x70F8      MOVW     R0,#+65528
   \       0x18   0x4001             ANDS     R1,R0,R1
   1091            /* Select the External clock mode1 */
   1092            tmpsmcr |= TIM_SlaveMode_External1;
   \       0x1A   0xF051 0x0107      ORRS     R1,R1,#0x7
   1093            /* Select the Trigger selection : ETRF */
   1094            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   \       0x1E   0xF64F 0x708F      MOVW     R0,#+65423
   \       0x22   0x4001             ANDS     R1,R0,R1
   1095            tmpsmcr |= TIM_TS_ETRF;
   \       0x24   0xF051 0x0170      ORRS     R1,R1,#0x70
   1096            /* Write to TIMx SMCR */
   1097            TIMx->SMCR = tmpsmcr;
   \       0x28   0x8121             STRH     R1,[R4, #+8]
   1098          }
   \       0x2A   0xBD10             POP      {R4,PC}
   1099          
   1100          /**
   1101            * @brief  Configures the External clock Mode2
   1102            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1103            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1104            *   This parameter can be one of the following values:
   1105            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1106            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1107            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1108            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1109            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1110            *   This parameter can be one of the following values:
   1111            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1112            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1113            * @param  ExtTRGFilter: External Trigger Filter.
   1114            *   This parameter must be a value between 0x00 and 0x0F
   1115            * @retval None
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   1118                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   1119          {
   \                     TIM_ETRClockMode2Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1120            /* Check the parameters */
   1121            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1122            //assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1123            //assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1124            //assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1125            /* Configure the ETR Clock source */
   1126            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0xB292             UXTH     R2,R2
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       TIM_ETRConfig
   1127            /* Enable the External clock mode2 */
   1128            TIMx->SMCR |= TIM_SMCR_ECE;
   \       0x10   0x8920             LDRH     R0,[R4, #+8]
   \       0x12   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x16   0x8120             STRH     R0,[R4, #+8]
   1129          }
   \       0x18   0xBD10             POP      {R4,PC}
   1130          
   1131          /**
   1132            * @brief  Configures the TIMx External Trigger (ETR).
   1133            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1134            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1135            *   This parameter can be one of the following values:
   1136            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1137            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1138            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1139            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1140            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1141            *   This parameter can be one of the following values:
   1142            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1143            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1144            * @param  ExtTRGFilter: External Trigger Filter.
   1145            *   This parameter must be a value between 0x00 and 0x0F
   1146            * @retval None
   1147            */

   \                                 In section .text, align 2, keep-with-next
   1148          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1149                             uint16_t ExtTRGFilter)
   1150          {
   \                     TIM_ETRConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1151            uint16_t tmpsmcr = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   1152            /* Check the parameters */
   1153            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1154            //assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1155            //assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1156            //assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1157            tmpsmcr = TIMx->SMCR;
   \        0x4   0x8904             LDRH     R4,[R0, #+8]
   1158            /* Reset the ETR Bits */
   1159            tmpsmcr &= SMCR_ETR_Mask;
   \        0x6   0xF004 0x04FF      AND      R4,R4,#0xFF
   1160            /* Set the Prescaler, the Filter value and the Polarity */
   1161            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   \        0xA   0x4321             ORRS     R1,R1,R4
   \        0xC   0x4311             ORRS     R1,R2,R1
   \        0xE   0xEA51 0x2103      ORRS     R1,R1,R3, LSL #+8
   1162            /* Write to TIMx SMCR */
   1163            TIMx->SMCR = tmpsmcr;
   \       0x12   0x8101             STRH     R1,[R0, #+8]
   1164          }
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR
   1165          
   1166          /**
   1167            * @brief  Configures the TIMx Prescaler.
   1168            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   1169            * @param  Prescaler: specifies the Prescaler Register value
   1170            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1171            *   This parameter can be one of the following values:
   1172            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
   1173            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
   1174            * @retval None
   1175            */

   \                                 In section .text, align 2, keep-with-next
   1176          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
   1177          {
   1178            /* Check the parameters */
   1179            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1180            //assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1181            /* Set the Prescaler value */
   1182            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig: (+1)
   \        0x0   0x8501             STRH     R1,[R0, #+40]
   1183            /* Set or reset the UG Bit */
   1184            TIMx->EGR = TIM_PSCReloadMode;
   \        0x2   0x8282             STRH     R2,[R0, #+20]
   1185          }
   \        0x4   0x4770             BX       LR
   1186          
   1187          /**
   1188            * @brief  Specifies the TIMx Counter Mode to be used.
   1189            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1190            * @param  TIM_CounterMode: specifies the Counter Mode to be used
   1191            *   This parameter can be one of the following values:
   1192            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
   1193            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
   1194            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1195            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1196            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1197            * @retval None
   1198            */

   \                                 In section .text, align 2, keep-with-next
   1199          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
   1200          {
   1201            uint16_t tmpcr1 = 0;
   \                     TIM_CounterModeConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1202            /* Check the parameters */
   1203            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1204            //assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1205            tmpcr1 = TIMx->CR1;
   \        0x2   0x8803             LDRH     R3,[R0, #+0]
   1206            /* Reset the CMS and DIR Bits */
   1207            tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   \        0x4   0xF64F 0x728F      MOVW     R2,#+65423
   \        0x8   0x4013             ANDS     R3,R2,R3
   1208            /* Set the Counter Mode */
   1209            tmpcr1 |= TIM_CounterMode;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1210            /* Write to TIMx CR1 register */
   1211            TIMx->CR1 = tmpcr1;
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   1212          }
   \        0xE   0x4770             BX       LR
   1213          
   1214          /**
   1215            * @brief  Selects the Input Trigger source
   1216            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1217            * @param  TIM_InputTriggerSource: The Input Trigger source.
   1218            *   This parameter can be one of the following values:
   1219            *     @arg TIM_TS_ITR0: Internal Trigger 0
   1220            *     @arg TIM_TS_ITR1: Internal Trigger 1
   1221            *     @arg TIM_TS_ITR2: Internal Trigger 2
   1222            *     @arg TIM_TS_ITR3: Internal Trigger 3
   1223            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   1224            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   1225            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   1226            *     @arg TIM_TS_ETRF: External Trigger input
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   1230          {
   1231            uint16_t tmpsmcr = 0;
   \                     TIM_SelectInputTrigger: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1232            /* Check the parameters */
   1233            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1234            //assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1235            /* Get the TIMx SMCR register value */
   1236            tmpsmcr = TIMx->SMCR;
   \        0x2   0x8903             LDRH     R3,[R0, #+8]
   1237            /* Reset the TS Bits */
   1238            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   \        0x4   0xF64F 0x728F      MOVW     R2,#+65423
   \        0x8   0x4013             ANDS     R3,R2,R3
   1239            /* Set the Input Trigger source */
   1240            tmpsmcr |= TIM_InputTriggerSource;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1241            /* Write to TIMx SMCR */
   1242            TIMx->SMCR = tmpsmcr;
   \        0xC   0x8101             STRH     R1,[R0, #+8]
   1243          }
   \        0xE   0x4770             BX       LR
   1244          
   1245          /**
   1246            * @brief  Configures the TIMx Encoder Interface.
   1247            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1248            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1249            *   This parameter can be one of the following values:
   1250            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   1251            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   1252            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   1253            *                                on the level of the other input.
   1254            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   1255            *   This parameter can be one of the following values:
   1256            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1257            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1258            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   1259            *   This parameter can be one of the following values:
   1260            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1261            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1262            * @retval None
   1263            */

   \                                 In section .text, align 2, keep-with-next
   1264          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   1265                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   1266          {
   \                     TIM_EncoderInterfaceConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   1267            uint16_t tmpsmcr = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   1268            uint16_t tmpccmr1 = 0;
   \        0x4   0x2400             MOVS     R4,#+0
   1269            uint16_t tmpccer = 0;
   \        0x6   0x2400             MOVS     R4,#+0
   1270              
   1271            /* Check the parameters */
   1272            //assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1273            //assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1274            //assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1275            //assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1276          
   1277            /* Get the TIMx SMCR register value */
   1278            tmpsmcr = TIMx->SMCR;
   \        0x8   0x8905             LDRH     R5,[R0, #+8]
   1279            
   1280            /* Get the TIMx CCMR1 register value */
   1281            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x8B06             LDRH     R6,[R0, #+24]
   1282            
   1283            /* Get the TIMx CCER register value */
   1284            tmpccer = TIMx->CCER;
   \        0xC   0x8C07             LDRH     R7,[R0, #+32]
   1285            
   1286            /* Set the encoder Mode */
   1287            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \        0xE   0xF64F 0x74F8      MOVW     R4,#+65528
   \       0x12   0x4025             ANDS     R5,R4,R5
   1288            tmpsmcr |= TIM_EncoderMode;
   \       0x14   0x4329             ORRS     R1,R1,R5
   1289            
   1290            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1291            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
   \       0x16   0xF64F 0x44FC      MOVW     R4,#+64764
   \       0x1A   0x4026             ANDS     R6,R4,R6
   1292            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   \       0x1C   0xF240 0x1401      MOVW     R4,#+257
   \       0x20   0x4326             ORRS     R6,R4,R6
   1293            
   1294            /* Set the TI1 and the TI2 Polarities */
   1295            tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
   \       0x22   0xF64F 0x74DD      MOVW     R4,#+65501
   \       0x26   0x4027             ANDS     R7,R4,R7
   1296            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   \       0x28   0x433A             ORRS     R2,R2,R7
   \       0x2A   0xEA52 0x1203      ORRS     R2,R2,R3, LSL #+4
   1297            
   1298            /* Write to TIMx SMCR */
   1299            TIMx->SMCR = tmpsmcr;
   \       0x2E   0x8101             STRH     R1,[R0, #+8]
   1300            /* Write to TIMx CCMR1 */
   1301            TIMx->CCMR1 = tmpccmr1;
   \       0x30   0x8306             STRH     R6,[R0, #+24]
   1302            /* Write to TIMx CCER */
   1303            TIMx->CCER = tmpccer;
   \       0x32   0x8402             STRH     R2,[R0, #+32]
   1304          }
   \       0x34   0xBCF0             POP      {R4-R7}
   \       0x36   0x4770             BX       LR
   1305          
   1306          /**
   1307            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1308            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1309            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1310            *   This parameter can be one of the following values:
   1311            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1312            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1313            * @retval None
   1314            */

   \                                 In section .text, align 2, keep-with-next
   1315          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1316          {
   1317            uint16_t tmpccmr1 = 0;
   \                     TIM_ForcedOC1Config: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1318            /* Check the parameters */
   1319            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1320            //assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1321            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1322            /* Reset the OC1M Bits */
   1323            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
   \        0x4   0xF64F 0x728F      MOVW     R2,#+65423
   \        0x8   0x4013             ANDS     R3,R2,R3
   1324            /* Configure The Forced output Mode */
   1325            tmpccmr1 |= TIM_ForcedAction;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1326            /* Write to TIMx CCMR1 register */
   1327            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x8301             STRH     R1,[R0, #+24]
   1328          }
   \        0xE   0x4770             BX       LR
   1329          
   1330          /**
   1331            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1332            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1333            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1334            *   This parameter can be one of the following values:
   1335            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1336            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1337            * @retval None
   1338            */

   \                                 In section .text, align 2, keep-with-next
   1339          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1340          {
   1341            uint16_t tmpccmr1 = 0;
   \                     TIM_ForcedOC2Config: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1342            /* Check the parameters */
   1343            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1344            //assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1345            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1346            /* Reset the OC2M Bits */
   1347            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
   \        0x4   0xF648 0x72FF      MOVW     R2,#+36863
   \        0x8   0x4013             ANDS     R3,R2,R3
   1348            /* Configure The Forced output Mode */
   1349            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1350            /* Write to TIMx CCMR1 register */
   1351            TIMx->CCMR1 = tmpccmr1;
   \        0xE   0x8303             STRH     R3,[R0, #+24]
   1352          }
   \       0x10   0x4770             BX       LR
   1353          
   1354          /**
   1355            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1356            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1357            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1358            *   This parameter can be one of the following values:
   1359            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1360            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1361            * @retval None
   1362            */

   \                                 In section .text, align 2, keep-with-next
   1363          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1364          {
   1365            uint16_t tmpccmr2 = 0;
   \                     TIM_ForcedOC3Config: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1366            /* Check the parameters */
   1367            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1368            //assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1369            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1370            /* Reset the OC1M Bits */
   1371            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
   \        0x4   0xF64F 0x728F      MOVW     R2,#+65423
   \        0x8   0x4013             ANDS     R3,R2,R3
   1372            /* Configure The Forced output Mode */
   1373            tmpccmr2 |= TIM_ForcedAction;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1374            /* Write to TIMx CCMR2 register */
   1375            TIMx->CCMR2 = tmpccmr2;
   \        0xC   0x8381             STRH     R1,[R0, #+28]
   1376          }
   \        0xE   0x4770             BX       LR
   1377          
   1378          /**
   1379            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1380            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1381            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1382            *   This parameter can be one of the following values:
   1383            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1384            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1385            * @retval None
   1386            */

   \                                 In section .text, align 2, keep-with-next
   1387          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1388          {
   1389            uint16_t tmpccmr2 = 0;
   \                     TIM_ForcedOC4Config: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1390            /* Check the parameters */
   1391            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1392            //assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1393            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1394            /* Reset the OC2M Bits */
   1395            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
   \        0x4   0xF648 0x72FF      MOVW     R2,#+36863
   \        0x8   0x4013             ANDS     R3,R2,R3
   1396            /* Configure The Forced output Mode */
   1397            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1398            /* Write to TIMx CCMR2 register */
   1399            TIMx->CCMR2 = tmpccmr2;
   \        0xE   0x8383             STRH     R3,[R0, #+28]
   1400          }
   \       0x10   0x4770             BX       LR
   1401          
   1402          /**
   1403            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
   1404            * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
   1405            * @param  NewState: new state of the TIMx peripheral Preload register
   1406            *   This parameter can be: ENABLE or DISABLE.
   1407            * @retval None
   1408            */

   \                                 In section .text, align 2, keep-with-next
   1409          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1410          {
   1411            /* Check the parameters */
   1412            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1413            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1414            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_ARRPreloadConfig_0
   1415            {
   1416              /* Set the ARR Preload Bit */
   1417              TIMx->CR1 |= TIM_CR1_ARPE;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF051 0x0180      ORRS     R1,R1,#0x80
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??TIM_ARRPreloadConfig_1
   1418            }
   1419            else
   1420            {
   1421              /* Reset the ARR Preload Bit */
   1422              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
   \                     ??TIM_ARRPreloadConfig_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64F 0x717F      MOVW     R1,#+65407
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
   1423            }
   1424          }
   \                     ??TIM_ARRPreloadConfig_1: (+1)
   \       0x1A   0x4770             BX       LR
   1425          
   1426          /**
   1427            * @brief  Selects the TIM peripheral Commutation event.
   1428            * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
   1429            * @param  NewState: new state of the Commutation event.
   1430            *   This parameter can be: ENABLE or DISABLE.
   1431            * @retval None
   1432            */

   \                                 In section .text, align 2, keep-with-next
   1433          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1434          {
   1435            /* Check the parameters */
   1436            //assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1437            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1438            if (NewState != DISABLE)
   \                     TIM_SelectCOM: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_SelectCOM_0
   1439            {
   1440              /* Set the COM Bit */
   1441              TIMx->CR2 |= TIM_CR2_CCUS;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??TIM_SelectCOM_1
   1442            }
   1443            else
   1444            {
   1445              /* Reset the COM Bit */
   1446              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
   \                     ??TIM_SelectCOM_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x71FB      MOVW     R1,#+65531
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
   1447            }
   1448          }
   \                     ??TIM_SelectCOM_1: (+1)
   \       0x1A   0x4770             BX       LR
   1449          
   1450          /**
   1451            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   1452            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
   1453            *         the TIM peripheral.
   1454            * @param  NewState: new state of the Capture Compare DMA source
   1455            *   This parameter can be: ENABLE or DISABLE.
   1456            * @retval None
   1457            */

   \                                 In section .text, align 2, keep-with-next
   1458          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1459          {
   1460            /* Check the parameters */
   1461            //assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1462            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1463            if (NewState != DISABLE)
   \                     TIM_SelectCCDMA: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_SelectCCDMA_0
   1464            {
   1465              /* Set the CCDS Bit */
   1466              TIMx->CR2 |= TIM_CR2_CCDS;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0108      ORRS     R1,R1,#0x8
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??TIM_SelectCCDMA_1
   1467            }
   1468            else
   1469            {
   1470              /* Reset the CCDS Bit */
   1471              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
   \                     ??TIM_SelectCCDMA_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x71F7      MOVW     R1,#+65527
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
   1472            }
   1473          }
   \                     ??TIM_SelectCCDMA_1: (+1)
   \       0x1A   0x4770             BX       LR
   1474          
   1475          /**
   1476            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   1477            * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15 
   1478            *         to select the TIMx peripheral
   1479            * @param  NewState: new state of the Capture Compare Preload Control bit
   1480            *   This parameter can be: ENABLE or DISABLE.
   1481            * @retval None
   1482            */

   \                                 In section .text, align 2, keep-with-next
   1483          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1484          { 
   1485            /* Check the parameters */
   1486            //assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1487            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1488            if (NewState != DISABLE)
   \                     TIM_CCPreloadControl: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_CCPreloadControl_0
   1489            {
   1490              /* Set the CCPC Bit */
   1491              TIMx->CR2 |= TIM_CR2_CCPC;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??TIM_CCPreloadControl_1
   1492            }
   1493            else
   1494            {
   1495              /* Reset the CCPC Bit */
   1496              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
   \                     ??TIM_CCPreloadControl_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
   1497            }
   1498          }
   \                     ??TIM_CCPreloadControl_1: (+1)
   \       0x1A   0x4770             BX       LR
   1499          
   1500          /**
   1501            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1502            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1503            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1504            *   This parameter can be one of the following values:
   1505            *     @arg TIM_OCPreload_Enable
   1506            *     @arg TIM_OCPreload_Disable
   1507            * @retval None
   1508            */

   \                                 In section .text, align 2, keep-with-next
   1509          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1510          {
   1511            uint16_t tmpccmr1 = 0;
   \                     TIM_OC1PreloadConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1512            /* Check the parameters */
   1513            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1514            //assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1515            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1516            /* Reset the OC1PE Bit */
   1517            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
   \        0x4   0xF64F 0x72F7      MOVW     R2,#+65527
   \        0x8   0x4013             ANDS     R3,R2,R3
   1518            /* Enable or Disable the Output Compare Preload feature */
   1519            tmpccmr1 |= TIM_OCPreload;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1520            /* Write to TIMx CCMR1 register */
   1521            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x8301             STRH     R1,[R0, #+24]
   1522          }
   \        0xE   0x4770             BX       LR
   1523          
   1524          /**
   1525            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1526            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1527            *         the TIM peripheral.
   1528            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1529            *   This parameter can be one of the following values:
   1530            *     @arg TIM_OCPreload_Enable
   1531            *     @arg TIM_OCPreload_Disable
   1532            * @retval None
   1533            */

   \                                 In section .text, align 2, keep-with-next
   1534          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1535          {
   1536            uint16_t tmpccmr1 = 0;
   \                     TIM_OC2PreloadConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1537            /* Check the parameters */
   1538            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1539            //assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1540            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1541            /* Reset the OC2PE Bit */
   1542            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
   \        0x4   0xF24F 0x72FF      MOVW     R2,#+63487
   \        0x8   0x4013             ANDS     R3,R2,R3
   1543            /* Enable or Disable the Output Compare Preload feature */
   1544            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1545            /* Write to TIMx CCMR1 register */
   1546            TIMx->CCMR1 = tmpccmr1;
   \        0xE   0x8303             STRH     R3,[R0, #+24]
   1547          }
   \       0x10   0x4770             BX       LR
   1548          
   1549          /**
   1550            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1551            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1552            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1553            *   This parameter can be one of the following values:
   1554            *     @arg TIM_OCPreload_Enable
   1555            *     @arg TIM_OCPreload_Disable
   1556            * @retval None
   1557            */

   \                                 In section .text, align 2, keep-with-next
   1558          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1559          {
   1560            uint16_t tmpccmr2 = 0;
   \                     TIM_OC3PreloadConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1561            /* Check the parameters */
   1562            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1563            //assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1564            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1565            /* Reset the OC3PE Bit */
   1566            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
   \        0x4   0xF64F 0x72F7      MOVW     R2,#+65527
   \        0x8   0x4013             ANDS     R3,R2,R3
   1567            /* Enable or Disable the Output Compare Preload feature */
   1568            tmpccmr2 |= TIM_OCPreload;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1569            /* Write to TIMx CCMR2 register */
   1570            TIMx->CCMR2 = tmpccmr2;
   \        0xC   0x8381             STRH     R1,[R0, #+28]
   1571          }
   \        0xE   0x4770             BX       LR
   1572          
   1573          /**
   1574            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1575            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1576            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1577            *   This parameter can be one of the following values:
   1578            *     @arg TIM_OCPreload_Enable
   1579            *     @arg TIM_OCPreload_Disable
   1580            * @retval None
   1581            */

   \                                 In section .text, align 2, keep-with-next
   1582          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1583          {
   1584            uint16_t tmpccmr2 = 0;
   \                     TIM_OC4PreloadConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1585            /* Check the parameters */
   1586            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1587            //assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1588            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1589            /* Reset the OC4PE Bit */
   1590            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
   \        0x4   0xF24F 0x72FF      MOVW     R2,#+63487
   \        0x8   0x4013             ANDS     R3,R2,R3
   1591            /* Enable or Disable the Output Compare Preload feature */
   1592            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1593            /* Write to TIMx CCMR2 register */
   1594            TIMx->CCMR2 = tmpccmr2;
   \        0xE   0x8383             STRH     R3,[R0, #+28]
   1595          }
   \       0x10   0x4770             BX       LR
   1596          
   1597          /**
   1598            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1599            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1600            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1601            *   This parameter can be one of the following values:
   1602            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1603            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1604            * @retval None
   1605            */

   \                                 In section .text, align 2, keep-with-next
   1606          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1607          {
   1608            uint16_t tmpccmr1 = 0;
   \                     TIM_OC1FastConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1609            /* Check the parameters */
   1610            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1611            //assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1612            /* Get the TIMx CCMR1 register value */
   1613            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1614            /* Reset the OC1FE Bit */
   1615            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
   \        0x4   0xF64F 0x72FB      MOVW     R2,#+65531
   \        0x8   0x4013             ANDS     R3,R2,R3
   1616            /* Enable or Disable the Output Compare Fast Bit */
   1617            tmpccmr1 |= TIM_OCFast;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1618            /* Write to TIMx CCMR1 */
   1619            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x8301             STRH     R1,[R0, #+24]
   1620          }
   \        0xE   0x4770             BX       LR
   1621          
   1622          /**
   1623            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1624            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1625            *         the TIM peripheral.
   1626            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1627            *   This parameter can be one of the following values:
   1628            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1629            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1630            * @retval None
   1631            */

   \                                 In section .text, align 2, keep-with-next
   1632          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1633          {
   1634            uint16_t tmpccmr1 = 0;
   \                     TIM_OC2FastConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1635            /* Check the parameters */
   1636            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1637            //assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1638            /* Get the TIMx CCMR1 register value */
   1639            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1640            /* Reset the OC2FE Bit */
   1641            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
   \        0x4   0xF64F 0x32FF      MOVW     R2,#+64511
   \        0x8   0x4013             ANDS     R3,R2,R3
   1642            /* Enable or Disable the Output Compare Fast Bit */
   1643            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1644            /* Write to TIMx CCMR1 */
   1645            TIMx->CCMR1 = tmpccmr1;
   \        0xE   0x8303             STRH     R3,[R0, #+24]
   1646          }
   \       0x10   0x4770             BX       LR
   1647          
   1648          /**
   1649            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1650            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1651            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1652            *   This parameter can be one of the following values:
   1653            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1654            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1655            * @retval None
   1656            */

   \                                 In section .text, align 2, keep-with-next
   1657          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1658          {
   1659            uint16_t tmpccmr2 = 0;
   \                     TIM_OC3FastConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1660            /* Check the parameters */
   1661            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1662            //assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1663            /* Get the TIMx CCMR2 register value */
   1664            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1665            /* Reset the OC3FE Bit */
   1666            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
   \        0x4   0xF64F 0x72FB      MOVW     R2,#+65531
   \        0x8   0x4013             ANDS     R3,R2,R3
   1667            /* Enable or Disable the Output Compare Fast Bit */
   1668            tmpccmr2 |= TIM_OCFast;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1669            /* Write to TIMx CCMR2 */
   1670            TIMx->CCMR2 = tmpccmr2;
   \        0xC   0x8381             STRH     R1,[R0, #+28]
   1671          }
   \        0xE   0x4770             BX       LR
   1672          
   1673          /**
   1674            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1675            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1676            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1677            *   This parameter can be one of the following values:
   1678            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1679            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1680            * @retval None
   1681            */

   \                                 In section .text, align 2, keep-with-next
   1682          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1683          {
   1684            uint16_t tmpccmr2 = 0;
   \                     TIM_OC4FastConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1685            /* Check the parameters */
   1686            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1687            //assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1688            /* Get the TIMx CCMR2 register value */
   1689            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1690            /* Reset the OC4FE Bit */
   1691            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
   \        0x4   0xF64F 0x32FF      MOVW     R2,#+64511
   \        0x8   0x4013             ANDS     R3,R2,R3
   1692            /* Enable or Disable the Output Compare Fast Bit */
   1693            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1694            /* Write to TIMx CCMR2 */
   1695            TIMx->CCMR2 = tmpccmr2;
   \        0xE   0x8383             STRH     R3,[R0, #+28]
   1696          }
   \       0x10   0x4770             BX       LR
   1697          
   1698          /**
   1699            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1700            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1701            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1702            *   This parameter can be one of the following values:
   1703            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1704            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1705            * @retval None
   1706            */

   \                                 In section .text, align 2, keep-with-next
   1707          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1708          {
   1709            uint16_t tmpccmr1 = 0;
   \                     TIM_ClearOC1Ref: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1710            /* Check the parameters */
   1711            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1712            //assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1713          
   1714            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B03             LDRH     R3,[R0, #+24]
   1715          
   1716            /* Reset the OC1CE Bit */
   1717            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
   \        0x4   0xF64F 0x727F      MOVW     R2,#+65407
   \        0x8   0x4013             ANDS     R3,R2,R3
   1718            /* Enable or Disable the Output Compare Clear Bit */
   1719            tmpccmr1 |= TIM_OCClear;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1720            /* Write to TIMx CCMR1 register */
   1721            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x8301             STRH     R1,[R0, #+24]
   1722          }
   \        0xE   0x4770             BX       LR
   1723          
   1724          /**
   1725            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1726            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1727            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1728            *   This parameter can be one of the following values:
   1729            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1730            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1731            * @retval None
   1732            */

   \                                 In section .text, align 2, keep-with-next
   1733          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1734          {
   1735            uint16_t tmpccmr1 = 0;
   \                     TIM_ClearOC2Ref: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1736            /* Check the parameters */
   1737            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1738            //assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1739            tmpccmr1 = TIMx->CCMR1;
   \        0x2   0x8B02             LDRH     R2,[R0, #+24]
   1740            /* Reset the OC2CE Bit */
   1741            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
   \        0x4   0x0452             LSLS     R2,R2,#+17
   \        0x6   0x0C52             LSRS     R2,R2,#+17
   1742            /* Enable or Disable the Output Compare Clear Bit */
   1743            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   \        0x8   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1744            /* Write to TIMx CCMR1 register */
   1745            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x8302             STRH     R2,[R0, #+24]
   1746          }
   \        0xE   0x4770             BX       LR
   1747          
   1748          /**
   1749            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1750            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1751            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1752            *   This parameter can be one of the following values:
   1753            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1754            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1755            * @retval None
   1756            */

   \                                 In section .text, align 2, keep-with-next
   1757          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1758          {
   1759            uint16_t tmpccmr2 = 0;
   \                     TIM_ClearOC3Ref: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1760            /* Check the parameters */
   1761            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1762            //assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1763            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B83             LDRH     R3,[R0, #+28]
   1764            /* Reset the OC3CE Bit */
   1765            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
   \        0x4   0xF64F 0x727F      MOVW     R2,#+65407
   \        0x8   0x4013             ANDS     R3,R2,R3
   1766            /* Enable or Disable the Output Compare Clear Bit */
   1767            tmpccmr2 |= TIM_OCClear;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1768            /* Write to TIMx CCMR2 register */
   1769            TIMx->CCMR2 = tmpccmr2;
   \        0xC   0x8381             STRH     R1,[R0, #+28]
   1770          }
   \        0xE   0x4770             BX       LR
   1771          
   1772          /**
   1773            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1774            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1775            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1776            *   This parameter can be one of the following values:
   1777            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1778            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1779            * @retval None
   1780            */

   \                                 In section .text, align 2, keep-with-next
   1781          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1782          {
   1783            uint16_t tmpccmr2 = 0;
   \                     TIM_ClearOC4Ref: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1784            /* Check the parameters */
   1785            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1786            //assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1787            tmpccmr2 = TIMx->CCMR2;
   \        0x2   0x8B82             LDRH     R2,[R0, #+28]
   1788            /* Reset the OC4CE Bit */
   1789            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
   \        0x4   0x0452             LSLS     R2,R2,#+17
   \        0x6   0x0C52             LSRS     R2,R2,#+17
   1790            /* Enable or Disable the Output Compare Clear Bit */
   1791            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   \        0x8   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1792            /* Write to TIMx CCMR2 register */
   1793            TIMx->CCMR2 = tmpccmr2;
   \        0xC   0x8382             STRH     R2,[R0, #+28]
   1794          }
   \        0xE   0x4770             BX       LR
   1795          
   1796          /**
   1797            * @brief  Configures the TIMx channel 1 polarity.
   1798            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1799            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1800            *   This parameter can be one of the following values:
   1801            *     @arg TIM_OCPolarity_High: Output Compare active high
   1802            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1803            * @retval None
   1804            */

   \                                 In section .text, align 2, keep-with-next
   1805          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1806          {
   1807            uint16_t tmpccer = 0;
   \                     TIM_OC1PolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1808            /* Check the parameters */
   1809            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1810            //assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1811            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1812            /* Set or Reset the CC1P Bit */
   1813            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
   \        0x4   0xF64F 0x72FD      MOVW     R2,#+65533
   \        0x8   0x4013             ANDS     R3,R2,R3
   1814            tmpccer |= TIM_OCPolarity;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1815            /* Write to TIMx CCER register */
   1816            TIMx->CCER = tmpccer;
   \        0xC   0x8401             STRH     R1,[R0, #+32]
   1817          }
   \        0xE   0x4770             BX       LR
   1818          
   1819          /**
   1820            * @brief  Configures the TIMx Channel 1N polarity.
   1821            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1822            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1823            *   This parameter can be one of the following values:
   1824            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1825            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1826            * @retval None
   1827            */

   \                                 In section .text, align 2, keep-with-next
   1828          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1829          {
   1830            uint16_t tmpccer = 0;
   \                     TIM_OC1NPolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1831            /* Check the parameters */
   1832            //assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1833            //assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1834             
   1835            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1836            /* Set or Reset the CC1NP Bit */
   1837            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
   \        0x4   0xF64F 0x72F7      MOVW     R2,#+65527
   \        0x8   0x4013             ANDS     R3,R2,R3
   1838            tmpccer |= TIM_OCNPolarity;
   \        0xA   0x4319             ORRS     R1,R1,R3
   1839            /* Write to TIMx CCER register */
   1840            TIMx->CCER = tmpccer;
   \        0xC   0x8401             STRH     R1,[R0, #+32]
   1841          }
   \        0xE   0x4770             BX       LR
   1842          
   1843          /**
   1844            * @brief  Configures the TIMx channel 2 polarity.
   1845            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1846            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1847            *   This parameter can be one of the following values:
   1848            *     @arg TIM_OCPolarity_High: Output Compare active high
   1849            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1850            * @retval None
   1851            */

   \                                 In section .text, align 2, keep-with-next
   1852          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1853          {
   1854            uint16_t tmpccer = 0;
   \                     TIM_OC2PolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1855            /* Check the parameters */
   1856            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1857            //assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1858            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1859            /* Set or Reset the CC2P Bit */
   1860            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
   \        0x4   0xF64F 0x72DF      MOVW     R2,#+65503
   \        0x8   0x4013             ANDS     R3,R2,R3
   1861            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   \        0xA   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   1862            /* Write to TIMx CCER register */
   1863            TIMx->CCER = tmpccer;
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1864          }
   \       0x10   0x4770             BX       LR
   1865          
   1866          /**
   1867            * @brief  Configures the TIMx Channel 2N polarity.
   1868            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1869            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1870            *   This parameter can be one of the following values:
   1871            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1872            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1873            * @retval None
   1874            */

   \                                 In section .text, align 2, keep-with-next
   1875          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1876          {
   1877            uint16_t tmpccer = 0;
   \                     TIM_OC2NPolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1878            /* Check the parameters */
   1879            //assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1880            //assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1881            
   1882            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1883            /* Set or Reset the CC2NP Bit */
   1884            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
   \        0x4   0xF64F 0x727F      MOVW     R2,#+65407
   \        0x8   0x4013             ANDS     R3,R2,R3
   1885            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   \        0xA   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   1886            /* Write to TIMx CCER register */
   1887            TIMx->CCER = tmpccer;
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1888          }
   \       0x10   0x4770             BX       LR
   1889          
   1890          /**
   1891            * @brief  Configures the TIMx channel 3 polarity.
   1892            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1893            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1894            *   This parameter can be one of the following values:
   1895            *     @arg TIM_OCPolarity_High: Output Compare active high
   1896            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1897            * @retval None
   1898            */

   \                                 In section .text, align 2, keep-with-next
   1899          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1900          {
   1901            uint16_t tmpccer = 0;
   \                     TIM_OC3PolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1902            /* Check the parameters */
   1903            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1904            //assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1905            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1906            /* Set or Reset the CC3P Bit */
   1907            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
   \        0x4   0xF64F 0x52FF      MOVW     R2,#+65023
   \        0x8   0x4013             ANDS     R3,R2,R3
   1908            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1909            /* Write to TIMx CCER register */
   1910            TIMx->CCER = tmpccer;
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1911          }
   \       0x10   0x4770             BX       LR
   1912          
   1913          /**
   1914            * @brief  Configures the TIMx Channel 3N polarity.
   1915            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1916            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1917            *   This parameter can be one of the following values:
   1918            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1919            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1920            * @retval None
   1921            */

   \                                 In section .text, align 2, keep-with-next
   1922          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1923          {
   1924            uint16_t tmpccer = 0;
   \                     TIM_OC3NPolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1925           
   1926            /* Check the parameters */
   1927            //assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1928            //assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1929              
   1930            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1931            /* Set or Reset the CC3NP Bit */
   1932            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
   \        0x4   0xF24F 0x72FF      MOVW     R2,#+63487
   \        0x8   0x4013             ANDS     R3,R2,R3
   1933            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   \        0xA   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   1934            /* Write to TIMx CCER register */
   1935            TIMx->CCER = tmpccer;
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1936          }
   \       0x10   0x4770             BX       LR
   1937          
   1938          /**
   1939            * @brief  Configures the TIMx channel 4 polarity.
   1940            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1941            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1942            *   This parameter can be one of the following values:
   1943            *     @arg TIM_OCPolarity_High: Output Compare active high
   1944            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1945            * @retval None
   1946            */

   \                                 In section .text, align 2, keep-with-next
   1947          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1948          {
   1949            uint16_t tmpccer = 0;
   \                     TIM_OC4PolarityConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1950            /* Check the parameters */
   1951            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1952            //assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1953            tmpccer = TIMx->CCER;
   \        0x2   0x8C03             LDRH     R3,[R0, #+32]
   1954            /* Set or Reset the CC4P Bit */
   1955            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
   \        0x4   0xF64D 0x72FF      MOVW     R2,#+57343
   \        0x8   0x4013             ANDS     R3,R2,R3
   1956            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   \        0xA   0xEA53 0x3301      ORRS     R3,R3,R1, LSL #+12
   1957            /* Write to TIMx CCER register */
   1958            TIMx->CCER = tmpccer;
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1959          }
   \       0x10   0x4770             BX       LR
   1960          
   1961          /**
   1962            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1963            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1964            * @param  TIM_Channel: specifies the TIM Channel
   1965            *   This parameter can be one of the following values:
   1966            *     @arg TIM_Channel_1: TIM Channel 1
   1967            *     @arg TIM_Channel_2: TIM Channel 2
   1968            *     @arg TIM_Channel_3: TIM Channel 3
   1969            *     @arg TIM_Channel_4: TIM Channel 4
   1970            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1971            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1972            * @retval None
   1973            */

   \                                 In section .text, align 2, keep-with-next
   1974          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1975          {
   \                     TIM_CCxCmd: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1976            uint16_t tmp = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   1977          
   1978            /* Check the parameters */
   1979            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1980            //assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1981            //assert_param(IS_TIM_CCX(TIM_CCx));
   1982          
   1983            tmp = CCER_CCE_Set << TIM_Channel;
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x408B             LSLS     R3,R3,R1
   1984          
   1985            /* Reset the CCxE Bit */
   1986            TIMx->CCER &= (uint16_t)~ tmp;
   \        0x8   0x8C04             LDRH     R4,[R0, #+32]
   \        0xA   0xEA34 0x0303      BICS     R3,R4,R3
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   1987          
   1988            /* Set or reset the CCxE Bit */ 
   1989            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   \       0x10   0x8C03             LDRH     R3,[R0, #+32]
   \       0x12   0xB292             UXTH     R2,R2
   \       0x14   0xFA12 0xF101      LSLS     R1,R2,R1
   \       0x18   0x4319             ORRS     R1,R1,R3
   \       0x1A   0x8401             STRH     R1,[R0, #+32]
   1990          }
   \       0x1C   0xBC10             POP      {R4}
   \       0x1E   0x4770             BX       LR
   1991          
   1992          /**
   1993            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1994            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1995            * @param  TIM_Channel: specifies the TIM Channel
   1996            *   This parameter can be one of the following values:
   1997            *     @arg TIM_Channel_1: TIM Channel 1
   1998            *     @arg TIM_Channel_2: TIM Channel 2
   1999            *     @arg TIM_Channel_3: TIM Channel 3
   2000            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   2001            *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   2002            * @retval None
   2003            */

   \                                 In section .text, align 2, keep-with-next
   2004          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   2005          {
   \                     TIM_CCxNCmd: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2006            uint16_t tmp = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   2007          
   2008            /* Check the parameters */
   2009            //assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2010            //assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   2011            //assert_param(IS_TIM_CCXN(TIM_CCxN));
   2012          
   2013            tmp = CCER_CCNE_Set << TIM_Channel;
   \        0x4   0x2304             MOVS     R3,#+4
   \        0x6   0x408B             LSLS     R3,R3,R1
   2014          
   2015            /* Reset the CCxNE Bit */
   2016            TIMx->CCER &= (uint16_t) ~tmp;
   \        0x8   0x8C04             LDRH     R4,[R0, #+32]
   \        0xA   0xEA34 0x0303      BICS     R3,R4,R3
   \        0xE   0x8403             STRH     R3,[R0, #+32]
   2017          
   2018            /* Set or reset the CCxNE Bit */ 
   2019            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   \       0x10   0x8C03             LDRH     R3,[R0, #+32]
   \       0x12   0xB292             UXTH     R2,R2
   \       0x14   0xFA12 0xF101      LSLS     R1,R2,R1
   \       0x18   0x4319             ORRS     R1,R1,R3
   \       0x1A   0x8401             STRH     R1,[R0, #+32]
   2020          }
   \       0x1C   0xBC10             POP      {R4}
   \       0x1E   0x4770             BX       LR
   2021          
   2022          /**
   2023            * @brief  Selects the TIM Output Compare Mode.
   2024            * @note   This function disables the selected channel before changing the Output
   2025            *         Compare Mode.
   2026            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
   2027            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2028            * @param  TIM_Channel: specifies the TIM Channel
   2029            *   This parameter can be one of the following values:
   2030            *     @arg TIM_Channel_1: TIM Channel 1
   2031            *     @arg TIM_Channel_2: TIM Channel 2
   2032            *     @arg TIM_Channel_3: TIM Channel 3
   2033            *     @arg TIM_Channel_4: TIM Channel 4
   2034            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   2035            *   This parameter can be one of the following values:
   2036            *     @arg TIM_OCMode_Timing
   2037            *     @arg TIM_OCMode_Active
   2038            *     @arg TIM_OCMode_Toggle
   2039            *     @arg TIM_OCMode_PWM1
   2040            *     @arg TIM_OCMode_PWM2
   2041            *     @arg TIM_ForcedAction_Active
   2042            *     @arg TIM_ForcedAction_InActive
   2043            * @retval None
   2044            */

   \                                 In section .text, align 2, keep-with-next
   2045          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   2046          {
   \                     TIM_SelectOCxM: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   2047            uint32_t tmp = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   2048            uint16_t tmp1 = 0;
   \        0x4   0x2300             MOVS     R3,#+0
   2049          
   2050            /* Check the parameters */
   2051            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2052            //assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2053            //assert_param(IS_TIM_OCM(TIM_OCMode));
   2054          
   2055            tmp = (uint32_t) TIMx;
   \        0x6   0x0003             MOVS     R3,R0
   2056            tmp += CCMR_Offset;
   \        0x8   0x3318             ADDS     R3,R3,#+24
   2057          
   2058            tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
   \        0xA   0x2401             MOVS     R4,#+1
   \        0xC   0x408C             LSLS     R4,R4,R1
   2059          
   2060            /* Disable the Channel: Reset the CCxE Bit */
   2061            TIMx->CCER &= (uint16_t) ~tmp1;
   \        0xE   0x8C05             LDRH     R5,[R0, #+32]
   \       0x10   0xEA35 0x0404      BICS     R4,R5,R4
   \       0x14   0x8404             STRH     R4,[R0, #+32]
   2062          
   2063            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \       0x16   0x0008             MOVS     R0,R1
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD003             BEQ.N    ??TIM_SelectOCxM_0
   \       0x1E   0x0008             MOVS     R0,R1
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x2808             CMP      R0,#+8
   \       0x24   0xD10C             BNE.N    ??TIM_SelectOCxM_1
   2064            {
   2065              tmp += (TIM_Channel>>1);
   \                     ??TIM_SelectOCxM_0: (+1)
   \       0x26   0xB289             UXTH     R1,R1
   \       0x28   0x0849             LSRS     R1,R1,#+1
   \       0x2A   0xB289             UXTH     R1,R1
   \       0x2C   0x18C9             ADDS     R1,R1,R3
   2066          
   2067              /* Reset the OCxM bits in the CCMRx register */
   2068              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
   \       0x2E   0x6808             LDR      R0,[R1, #+0]
   \       0x30   0xF030 0x0070      BICS     R0,R0,#0x70
   \       0x34   0x6008             STR      R0,[R1, #+0]
   2069             
   2070              /* Configure the OCxM bits in the CCMRx register */
   2071              *(__IO uint32_t *) tmp |= TIM_OCMode;
   \       0x36   0x6808             LDR      R0,[R1, #+0]
   \       0x38   0xB292             UXTH     R2,R2
   \       0x3A   0x4302             ORRS     R2,R2,R0
   \       0x3C   0x600A             STR      R2,[R1, #+0]
   \       0x3E   0xE00D             B.N      ??TIM_SelectOCxM_2
   2072            }
   2073            else
   2074            {
   2075              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   \                     ??TIM_SelectOCxM_1: (+1)
   \       0x40   0x1F08             SUBS     R0,R1,#+4
   \       0x42   0xB280             UXTH     R0,R0
   \       0x44   0x0840             LSRS     R0,R0,#+1
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0x18C3             ADDS     R3,R0,R3
   2076          
   2077              /* Reset the OCxM bits in the CCMRx register */
   2078              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
   \       0x4A   0x6818             LDR      R0,[R3, #+0]
   \       0x4C   0xF430 0x40E0      BICS     R0,R0,#0x7000
   \       0x50   0x6018             STR      R0,[R3, #+0]
   2079              
   2080              /* Configure the OCxM bits in the CCMRx register */
   2081              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   \       0x52   0x6818             LDR      R0,[R3, #+0]
   \       0x54   0x0212             LSLS     R2,R2,#+8
   \       0x56   0xB292             UXTH     R2,R2
   \       0x58   0x4302             ORRS     R2,R2,R0
   \       0x5A   0x601A             STR      R2,[R3, #+0]
   2082            }
   2083          }
   \                     ??TIM_SelectOCxM_2: (+1)
   \       0x5C   0xBC30             POP      {R4,R5}
   \       0x5E   0x4770             BX       LR
   2084          
   2085          /**
   2086            * @brief  Enables or Disables the TIMx Update event.
   2087            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2088            * @param  NewState: new state of the TIMx UDIS bit
   2089            *   This parameter can be: ENABLE or DISABLE.
   2090            * @retval None
   2091            */

   \                                 In section .text, align 2, keep-with-next
   2092          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2093          {
   2094            /* Check the parameters */
   2095            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2096            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   2097            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_UpdateDisableConfig_0
   2098            {
   2099              /* Set the Update Disable Bit */
   2100              TIMx->CR1 |= TIM_CR1_UDIS;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??TIM_UpdateDisableConfig_1
   2101            }
   2102            else
   2103            {
   2104              /* Reset the Update Disable Bit */
   2105              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
   \                     ??TIM_UpdateDisableConfig_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64F 0x71FD      MOVW     R1,#+65533
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
   2106            }
   2107          }
   \                     ??TIM_UpdateDisableConfig_1: (+1)
   \       0x1A   0x4770             BX       LR
   2108          
   2109          /**
   2110            * @brief  Configures the TIMx Update Request Interrupt source.
   2111            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2112            * @param  TIM_UpdateSource: specifies the Update source.
   2113            *   This parameter can be one of the following values:
   2114            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
   2115                                                 or the setting of UG bit, or an update generation
   2116                                                 through the slave mode controller.
   2117            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
   2118            * @retval None
   2119            */

   \                                 In section .text, align 2, keep-with-next
   2120          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
   2121          {
   2122            /* Check the parameters */
   2123            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2124            //assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2125            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_UpdateRequestConfig_0
   2126            {
   2127              /* Set the URS Bit */
   2128              TIMx->CR1 |= TIM_CR1_URS;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??TIM_UpdateRequestConfig_1
   2129            }
   2130            else
   2131            {
   2132              /* Reset the URS Bit */
   2133              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
   \                     ??TIM_UpdateRequestConfig_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64F 0x71FB      MOVW     R1,#+65531
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
   2134            }
   2135          }
   \                     ??TIM_UpdateRequestConfig_1: (+1)
   \       0x1A   0x4770             BX       LR
   2136          
   2137          /**
   2138            * @brief  Enables or disables the TIMx's Hall sensor interface.
   2139            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2140            * @param  NewState: new state of the TIMx Hall sensor interface.
   2141            *   This parameter can be: ENABLE or DISABLE.
   2142            * @retval None
   2143            */

   \                                 In section .text, align 2, keep-with-next
   2144          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2145          {
   2146            /* Check the parameters */
   2147            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2148            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   2149            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??TIM_SelectHallSensor_0
   2150            {
   2151              /* Set the TI1S Bit */
   2152              TIMx->CR2 |= TIM_CR2_TI1S;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0180      ORRS     R1,R1,#0x80
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??TIM_SelectHallSensor_1
   2153            }
   2154            else
   2155            {
   2156              /* Reset the TI1S Bit */
   2157              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
   \                     ??TIM_SelectHallSensor_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x717F      MOVW     R1,#+65407
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
   2158            }
   2159          }
   \                     ??TIM_SelectHallSensor_1: (+1)
   \       0x1A   0x4770             BX       LR
   2160          
   2161          /**
   2162            * @brief  Selects the TIMx's One Pulse Mode.
   2163            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2164            * @param  TIM_OPMode: specifies the OPM Mode to be used.
   2165            *   This parameter can be one of the following values:
   2166            *     @arg TIM_OPMode_Single
   2167            *     @arg TIM_OPMode_Repetitive
   2168            * @retval None
   2169            */

   \                                 In section .text, align 2, keep-with-next
   2170          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
   2171          {
   2172            /* Check the parameters */
   2173            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2174            //assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2175            /* Reset the OPM Bit */
   2176            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
   \                     TIM_SelectOnePulseMode: (+1)
   \        0x0   0x8803             LDRH     R3,[R0, #+0]
   \        0x2   0xF64F 0x72F7      MOVW     R2,#+65527
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8003             STRH     R3,[R0, #+0]
   2177            /* Configure the OPM Mode */
   2178            TIMx->CR1 |= TIM_OPMode;
   \        0xA   0x8802             LDRH     R2,[R0, #+0]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8001             STRH     R1,[R0, #+0]
   2179          }
   \       0x10   0x4770             BX       LR
   2180          
   2181          /**
   2182            * @brief  Selects the TIMx Trigger Output Mode.
   2183            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
   2184            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2185            *   This paramter can be one of the following values:
   2186            *
   2187            *  - For all TIMx
   2188            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2189            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2190            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2191            *
   2192            *  - For all TIMx except TIM6 and TIM7
   2193            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2194            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2195            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2196            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2197            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2198            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2199            *
   2200            * @retval None
   2201            */

   \                                 In section .text, align 2, keep-with-next
   2202          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2203          {
   2204            /* Check the parameters */
   2205            //assert_param(IS_TIM_LIST7_PERIPH(TIMx));
   2206            //assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2207            /* Reset the MMS Bits */
   2208            TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
   \                     TIM_SelectOutputTrigger: (+1)
   \        0x0   0x8883             LDRH     R3,[R0, #+4]
   \        0x2   0xF64F 0x728F      MOVW     R2,#+65423
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8083             STRH     R3,[R0, #+4]
   2209            /* Select the TRGO source */
   2210            TIMx->CR2 |=  TIM_TRGOSource;
   \        0xA   0x8882             LDRH     R2,[R0, #+4]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8081             STRH     R1,[R0, #+4]
   2211          }
   \       0x10   0x4770             BX       LR
   2212          
   2213          /**
   2214            * @brief  Selects the TIMx Slave Mode.
   2215            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2216            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2217            *   This parameter can be one of the following values:
   2218            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2219            *                               the counter and triggers an update of the registers.
   2220            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2221            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2222            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2223            * @retval None
   2224            */

   \                                 In section .text, align 2, keep-with-next
   2225          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2226          {
   2227            /* Check the parameters */
   2228            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2229            //assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2230           /* Reset the SMS Bits */
   2231            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
   \                     TIM_SelectSlaveMode: (+1)
   \        0x0   0x8903             LDRH     R3,[R0, #+8]
   \        0x2   0xF64F 0x72F8      MOVW     R2,#+65528
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8103             STRH     R3,[R0, #+8]
   2232            /* Select the Slave Mode */
   2233            TIMx->SMCR |= TIM_SlaveMode;
   \        0xA   0x8902             LDRH     R2,[R0, #+8]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8101             STRH     R1,[R0, #+8]
   2234          }
   \       0x10   0x4770             BX       LR
   2235          
   2236          /**
   2237            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2238            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2239            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2240            *   This parameter can be one of the following values:
   2241            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2242            *                                      and its slaves (through TRGO).
   2243            *     @arg TIM_MasterSlaveMode_Disable: No action
   2244            * @retval None
   2245            */

   \                                 In section .text, align 2, keep-with-next
   2246          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2247          {
   2248            /* Check the parameters */
   2249            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2250            //assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2251            /* Reset the MSM Bit */
   2252            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
   \                     TIM_SelectMasterSlaveMode: (+1)
   \        0x0   0x8903             LDRH     R3,[R0, #+8]
   \        0x2   0xF64F 0x727F      MOVW     R2,#+65407
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8103             STRH     R3,[R0, #+8]
   2253            
   2254            /* Set or Reset the MSM Bit */
   2255            TIMx->SMCR |= TIM_MasterSlaveMode;
   \        0xA   0x8902             LDRH     R2,[R0, #+8]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8101             STRH     R1,[R0, #+8]
   2256          }
   \       0x10   0x4770             BX       LR
   2257          
   2258          /**
   2259            * @brief  Sets the TIMx Counter Register value
   2260            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2261            * @param  Counter: specifies the Counter register new value.
   2262            * @retval None
   2263            */

   \                                 In section .text, align 2, keep-with-next
   2264          void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
   2265          {
   2266            /* Check the parameters */
   2267            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2268            /* Set the Counter Register value */
   2269            TIMx->CNT = Counter;
   \                     TIM_SetCounter: (+1)
   \        0x0   0x8481             STRH     R1,[R0, #+36]
   2270          }
   \        0x2   0x4770             BX       LR
   2271          
   2272          /**
   2273            * @brief  Sets the TIMx Autoreload Register value
   2274            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2275            * @param  Autoreload: specifies the Autoreload register new value.
   2276            * @retval None
   2277            */

   \                                 In section .text, align 2, keep-with-next
   2278          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
   2279          {
   2280            /* Check the parameters */
   2281            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2282            /* Set the Autoreload Register value */
   2283            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload: (+1)
   \        0x0   0x8581             STRH     R1,[R0, #+44]
   2284          }
   \        0x2   0x4770             BX       LR
   2285          
   2286          /**
   2287            * @brief  Sets the TIMx Capture Compare1 Register value
   2288            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2289            * @param  Compare1: specifies the Capture Compare1 register new value.
   2290            * @retval None
   2291            */

   \                                 In section .text, align 2, keep-with-next
   2292          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
   2293          {
   2294            /* Check the parameters */
   2295            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2296            /* Set the Capture Compare1 Register value */
   2297            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1: (+1)
   \        0x0   0x8681             STRH     R1,[R0, #+52]
   2298          }
   \        0x2   0x4770             BX       LR
   2299          
   2300          /**
   2301            * @brief  Sets the TIMx Capture Compare2 Register value
   2302            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2303            * @param  Compare2: specifies the Capture Compare2 register new value.
   2304            * @retval None
   2305            */

   \                                 In section .text, align 2, keep-with-next
   2306          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
   2307          {
   2308            /* Check the parameters */
   2309            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2310            /* Set the Capture Compare2 Register value */
   2311            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2: (+1)
   \        0x0   0x8701             STRH     R1,[R0, #+56]
   2312          }
   \        0x2   0x4770             BX       LR
   2313          
   2314          /**
   2315            * @brief  Sets the TIMx Capture Compare3 Register value
   2316            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2317            * @param  Compare3: specifies the Capture Compare3 register new value.
   2318            * @retval None
   2319            */

   \                                 In section .text, align 2, keep-with-next
   2320          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
   2321          {
   2322            /* Check the parameters */
   2323            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2324            /* Set the Capture Compare3 Register value */
   2325            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3: (+1)
   \        0x0   0x8781             STRH     R1,[R0, #+60]
   2326          }
   \        0x2   0x4770             BX       LR
   2327          
   2328          /**
   2329            * @brief  Sets the TIMx Capture Compare4 Register value
   2330            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2331            * @param  Compare4: specifies the Capture Compare4 register new value.
   2332            * @retval None
   2333            */

   \                                 In section .text, align 2, keep-with-next
   2334          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
   2335          {
   2336            /* Check the parameters */
   2337            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2338            /* Set the Capture Compare4 Register value */
   2339            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4: (+1)
   \        0x0   0xF8A0 0x1040      STRH     R1,[R0, #+64]
   2340          }
   \        0x4   0x4770             BX       LR
   2341          
   2342          /**
   2343            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2344            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2345            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2346            *   This parameter can be one of the following values:
   2347            *     @arg TIM_ICPSC_DIV1: no prescaler
   2348            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2349            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2350            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2351            * @retval None
   2352            */

   \                                 In section .text, align 2, keep-with-next
   2353          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2354          {
   2355            /* Check the parameters */
   2356            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2357            //assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2358            /* Reset the IC1PSC Bits */
   2359            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
   \                     TIM_SetIC1Prescaler: (+1)
   \        0x0   0x8B03             LDRH     R3,[R0, #+24]
   \        0x2   0xF64F 0x72F3      MOVW     R2,#+65523
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8303             STRH     R3,[R0, #+24]
   2360            /* Set the IC1PSC value */
   2361            TIMx->CCMR1 |= TIM_ICPSC;
   \        0xA   0x8B02             LDRH     R2,[R0, #+24]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8301             STRH     R1,[R0, #+24]
   2362          }
   \       0x10   0x4770             BX       LR
   2363          
   2364          /**
   2365            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2366            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2367            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2368            *   This parameter can be one of the following values:
   2369            *     @arg TIM_ICPSC_DIV1: no prescaler
   2370            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2371            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2372            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2373            * @retval None
   2374            */

   \                                 In section .text, align 2, keep-with-next
   2375          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2376          {
   2377            /* Check the parameters */
   2378            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2379            //assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2380            /* Reset the IC2PSC Bits */
   2381            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
   \                     TIM_SetIC2Prescaler: (+1)
   \        0x0   0x8B03             LDRH     R3,[R0, #+24]
   \        0x2   0xF24F 0x32FF      MOVW     R2,#+62463
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8303             STRH     R3,[R0, #+24]
   2382            /* Set the IC2PSC value */
   2383            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   \        0xA   0x8B02             LDRH     R2,[R0, #+24]
   \        0xC   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0x10   0x8302             STRH     R2,[R0, #+24]
   2384          }
   \       0x12   0x4770             BX       LR
   2385          
   2386          /**
   2387            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2388            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2389            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2390            *   This parameter can be one of the following values:
   2391            *     @arg TIM_ICPSC_DIV1: no prescaler
   2392            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2393            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2394            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2395            * @retval None
   2396            */

   \                                 In section .text, align 2, keep-with-next
   2397          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2398          {
   2399            /* Check the parameters */
   2400            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2401            //assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2402            /* Reset the IC3PSC Bits */
   2403            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
   \                     TIM_SetIC3Prescaler: (+1)
   \        0x0   0x8B83             LDRH     R3,[R0, #+28]
   \        0x2   0xF64F 0x72F3      MOVW     R2,#+65523
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8383             STRH     R3,[R0, #+28]
   2404            /* Set the IC3PSC value */
   2405            TIMx->CCMR2 |= TIM_ICPSC;
   \        0xA   0x8B82             LDRH     R2,[R0, #+28]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8381             STRH     R1,[R0, #+28]
   2406          }
   \       0x10   0x4770             BX       LR
   2407          
   2408          /**
   2409            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2410            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2411            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2412            *   This parameter can be one of the following values:
   2413            *     @arg TIM_ICPSC_DIV1: no prescaler
   2414            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2415            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2416            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2417            * @retval None
   2418            */

   \                                 In section .text, align 2, keep-with-next
   2419          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2420          {  
   2421            /* Check the parameters */
   2422            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2423            //assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2424            /* Reset the IC4PSC Bits */
   2425            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
   \                     TIM_SetIC4Prescaler: (+1)
   \        0x0   0x8B83             LDRH     R3,[R0, #+28]
   \        0x2   0xF24F 0x32FF      MOVW     R2,#+62463
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8383             STRH     R3,[R0, #+28]
   2426            /* Set the IC4PSC value */
   2427            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   \        0xA   0x8B82             LDRH     R2,[R0, #+28]
   \        0xC   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0x10   0x8382             STRH     R2,[R0, #+28]
   2428          }
   \       0x12   0x4770             BX       LR
   2429          
   2430          /**
   2431            * @brief  Sets the TIMx Clock Division value.
   2432            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select 
   2433            *   the TIM peripheral.
   2434            * @param  TIM_CKD: specifies the clock division value.
   2435            *   This parameter can be one of the following value:
   2436            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
   2437            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2438            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2439            * @retval None
   2440            */

   \                                 In section .text, align 2, keep-with-next
   2441          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
   2442          {
   2443            /* Check the parameters */
   2444            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2445            //assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2446            /* Reset the CKD Bits */
   2447            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
   \                     TIM_SetClockDivision: (+1)
   \        0x0   0x8803             LDRH     R3,[R0, #+0]
   \        0x2   0xF64F 0x42FF      MOVW     R2,#+64767
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8003             STRH     R3,[R0, #+0]
   2448            /* Set the CKD value */
   2449            TIMx->CR1 |= TIM_CKD;
   \        0xA   0x8802             LDRH     R2,[R0, #+0]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8001             STRH     R1,[R0, #+0]
   2450          }
   \       0x10   0x4770             BX       LR
   2451          
   2452          /**
   2453            * @brief  Gets the TIMx Input Capture 1 value.
   2454            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2455            * @retval Capture Compare 1 Register value.
   2456            */

   \                                 In section .text, align 2, keep-with-next
   2457          uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2458          {
   2459            /* Check the parameters */
   2460            //assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2461            /* Get the Capture 1 Register value */
   2462            return TIMx->CCR1;
   \                     TIM_GetCapture1: (+1)
   \        0x0   0x8E80             LDRH     R0,[R0, #+52]
   \        0x2   0x4770             BX       LR
   2463          }
   2464          
   2465          /**
   2466            * @brief  Gets the TIMx Input Capture 2 value.
   2467            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2468            * @retval Capture Compare 2 Register value.
   2469            */

   \                                 In section .text, align 2, keep-with-next
   2470          uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2471          {
   2472            /* Check the parameters */
   2473            //assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2474            /* Get the Capture 2 Register value */
   2475            return TIMx->CCR2;
   \                     TIM_GetCapture2: (+1)
   \        0x0   0x8F00             LDRH     R0,[R0, #+56]
   \        0x2   0x4770             BX       LR
   2476          }
   2477          
   2478          /**
   2479            * @brief  Gets the TIMx Input Capture 3 value.
   2480            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2481            * @retval Capture Compare 3 Register value.
   2482            */

   \                                 In section .text, align 2, keep-with-next
   2483          uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2484          {
   2485            /* Check the parameters */
   2486            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2487            /* Get the Capture 3 Register value */
   2488            return TIMx->CCR3;
   \                     TIM_GetCapture3: (+1)
   \        0x0   0x8F80             LDRH     R0,[R0, #+60]
   \        0x2   0x4770             BX       LR
   2489          }
   2490          
   2491          /**
   2492            * @brief  Gets the TIMx Input Capture 4 value.
   2493            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2494            * @retval Capture Compare 4 Register value.
   2495            */

   \                                 In section .text, align 2, keep-with-next
   2496          uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2497          {
   2498            /* Check the parameters */
   2499            //assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2500            /* Get the Capture 4 Register value */
   2501            return TIMx->CCR4;
   \                     TIM_GetCapture4: (+1)
   \        0x0   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \        0x4   0x4770             BX       LR
   2502          }
   2503          
   2504          /**
   2505            * @brief  Gets the TIMx Counter value.
   2506            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2507            * @retval Counter Register value.
   2508            */

   \                                 In section .text, align 2, keep-with-next
   2509          uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
   2510          {
   2511            /* Check the parameters */
   2512            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2513            /* Get the Counter Register value */
   2514            return TIMx->CNT;
   \                     TIM_GetCounter: (+1)
   \        0x0   0x8C80             LDRH     R0,[R0, #+36]
   \        0x2   0x4770             BX       LR
   2515          }
   2516          
   2517          /**
   2518            * @brief  Gets the TIMx Prescaler value.
   2519            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2520            * @retval Prescaler Register value.
   2521            */

   \                                 In section .text, align 2, keep-with-next
   2522          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2523          {
   2524            /* Check the parameters */
   2525            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2526            /* Get the Prescaler Register value */
   2527            return TIMx->PSC;
   \                     TIM_GetPrescaler: (+1)
   \        0x0   0x8D00             LDRH     R0,[R0, #+40]
   \        0x2   0x4770             BX       LR
   2528          }
   2529          
   2530          /**
   2531            * @brief  Checks whether the specified TIM flag is set or not.
   2532            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2533            * @param  TIM_FLAG: specifies the flag to check.
   2534            *   This parameter can be one of the following values:
   2535            *     @arg TIM_FLAG_Update: TIM update Flag
   2536            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2537            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2538            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2539            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2540            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2541            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2542            *     @arg TIM_FLAG_Break: TIM Break Flag
   2543            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2544            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2545            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2546            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2547            * @note
   2548            *   - TIM6 and TIM7 can have only one update flag. 
   2549            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2550            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2551            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2552            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2553            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2554            * @retval The new state of TIM_FLAG (SET or RESET).
   2555            */

   \                                 In section .text, align 2, keep-with-next
   2556          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2557          { 
   2558            ITStatus bitstatus = RESET;  
   \                     TIM_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   2559            /* Check the parameters */
   2560            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2561            //assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2562            
   2563            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   \        0x2   0x8A00             LDRH     R0,[R0, #+16]
   \        0x4   0x4208             TST      R0,R1
   \        0x6   0xD001             BEQ.N    ??TIM_GetFlagStatus_0
   2564            {
   2565              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??TIM_GetFlagStatus_1
   2566            }
   2567            else
   2568            {
   2569              bitstatus = RESET;
   \                     ??TIM_GetFlagStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   2570            }
   2571            return bitstatus;
   \                     ??TIM_GetFlagStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
   2572          }
   2573          
   2574          /**
   2575            * @brief  Clears the TIMx's pending flags.
   2576            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2577            * @param  TIM_FLAG: specifies the flag bit to clear.
   2578            *   This parameter can be any combination of the following values:
   2579            *     @arg TIM_FLAG_Update: TIM update Flag
   2580            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2581            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2582            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2583            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2584            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2585            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2586            *     @arg TIM_FLAG_Break: TIM Break Flag
   2587            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2588            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2589            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2590            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2591            * @note
   2592            *   - TIM6 and TIM7 can have only one update flag. 
   2593            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2594            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2595            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2596            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2597            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.   
   2598            * @retval None
   2599            */

   \                                 In section .text, align 2, keep-with-next
   2600          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2601          {  
   2602            /* Check the parameters */
   2603            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2604            //assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   2605             
   2606            /* Clear the flags */
   2607            TIMx->SR = (uint16_t)~TIM_FLAG;
   \                     TIM_ClearFlag: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2   0x43C9             MVNS     R1,R1
   \        0x4   0x8201             STRH     R1,[R0, #+16]
   2608          }
   \        0x6   0x4770             BX       LR
   2609          
   2610          /**
   2611            * @brief  Checks whether the TIM interrupt has occurred or not.
   2612            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2613            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2614            *   This parameter can be one of the following values:
   2615            *     @arg TIM_IT_Update: TIM update Interrupt source
   2616            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2617            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2618            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2619            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2620            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2621            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2622            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2623            * @note
   2624            *   - TIM6 and TIM7 can generate only an update interrupt.
   2625            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2626            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2627            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2628            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2629            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
   2630            * @retval The new state of the TIM_IT(SET or RESET).
   2631            */

   \                                 In section .text, align 2, keep-with-next
   2632          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2633          {
   2634            ITStatus bitstatus = RESET;  
   \                     TIM_GetITStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   2635            uint16_t itstatus = 0x0, itenable = 0x0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   2636            /* Check the parameters */
   2637            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2638            //assert_param(IS_TIM_GET_IT(TIM_IT));
   2639             
   2640            itstatus = TIMx->SR & TIM_IT;
   \        0x6   0x8A02             LDRH     R2,[R0, #+16]
   \        0x8   0x400A             ANDS     R2,R1,R2
   2641            
   2642            itenable = TIMx->DIER & TIM_IT;
   \        0xA   0x8980             LDRH     R0,[R0, #+12]
   \        0xC   0x4001             ANDS     R1,R1,R0
   2643            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   \        0xE   0xB292             UXTH     R2,R2
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD004             BEQ.N    ??TIM_GetITStatus_0
   \       0x14   0xB289             UXTH     R1,R1
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD001             BEQ.N    ??TIM_GetITStatus_0
   2644            {
   2645              bitstatus = SET;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??TIM_GetITStatus_1
   2646            }
   2647            else
   2648            {
   2649              bitstatus = RESET;
   \                     ??TIM_GetITStatus_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   2650            }
   2651            return bitstatus;
   \                     ??TIM_GetITStatus_1: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x4770             BX       LR
   2652          }
   2653          
   2654          /**
   2655            * @brief  Clears the TIMx's interrupt pending bits.
   2656            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2657            * @param  TIM_IT: specifies the pending bit to clear.
   2658            *   This parameter can be any combination of the following values:
   2659            *     @arg TIM_IT_Update: TIM1 update Interrupt source
   2660            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2661            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2662            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2663            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2664            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2665            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2666            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2667            * @note
   2668            *   - TIM6 and TIM7 can generate only an update interrupt.
   2669            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2670            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2671            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2672            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2673            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2674            * @retval None
   2675            */

   \                                 In section .text, align 2, keep-with-next
   2676          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2677          {
   2678            /* Check the parameters */
   2679            //assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2680            //assert_param(IS_TIM_IT(TIM_IT));
   2681            /* Clear the IT pending Bit */
   2682            TIMx->SR = (uint16_t)~TIM_IT;
   \                     TIM_ClearITPendingBit: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2   0x43C9             MVNS     R1,R1
   \        0x4   0x8201             STRH     R1,[R0, #+16]
   2683          }
   \        0x6   0x4770             BX       LR
   2684          
   2685          /**
   2686            * @brief  Configure the TI1 as Input.
   2687            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2688            * @param  TIM_ICPolarity : The Input Polarity.
   2689            *   This parameter can be one of the following values:
   2690            *     @arg TIM_ICPolarity_Rising
   2691            *     @arg TIM_ICPolarity_Falling
   2692            * @param  TIM_ICSelection: specifies the input to be used.
   2693            *   This parameter can be one of the following values:
   2694            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2695            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2696            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2697            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2698            *   This parameter must be a value between 0x00 and 0x0F.
   2699            * @retval None
   2700            */

   \                                 In section .text, align 2, keep-with-next
   2701          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2702                                 uint16_t TIM_ICFilter)
   2703          {
   \                     TI1_Config: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   2704            uint16_t tmpccmr1 = 0, tmpccer = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   2705            /* Disable the Channel 1: Reset the CC1E Bit */
   2706            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
   \        0x6   0x8C05             LDRH     R5,[R0, #+32]
   \        0x8   0xF64F 0x74FE      MOVW     R4,#+65534
   \        0xC   0x4025             ANDS     R5,R4,R5
   \        0xE   0x8405             STRH     R5,[R0, #+32]
   2707            tmpccmr1 = TIMx->CCMR1;
   \       0x10   0x8B05             LDRH     R5,[R0, #+24]
   2708            tmpccer = TIMx->CCER;
   \       0x12   0x8C06             LDRH     R6,[R0, #+32]
   2709            /* Select the Input and set the filter */
   2710            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
   \       0x14   0xF64F 0x740C      MOVW     R4,#+65292
   \       0x18   0x4025             ANDS     R5,R4,R5
   2711            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \       0x1A   0x432A             ORRS     R2,R2,R5
   \       0x1C   0xEA52 0x1203      ORRS     R2,R2,R3, LSL #+4
   2712            
   2713            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2714               (TIMx == TIM4) ||(TIMx == TIM5))
   \       0x20   0x....             LDR.N    R3,??DataTable6
   \       0x22   0x4298             CMP      R0,R3
   \       0x24   0xD00E             BEQ.N    ??TI1_Config_0
   \       0x26   0x....             LDR.N    R3,??DataTable8
   \       0x28   0x4298             CMP      R0,R3
   \       0x2A   0xD00B             BEQ.N    ??TI1_Config_0
   \       0x2C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x30   0xD008             BEQ.N    ??TI1_Config_0
   \       0x32   0x....             LDR.N    R3,??DataTable7
   \       0x34   0x4298             CMP      R0,R3
   \       0x36   0xD005             BEQ.N    ??TI1_Config_0
   \       0x38   0x....             LDR.N    R3,??DataTable7_1
   \       0x3A   0x4298             CMP      R0,R3
   \       0x3C   0xD002             BEQ.N    ??TI1_Config_0
   \       0x3E   0x....             LDR.N    R3,??DataTable7_2
   \       0x40   0x4298             CMP      R0,R3
   \       0x42   0xD106             BNE.N    ??TI1_Config_1
   2715            {
   2716              /* Select the Polarity and set the CC1E Bit */
   2717              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
   \                     ??TI1_Config_0: (+1)
   \       0x44   0xF64F 0x73FD      MOVW     R3,#+65533
   \       0x48   0x401E             ANDS     R6,R3,R6
   2718              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   \       0x4A   0x4331             ORRS     R1,R1,R6
   \       0x4C   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x50   0xE005             B.N      ??TI1_Config_2
   2719            }
   2720            else
   2721            {
   2722              /* Select the Polarity and set the CC1E Bit */
   2723              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \                     ??TI1_Config_1: (+1)
   \       0x52   0xF64F 0x73F5      MOVW     R3,#+65525
   \       0x56   0x401E             ANDS     R6,R3,R6
   2724              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   \       0x58   0x4331             ORRS     R1,R1,R6
   \       0x5A   0xF051 0x0101      ORRS     R1,R1,#0x1
   2725            }
   2726          
   2727            /* Write to TIMx CCMR1 and CCER registers */
   2728            TIMx->CCMR1 = tmpccmr1;
   \                     ??TI1_Config_2: (+1)
   \       0x5E   0x8302             STRH     R2,[R0, #+24]
   2729            TIMx->CCER = tmpccer;
   \       0x60   0x8401             STRH     R1,[R0, #+32]
   2730          }
   \       0x62   0xBC70             POP      {R4-R6}
   \       0x64   0x4770             BX       LR
   2731          
   2732          /**
   2733            * @brief  Configure the TI2 as Input.
   2734            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2735            * @param  TIM_ICPolarity : The Input Polarity.
   2736            *   This parameter can be one of the following values:
   2737            *     @arg TIM_ICPolarity_Rising
   2738            *     @arg TIM_ICPolarity_Falling
   2739            * @param  TIM_ICSelection: specifies the input to be used.
   2740            *   This parameter can be one of the following values:
   2741            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2742            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2743            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2744            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2745            *   This parameter must be a value between 0x00 and 0x0F.
   2746            * @retval None
   2747            */

   \                                 In section .text, align 2, keep-with-next
   2748          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2749                                 uint16_t TIM_ICFilter)
   2750          {
   \                     TI2_Config: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   2751            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   2752            /* Disable the Channel 2: Reset the CC2E Bit */
   2753            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
   \        0x8   0x8C05             LDRH     R5,[R0, #+32]
   \        0xA   0xF64F 0x74EF      MOVW     R4,#+65519
   \        0xE   0x4025             ANDS     R5,R4,R5
   \       0x10   0x8405             STRH     R5,[R0, #+32]
   2754            tmpccmr1 = TIMx->CCMR1;
   \       0x12   0x8B05             LDRH     R5,[R0, #+24]
   2755            tmpccer = TIMx->CCER;
   \       0x14   0x8C06             LDRH     R6,[R0, #+32]
   2756            tmp = (uint16_t)(TIM_ICPolarity << 4);
   \       0x16   0x010F             LSLS     R7,R1,#+4
   2757            /* Select the Input and set the filter */
   2758            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
   \       0x18   0xF640 0x44FF      MOVW     R4,#+3327
   \       0x1C   0x4025             ANDS     R5,R4,R5
   2759            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   \       0x1E   0xEA55 0x3503      ORRS     R5,R5,R3, LSL #+12
   2760            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   \       0x22   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   2761            
   2762            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2763               (TIMx == TIM4) ||(TIMx == TIM5))
   \       0x26   0x....             LDR.N    R2,??DataTable9_6
   \       0x28   0x4290             CMP      R0,R2
   \       0x2A   0xD00E             BEQ.N    ??TI2_Config_0
   \       0x2C   0x....             LDR.N    R2,??DataTable8
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD00B             BEQ.N    ??TI2_Config_0
   \       0x32   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x36   0xD008             BEQ.N    ??TI2_Config_0
   \       0x38   0x....             LDR.N    R2,??DataTable7
   \       0x3A   0x4290             CMP      R0,R2
   \       0x3C   0xD005             BEQ.N    ??TI2_Config_0
   \       0x3E   0x....             LDR.N    R2,??DataTable7_1
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD002             BEQ.N    ??TI2_Config_0
   \       0x44   0x....             LDR.N    R2,??DataTable7_2
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xD107             BNE.N    ??TI2_Config_1
   2764            {
   2765              /* Select the Polarity and set the CC2E Bit */
   2766              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
   \                     ??TI2_Config_0: (+1)
   \       0x4A   0x0031             MOVS     R1,R6
   \       0x4C   0xF64F 0x72DF      MOVW     R2,#+65503
   \       0x50   0x4011             ANDS     R1,R2,R1
   2767              tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   \       0x52   0x4339             ORRS     R1,R7,R1
   \       0x54   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x58   0xE005             B.N      ??TI2_Config_2
   2768            }
   2769            else
   2770            {
   2771              /* Select the Polarity and set the CC2E Bit */
   2772              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \                     ??TI2_Config_1: (+1)
   \       0x5A   0xF64F 0x725F      MOVW     R2,#+65375
   \       0x5E   0x4016             ANDS     R6,R2,R6
   2773              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
   \       0x60   0x4331             ORRS     R1,R1,R6
   \       0x62   0xF051 0x0110      ORRS     R1,R1,#0x10
   2774            }
   2775            
   2776            /* Write to TIMx CCMR1 and CCER registers */
   2777            TIMx->CCMR1 = tmpccmr1 ;
   \                     ??TI2_Config_2: (+1)
   \       0x66   0x8305             STRH     R5,[R0, #+24]
   2778            TIMx->CCER = tmpccer;
   \       0x68   0x8401             STRH     R1,[R0, #+32]
   2779          }
   \       0x6A   0xBCF0             POP      {R4-R7}
   \       0x6C   0x4770             BX       LR
   2780          
   2781          /**
   2782            * @brief  Configure the TI3 as Input.
   2783            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2784            * @param  TIM_ICPolarity : The Input Polarity.
   2785            *   This parameter can be one of the following values:
   2786            *     @arg TIM_ICPolarity_Rising
   2787            *     @arg TIM_ICPolarity_Falling
   2788            * @param  TIM_ICSelection: specifies the input to be used.
   2789            *   This parameter can be one of the following values:
   2790            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2791            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2792            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2793            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2794            *   This parameter must be a value between 0x00 and 0x0F.
   2795            * @retval None
   2796            */

   \                                 In section .text, align 2, keep-with-next
   2797          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2798                                 uint16_t TIM_ICFilter)
   2799          {
   \                     TI3_Config: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   2800            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   2801            /* Disable the Channel 3: Reset the CC3E Bit */
   2802            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
   \        0x8   0x8C05             LDRH     R5,[R0, #+32]
   \        0xA   0xF64F 0x64FF      MOVW     R4,#+65279
   \        0xE   0x4025             ANDS     R5,R4,R5
   \       0x10   0x8405             STRH     R5,[R0, #+32]
   2803            tmpccmr2 = TIMx->CCMR2;
   \       0x12   0x8B85             LDRH     R5,[R0, #+28]
   2804            tmpccer = TIMx->CCER;
   \       0x14   0x8C06             LDRH     R6,[R0, #+32]
   2805            tmp = (uint16_t)(TIM_ICPolarity << 8);
   \       0x16   0x020F             LSLS     R7,R1,#+8
   2806            /* Select the Input and set the filter */
   2807            tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
   \       0x18   0xF64F 0x740C      MOVW     R4,#+65292
   \       0x1C   0x4025             ANDS     R5,R4,R5
   2808            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \       0x1E   0x432A             ORRS     R2,R2,R5
   \       0x20   0xEA52 0x1203      ORRS     R2,R2,R3, LSL #+4
   2809              
   2810            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2811               (TIMx == TIM4) ||(TIMx == TIM5))
   \       0x24   0x....             LDR.N    R3,??DataTable9_6
   \       0x26   0x4298             CMP      R0,R3
   \       0x28   0xD00E             BEQ.N    ??TI3_Config_0
   \       0x2A   0x....             LDR.N    R3,??DataTable8
   \       0x2C   0x4298             CMP      R0,R3
   \       0x2E   0xD00B             BEQ.N    ??TI3_Config_0
   \       0x30   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x34   0xD008             BEQ.N    ??TI3_Config_0
   \       0x36   0x....             LDR.N    R3,??DataTable9_7
   \       0x38   0x4298             CMP      R0,R3
   \       0x3A   0xD005             BEQ.N    ??TI3_Config_0
   \       0x3C   0x....             LDR.N    R3,??DataTable9_8
   \       0x3E   0x4298             CMP      R0,R3
   \       0x40   0xD002             BEQ.N    ??TI3_Config_0
   \       0x42   0x....             LDR.N    R3,??DataTable9_9
   \       0x44   0x4298             CMP      R0,R3
   \       0x46   0xD107             BNE.N    ??TI3_Config_1
   2812            {
   2813              /* Select the Polarity and set the CC3E Bit */
   2814              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
   \                     ??TI3_Config_0: (+1)
   \       0x48   0x0031             MOVS     R1,R6
   \       0x4A   0xF64F 0x53FF      MOVW     R3,#+65023
   \       0x4E   0x4019             ANDS     R1,R3,R1
   2815              tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   \       0x50   0x4339             ORRS     R1,R7,R1
   \       0x52   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x56   0xE005             B.N      ??TI3_Config_2
   2816            }
   2817            else
   2818            {
   2819              /* Select the Polarity and set the CC3E Bit */
   2820              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \                     ??TI3_Config_1: (+1)
   \       0x58   0xF24F 0x53FF      MOVW     R3,#+62975
   \       0x5C   0x401E             ANDS     R6,R3,R6
   2821              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
   \       0x5E   0x4331             ORRS     R1,R1,R6
   \       0x60   0xF451 0x7180      ORRS     R1,R1,#0x100
   2822            }
   2823            
   2824            /* Write to TIMx CCMR2 and CCER registers */
   2825            TIMx->CCMR2 = tmpccmr2;
   \                     ??TI3_Config_2: (+1)
   \       0x64   0x8382             STRH     R2,[R0, #+28]
   2826            TIMx->CCER = tmpccer;
   \       0x66   0x8401             STRH     R1,[R0, #+32]
   2827          }
   \       0x68   0xBCF0             POP      {R4-R7}
   \       0x6A   0x4770             BX       LR
   2828          
   2829          /**
   2830            * @brief  Configure the TI4 as Input.
   2831            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2832            * @param  TIM_ICPolarity : The Input Polarity.
   2833            *   This parameter can be one of the following values:
   2834            *     @arg TIM_ICPolarity_Rising
   2835            *     @arg TIM_ICPolarity_Falling
   2836            * @param  TIM_ICSelection: specifies the input to be used.
   2837            *   This parameter can be one of the following values:
   2838            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2839            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2840            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2841            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2842            *   This parameter must be a value between 0x00 and 0x0F.
   2843            * @retval None
   2844            */

   \                                 In section .text, align 2, keep-with-next
   2845          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2846                                 uint16_t TIM_ICFilter)
   2847          {
   \                     TI4_Config: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   2848            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   2849          
   2850             /* Disable the Channel 4: Reset the CC4E Bit */
   2851            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
   \        0x8   0x8C05             LDRH     R5,[R0, #+32]
   \        0xA   0xF64E 0x74FF      MOVW     R4,#+61439
   \        0xE   0x4025             ANDS     R5,R4,R5
   \       0x10   0x8405             STRH     R5,[R0, #+32]
   2852            tmpccmr2 = TIMx->CCMR2;
   \       0x12   0x8B85             LDRH     R5,[R0, #+28]
   2853            tmpccer = TIMx->CCER;
   \       0x14   0x8C06             LDRH     R6,[R0, #+32]
   2854            tmp = (uint16_t)(TIM_ICPolarity << 12);
   \       0x16   0x030F             LSLS     R7,R1,#+12
   2855            /* Select the Input and set the filter */
   2856            tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
   \       0x18   0xF640 0x44FF      MOVW     R4,#+3327
   \       0x1C   0x4025             ANDS     R5,R4,R5
   2857            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   \       0x1E   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   2858            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   \       0x22   0xEA55 0x3503      ORRS     R5,R5,R3, LSL #+12
   2859            
   2860            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2861               (TIMx == TIM4) ||(TIMx == TIM5))
   \       0x26   0x....             LDR.N    R2,??DataTable9_6
   \       0x28   0x4290             CMP      R0,R2
   \       0x2A   0xD00E             BEQ.N    ??TI4_Config_0
   \       0x2C   0x....             LDR.N    R2,??DataTable9_5
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD00B             BEQ.N    ??TI4_Config_0
   \       0x32   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x36   0xD008             BEQ.N    ??TI4_Config_0
   \       0x38   0x....             LDR.N    R2,??DataTable9_7
   \       0x3A   0x4290             CMP      R0,R2
   \       0x3C   0xD005             BEQ.N    ??TI4_Config_0
   \       0x3E   0x....             LDR.N    R2,??DataTable9_8
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD002             BEQ.N    ??TI4_Config_0
   \       0x44   0x....             LDR.N    R2,??DataTable9_9
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xD107             BNE.N    ??TI4_Config_1
   2862            {
   2863              /* Select the Polarity and set the CC4E Bit */
   2864              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
   \                     ??TI4_Config_0: (+1)
   \       0x4A   0x0031             MOVS     R1,R6
   \       0x4C   0xF64D 0x72FF      MOVW     R2,#+57343
   \       0x50   0x4011             ANDS     R1,R2,R1
   2865              tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   \       0x52   0x4339             ORRS     R1,R7,R1
   \       0x54   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \       0x58   0xE005             B.N      ??TI4_Config_2
   2866            }
   2867            else
   2868            {
   2869              /* Select the Polarity and set the CC4E Bit */
   2870              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
   \                     ??TI4_Config_1: (+1)
   \       0x5A   0xF647 0x52FF      MOVW     R2,#+32255
   \       0x5E   0x4016             ANDS     R6,R2,R6
   2871              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
   \       0x60   0x4331             ORRS     R1,R1,R6
   \       0x62   0xF451 0x5180      ORRS     R1,R1,#0x1000
   2872            }
   2873            /* Write to TIMx CCMR2 and CCER registers */
   2874            TIMx->CCMR2 = tmpccmr2;
   \                     ??TI4_Config_2: (+1)
   \       0x66   0x8385             STRH     R5,[R0, #+28]
   2875            TIMx->CCER = tmpccer;
   \       0x68   0x8401             STRH     R1,[R0, #+32]
   2876          }
   \       0x6A   0xBCF0             POP      {R4-R7}
   \       0x6C   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x4000'0C00        DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x4000'1000        DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x4000'1400        DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4001'3400        DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4001'4C00        DC32     0x40014c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4001'5000        DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x4001'5400        DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x4000'1800        DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x4000'1C00        DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x4000'2000        DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x4001'3400        DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \        0x0   0x4000'0C00        DC32     0x40000c00
   2877          
   2878          /**
   2879            * @}
   2880            */
   2881          
   2882          /**
   2883            * @}
   2884            */
   2885          
   2886          /**
   2887            * @}
   2888            */
   2889          
   2890          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   TI1_Config
      16   TI2_Config
      16   TI3_Config
      16   TI4_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
       4   TIM_CCxCmd
       4   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   TIM_ETRClockMode1Config
         8   -> TIM_ETRConfig
       8   TIM_ETRClockMode2Config
         8   -> TIM_ETRConfig
       4   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
       8   TIM_ITRxExternalClockConfig
         8   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
       8   TIM_OC1Init
       0   TIM_OC1NPolarityConfig
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
       8   TIM_OC2Init
       0   TIM_OC2NPolarityConfig
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
       8   TIM_OC3Init
       0   TIM_OC3NPolarityConfig
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
       8   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
       8   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      16   TIM_TIxExternalClockConfig
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TIM_SelectInputTrigger
       0   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     102  TI1_Config
     110  TI2_Config
     108  TI3_Config
     110  TI4_Config
      28  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      28  TIM_CCPreloadControl
      32  TIM_CCxCmd
      32  TIM_CCxNCmd
       8  TIM_ClearFlag
       8  TIM_ClearITPendingBit
      16  TIM_ClearOC1Ref
      16  TIM_ClearOC2Ref
      16  TIM_ClearOC3Ref
      16  TIM_ClearOC4Ref
      28  TIM_Cmd
      16  TIM_CounterModeConfig
      34  TIM_CtrlPWMOutputs
      24  TIM_DMACmd
       8  TIM_DMAConfig
     478  TIM_DeInit
      44  TIM_ETRClockMode1Config
      26  TIM_ETRClockMode2Config
      24  TIM_ETRConfig
      56  TIM_EncoderInterfaceConfig
      16  TIM_ForcedOC1Config
      18  TIM_ForcedOC2Config
      16  TIM_ForcedOC3Config
      18  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
      18  TIM_GetFlagStatus
      36  TIM_GetITStatus
       4  TIM_GetPrescaler
     112  TIM_ICInit
      22  TIM_ICStructInit
      24  TIM_ITConfig
      22  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      16  TIM_OC1FastConfig
     148  TIM_OC1Init
      16  TIM_OC1NPolarityConfig
      16  TIM_OC1PolarityConfig
      16  TIM_OC1PreloadConfig
      18  TIM_OC2FastConfig
     138  TIM_OC2Init
      18  TIM_OC2NPolarityConfig
      18  TIM_OC2PolarityConfig
      18  TIM_OC2PreloadConfig
      16  TIM_OC3FastConfig
     136  TIM_OC3Init
      18  TIM_OC3NPolarityConfig
      18  TIM_OC3PolarityConfig
      16  TIM_OC3PreloadConfig
      18  TIM_OC4FastConfig
     104  TIM_OC4Init
      18  TIM_OC4PolarityConfig
      18  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     132  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      28  TIM_SelectCCDMA
      28  TIM_SelectCOM
      28  TIM_SelectHallSensor
      16  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
      96  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      62  TIM_TIxExternalClockConfig
     146  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      28  TIM_UpdateDisableConfig
      28  TIM_UpdateRequestConfig

 
 3'490 bytes in section .text
 
 3'490 bytes of CODE memory

Errors: none
Warnings: none
