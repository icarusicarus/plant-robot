###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       22/Nov/2021  19:36:24
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_rcc.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EWF182.tmp
#        (C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_rcc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\List -o
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\pnu3\Desktop\Embedded-main\Libraries\CMSIS\DeviceSupport\
#        -I C:\Users\pnu3\Desktop\Embedded-main\Libraries\LCD\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\Embedded-main\user\inc\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\user\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\DHT11\ -Ol -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\List\stm32f10x_rcc.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\Obj\stm32f10x_rcc.o
#
###############################################################################

C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_rcc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the RCC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_rcc.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          /** @defgroup RCC 
     30            * @brief RCC driver modules
     31            * @{
     32            */ 
     33          
     34          /** @defgroup RCC_Private_TypesDefinitions
     35            * @{
     36            */
     37          
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup RCC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* ------------ RCC registers bit address in the alias region ----------- */
     47          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     48          
     49          /* --- CR Register ---*/
     50          
     51          /* Alias word address of HSION bit */
     52          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     53          #define HSION_BitNumber           0x00
     54          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     55          
     56          /* Alias word address of PLLON bit */
     57          #define PLLON_BitNumber           0x18
     58          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     59          
     60          #ifdef STM32F10X_CL
     61           /* Alias word address of PLL2ON bit */
     62           #define PLL2ON_BitNumber          0x1A
     63           #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
     64          
     65           /* Alias word address of PLL3ON bit */
     66           #define PLL3ON_BitNumber          0x1C
     67           #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
     68          #endif /* STM32F10X_CL */ 
     69          
     70          /* Alias word address of CSSON bit */
     71          #define CSSON_BitNumber           0x13
     72          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     73          
     74          /* --- CFGR Register ---*/
     75          
     76          /* Alias word address of USBPRE bit */
     77          #define CFGR_OFFSET               (RCC_OFFSET + 0x04)
     78          
     79          #ifndef STM32F10X_CL
     80           #define USBPRE_BitNumber          0x16
     81           #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
     82          #else
     83           #define OTGFSPRE_BitNumber        0x16
     84           #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
     85          #endif /* STM32F10X_CL */ 
     86          
     87          /* --- BDCR Register ---*/
     88          
     89          /* Alias word address of RTCEN bit */
     90          #define BDCR_OFFSET               (RCC_OFFSET + 0x20)
     91          #define RTCEN_BitNumber           0x0F
     92          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
     93          
     94          /* Alias word address of BDRST bit */
     95          #define BDRST_BitNumber           0x10
     96          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
     97          
     98          /* --- CSR Register ---*/
     99          
    100          /* Alias word address of LSION bit */
    101          #define CSR_OFFSET                (RCC_OFFSET + 0x24)
    102          #define LSION_BitNumber           0x00
    103          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    104          
    105          #ifdef STM32F10X_CL
    106          /* --- CFGR2 Register ---*/
    107          
    108           /* Alias word address of I2S2SRC bit */
    109           #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
    110           #define I2S2SRC_BitNumber         0x11
    111           #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
    112          
    113           /* Alias word address of I2S3SRC bit */
    114           #define I2S3SRC_BitNumber         0x12
    115           #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
    116          #endif /* STM32F10X_CL */
    117          
    118          /* ---------------------- RCC registers bit mask ------------------------ */
    119          
    120          /* CR register bit mask */
    121          #define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
    122          #define CR_HSEBYP_Set             ((uint32_t)0x00040000)
    123          #define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
    124          #define CR_HSEON_Set              ((uint32_t)0x00010000)
    125          #define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
    126          
    127          /* CFGR register bit mask */
    128          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL) 
    129           #define CFGR_PLL_Mask            ((uint32_t)0xFFC2FFFF)
    130          #else
    131           #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
    132          #endif /* STM32F10X_CL */ 
    133          
    134          #define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
    135          #define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
    136          #define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
    137          #define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
    138          #define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
    139          #define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
    140          #define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
    141          #define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
    142          #define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
    143          #define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
    144          #define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
    145          #define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
    146          #define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
    147          
    148          /* CSR register bit mask */
    149          #define CSR_RMVF_Set              ((uint32_t)0x01000000)
    150          
    151          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL) 
    152          /* CFGR2 register bit mask */
    153           #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
    154           #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
    155          #endif
    156          #ifdef STM32F10X_CL
    157           #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
    158           #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
    159           #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
    160          #endif /* STM32F10X_CL */ 
    161          
    162          /* RCC Flag Mask */
    163          #define FLAG_Mask                 ((uint8_t)0x1F)
    164          
    165          /* CIR register byte 2 (Bits[15:8]) base address */
    166          #define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
    167          
    168          /* CIR register byte 3 (Bits[23:16]) base address */
    169          #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
    170          
    171          /* CFGR register byte 4 (Bits[31:24]) base address */
    172          #define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
    173          
    174          /* BDCR register base address */
    175          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    176          
    177          /**
    178            * @}
    179            */ 
    180          
    181          /** @defgroup RCC_Private_Macros
    182            * @{
    183            */ 
    184          
    185          /**
    186            * @}
    187            */ 
    188          
    189          /** @defgroup RCC_Private_Variables
    190            * @{
    191            */ 
    192          

   \                                 In section .data, align 4
    193          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    

   \                                 In section .data, align 4
    194          static __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
   \                     ADCPrescTable:
   \   00000000   0x02 0x04          DC8 2, 4, 6, 8
   \              0x06 0x08    
    195          
    196          /**
    197            * @}
    198            */
    199          
    200          /** @defgroup RCC_Private_FunctionPrototypes
    201            * @{
    202            */
    203          
    204          /**
    205            * @}
    206            */
    207          
    208          /** @defgroup RCC_Private_Functions
    209            * @{
    210            */
    211          
    212          /**
    213            * @brief  Resets the RCC clock configuration to the default reset state.
    214            * @param  None
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void RCC_DeInit(void)
    218          {
    219            /* Set HSION bit */
    220            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    221          
    222            /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    223          #ifndef STM32F10X_CL
    224            RCC->CFGR &= (uint32_t)0xF8FF0000;
    225          #else
    226            RCC->CFGR &= (uint32_t)0xF0FF0000;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40021004
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable39_2  ;; 0xf0ff0000
   \   0000001A   0x4001             ANDS     R1,R0,R1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40021004
   \   00000020   0x6001             STR      R1,[R0, #+0]
    227          #endif /* STM32F10X_CL */   
    228            
    229            /* Reset HSEON, CSSON and PLLON bits */
    230            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable39_3  ;; 0xfef6ffff
   \   0000002C   0x4001             ANDS     R1,R0,R1
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000032   0x6001             STR      R1,[R0, #+0]
    231          
    232            /* Reset HSEBYP bit */
    233            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   00000042   0x6008             STR      R0,[R1, #+0]
    234          
    235            /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    236            RCC->CFGR &= (uint32_t)0xFF80FFFF;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40021004
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x00FE      BICS     R0,R0,#0x7F0000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000052   0x6008             STR      R0,[R1, #+0]
    237          
    238          #ifdef STM32F10X_CL
    239            /* Reset PLL2ON and PLL3ON bits */
    240            RCC->CR &= (uint32_t)0xEBFFFFFF;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x50A0      BICS     R0,R0,#0x14000000
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   00000062   0x6008             STR      R0,[R1, #+0]
    241          
    242            /* Disable all interrupts and clear pending bits  */
    243            RCC->CIR = 0x00FF0000;
   \   00000064   0xF45F 0x007F      MOVS     R0,#+16711680
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable39_4  ;; 0x40021008
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    244          
    245            /* Reset CFGR2 register */
    246            RCC->CFGR2 = 0x00000000;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000074   0x6008             STR      R0,[R1, #+0]
    247          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    248            /* Disable all interrupts and clear pending bits  */
    249            RCC->CIR = 0x009F0000;
    250          
    251            /* Reset CFGR2 register */
    252            RCC->CFGR2 = 0x00000000;      
    253          #else
    254            /* Disable all interrupts and clear pending bits  */
    255            RCC->CIR = 0x009F0000;
    256          #endif /* STM32F10X_CL */
    257          
    258          }
   \   00000076   0x4770             BX       LR               ;; return
    259          
    260          /**
    261            * @brief  Configures the External High Speed oscillator (HSE).
    262            * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
    263            * @param  RCC_HSE: specifies the new state of the HSE.
    264            *   This parameter can be one of the following values:
    265            *     @arg RCC_HSE_OFF: HSE oscillator OFF
    266            *     @arg RCC_HSE_ON: HSE oscillator ON
    267            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    268            * @retval None
    269            */

   \                                 In section .text, align 2, keep-with-next
    270          void RCC_HSEConfig(uint32_t RCC_HSE)
    271          {
    272            /* Check the parameters */
    273            //assert_param(IS_RCC_HSE(RCC_HSE));
    274            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    275            /* Reset HSEON bit */
    276            RCC->CR &= CR_HSEON_Reset;
   \                     RCC_HSEConfig: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable39  ;; 0x40021000
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    277            /* Reset HSEBYP bit */
    278            RCC->CR &= CR_HSEBYP_Reset;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF431 0x2180      BICS     R1,R1,#0x40000
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable39  ;; 0x40021000
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    279            /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
    280            switch(RCC_HSE)
   \   00000020   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000024   0xD003             BEQ.N    ??RCC_HSEConfig_0
   \   00000026   0xF5B0 0x2F80      CMP      R0,#+262144
   \   0000002A   0xD009             BEQ.N    ??RCC_HSEConfig_1
   \   0000002C   0xE011             B.N      ??RCC_HSEConfig_2
    281            {
    282              case RCC_HSE_ON:
    283                /* Set HSEON bit */
    284                RCC->CR |= CR_HSEON_Set;
   \                     ??RCC_HSEConfig_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    285                break;
   \   0000003E   0xE008             B.N      ??RCC_HSEConfig_3
    286                
    287              case RCC_HSE_Bypass:
    288                /* Set HSEBYP and HSEON bits */
    289                RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
   \                     ??RCC_HSEConfig_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x20A0      ORRS     R0,R0,#0x50000
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    290                break;
   \   00000050   0xE7FF             B.N      ??RCC_HSEConfig_3
    291                
    292              default:
    293                break;
    294            }
    295          }
   \                     ??RCC_HSEConfig_2: (+1)
   \                     ??RCC_HSEConfig_3: (+1)
   \   00000052   0x4770             BX       LR               ;; return
    296          
    297          /**
    298            * @brief  Waits for HSE start-up.
    299            * @param  None
    300            * @retval An ErrorStatus enumuration value:
    301            * - SUCCESS: HSE oscillator is stable and ready to use
    302            * - ERROR: HSE oscillator not yet ready
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          ErrorStatus RCC_WaitForHSEStartUp(void)
    305          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    306            __IO uint32_t StartUpCounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    307            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    308            FlagStatus HSEStatus = RESET;
   \   00000008   0x2000             MOVS     R0,#+0
    309            
    310            /* Wait till HSE is ready and if Time out is reached exit */
    311            do
    312            {
    313              HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2031             MOVS     R0,#+49
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
    314              StartUpCounter++;  
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x9100             STR      R1,[SP, #+0]
    315            } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0xF5B1 0x6FA0      CMP      R1,#+1280
   \   0000001C   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_1
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F2             BEQ.N    ??RCC_WaitForHSEStartUp_0
    316            
    317            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000024   0x2031             MOVS     R0,#+49
   \   00000026   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??RCC_WaitForHSEStartUp_2
    318            {
    319              status = SUCCESS;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??RCC_WaitForHSEStartUp_3
    320            }
    321            else
    322            {
    323              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
    324            }  
    325            return (status);
   \                     ??RCC_WaitForHSEStartUp_3: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xBD02             POP      {R1,PC}          ;; return
    326          }
    327          
    328          /**
    329            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    330            * @param  HSICalibrationValue: specifies the calibration trimming value.
    331            *   This parameter must be a number between 0 and 0x1F.
    332            * @retval None
    333            */

   \                                 In section .text, align 2, keep-with-next
    334          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    335          {
    336            uint32_t tmpreg = 0;
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    337            /* Check the parameters */
    338            //assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    339            tmpreg = RCC->CR;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39  ;; 0x40021000
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    340            /* Clear HSITRIM[4:0] bits */
    341            tmpreg &= CR_HSITRIM_Mask;
   \   00000008   0xF031 0x01F8      BICS     R1,R1,#0xF8
    342            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    343            tmpreg |= (uint32_t)HSICalibrationValue << 3;
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
    344            /* Store the new value */
    345            RCC->CR = tmpreg;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40021000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    346          }
   \   00000018   0x4770             BX       LR               ;; return
    347          
    348          /**
    349            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    350            * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
    351            * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
    352            * @retval None
    353            */

   \                                 In section .text, align 2, keep-with-next
    354          void RCC_HSICmd(FunctionalState NewState)
    355          {
    356            /* Check the parameters */
    357            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    358            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_6  ;; 0x42420000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    359          }
   \   00000008   0x4770             BX       LR               ;; return
    360          
    361          /**
    362            * @brief  Configures the PLL clock source and multiplication factor.
    363            * @note   This function must be used only when the PLL is disabled.
    364            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    365            *   For @b STM32_Connectivity_line_devices or @b STM32_Value_line_devices, 
    366            *   this parameter can be one of the following values:
    367            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    368            *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
    369            *   For @b other_STM32_devices, this parameter can be one of the following values:
    370            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    371            *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
    372            *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry 
    373            * @param  RCC_PLLMul: specifies the PLL multiplication factor.
    374            *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
    375            *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
    379          {
    380            uint32_t tmpreg = 0;
   \                     RCC_PLLConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    381          
    382            /* Check the parameters */
    383            //assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    384            //assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
    385          
    386            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable39_1  ;; 0x40021004
   \   00000006   0x6812             LDR      R2,[R2, #+0]
    387            /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
    388            tmpreg &= CFGR_PLL_Mask;
   \   00000008   0xF432 0x1274      BICS     R2,R2,#0x3D0000
    389            /* Set the PLL configuration bits */
    390            tmpreg |= RCC_PLLSource | RCC_PLLMul;
   \   0000000C   0x4308             ORRS     R0,R1,R0
   \   0000000E   0x4310             ORRS     R0,R0,R2
    391            /* Store the new value */
    392            RCC->CFGR = tmpreg;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000014   0x6008             STR      R0,[R1, #+0]
    393          }
   \   00000016   0x4770             BX       LR               ;; return
    394          
    395          /**
    396            * @brief  Enables or disables the PLL.
    397            * @note   The PLL can not be disabled if it is used as system clock.
    398            * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
    399            * @retval None
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          void RCC_PLLCmd(FunctionalState NewState)
    402          {
    403            /* Check the parameters */
    404            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    405          
    406            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_7  ;; 0x42420060
   \   00000006   0x6008             STR      R0,[R1, #+0]
    407          }
   \   00000008   0x4770             BX       LR               ;; return
    408          
    409          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
    410          /**
    411            * @brief  Configures the PREDIV1 division factor.
    412            * @note 
    413            *   - This function must be used only when the PLL is disabled.
    414            *   - This function applies only to STM32 Connectivity line and Value line 
    415            *     devices.
    416            * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
    417            *   This parameter can be one of the following values:
    418            *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
    419            *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
    420            * @note 
    421            *   For @b STM32_Value_line_devices this parameter is always RCC_PREDIV1_Source_HSE  
    422            * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
    423            *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
    424            * @retval None
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
    427          {
    428            uint32_t tmpreg = 0;
   \                     RCC_PREDIV1Config: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    429            
    430            /* Check the parameters */
    431            //assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
    432            //assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
    433          
    434            tmpreg = RCC->CFGR2;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable39_5  ;; 0x4002102c
   \   00000006   0x6813             LDR      R3,[R2, #+0]
    435            /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
    436            tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable39_8  ;; 0xfffefff0
   \   0000000C   0x4013             ANDS     R3,R2,R3
    437            /* Set the PREDIV1 clock source and division factor */
    438            tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x4318             ORRS     R0,R0,R3
    439            /* Store the new value */
    440            RCC->CFGR2 = tmpreg;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    441          }
   \   00000018   0x4770             BX       LR               ;; return
    442          #endif
    443          
    444          #ifdef STM32F10X_CL
    445          /**
    446            * @brief  Configures the PREDIV2 division factor.
    447            * @note 
    448            *   - This function must be used only when both PLL2 and PLL3 are disabled.
    449            *   - This function applies only to STM32 Connectivity line devices.
    450            * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
    451            *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
    452            * @retval None
    453            */

   \                                 In section .text, align 2, keep-with-next
    454          void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
    455          {
    456            uint32_t tmpreg = 0;
   \                     RCC_PREDIV2Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    457          
    458            /* Check the parameters */
    459            //assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
    460          
    461            tmpreg = RCC->CFGR2;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    462            /* Clear PREDIV2[3:0] bits */
    463            tmpreg &= ~CFGR2_PREDIV2;
   \   00000008   0xF031 0x01F0      BICS     R1,R1,#0xF0
    464            /* Set the PREDIV2 division factor */
    465            tmpreg |= RCC_PREDIV2_Div;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    466            /* Store the new value */
    467            RCC->CFGR2 = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    468          }
   \   00000014   0x4770             BX       LR               ;; return
    469          
    470          /**
    471            * @brief  Configures the PLL2 multiplication factor.
    472            * @note
    473            *   - This function must be used only when the PLL2 is disabled.
    474            *   - This function applies only to STM32 Connectivity line devices.
    475            * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
    476            *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
    477            * @retval None
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
    480          {
    481            uint32_t tmpreg = 0;
   \                     RCC_PLL2Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    482          
    483            /* Check the parameters */
    484            //assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
    485          
    486            tmpreg = RCC->CFGR2;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    487            /* Clear PLL2Mul[3:0] bits */
    488            tmpreg &= ~CFGR2_PLL2MUL;
   \   00000008   0xF431 0x6170      BICS     R1,R1,#0xF00
    489            /* Set the PLL2 configuration bits */
    490            tmpreg |= RCC_PLL2Mul;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    491            /* Store the new value */
    492            RCC->CFGR2 = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    493          }
   \   00000014   0x4770             BX       LR               ;; return
    494          
    495          
    496          /**
    497            * @brief  Enables or disables the PLL2.
    498            * @note 
    499            *   - The PLL2 can not be disabled if it is used indirectly as system clock
    500            *     (i.e. it is used as PLL clock entry that is used as System clock).
    501            *   - This function applies only to STM32 Connectivity line devices.
    502            * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
    503            * @retval None
    504            */

   \                                 In section .text, align 2, keep-with-next
    505          void RCC_PLL2Cmd(FunctionalState NewState)
    506          {
    507            /* Check the parameters */
    508            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    509          
    510            *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
   \                     RCC_PLL2Cmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_9  ;; 0x42420068
   \   00000006   0x6008             STR      R0,[R1, #+0]
    511          }
   \   00000008   0x4770             BX       LR               ;; return
    512          
    513          
    514          /**
    515            * @brief  Configures the PLL3 multiplication factor.
    516            * @note 
    517            *   - This function must be used only when the PLL3 is disabled.
    518            *   - This function applies only to STM32 Connectivity line devices.
    519            * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
    520            *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
    521            * @retval None
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
    524          {
    525            uint32_t tmpreg = 0;
   \                     RCC_PLL3Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    526          
    527            /* Check the parameters */
    528            //assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
    529          
    530            tmpreg = RCC->CFGR2;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    531            /* Clear PLL3Mul[3:0] bits */
    532            tmpreg &= ~CFGR2_PLL3MUL;
   \   00000008   0xF431 0x4170      BICS     R1,R1,#0xF000
    533            /* Set the PLL3 configuration bits */
    534            tmpreg |= RCC_PLL3Mul;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    535            /* Store the new value */
    536            RCC->CFGR2 = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0x4002102c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    537          }
   \   00000014   0x4770             BX       LR               ;; return
    538          
    539          
    540          /**
    541            * @brief  Enables or disables the PLL3.
    542            * @note   This function applies only to STM32 Connectivity line devices.
    543            * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
    544            * @retval None
    545            */

   \                                 In section .text, align 2, keep-with-next
    546          void RCC_PLL3Cmd(FunctionalState NewState)
    547          {
    548            /* Check the parameters */
    549          
    550            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    551            *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
   \                     RCC_PLL3Cmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_10  ;; 0x42420070
   \   00000006   0x6008             STR      R0,[R1, #+0]
    552          }
   \   00000008   0x4770             BX       LR               ;; return
    553          #endif /* STM32F10X_CL */
    554          
    555          /**
    556            * @brief  Configures the system clock (SYSCLK).
    557            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    558            *   This parameter can be one of the following values:
    559            *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
    560            *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
    561            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
    562            * @retval None
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    565          {
    566            uint32_t tmpreg = 0;
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    567            /* Check the parameters */
    568            //assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    569            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    570            /* Clear SW[1:0] bits */
    571            tmpreg &= CFGR_SW_Mask;
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0089             LSLS     R1,R1,#+2
    572            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    573            tmpreg |= RCC_SYSCLKSource;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    574            /* Store the new value */
    575            RCC->CFGR = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    576          }
   \   00000014   0x4770             BX       LR               ;; return
    577          
    578          /**
    579            * @brief  Returns the clock source used as system clock.
    580            * @param  None
    581            * @retval The clock source used as system clock. The returned value can
    582            *   be one of the following:
    583            *     - 0x00: HSI used as system clock
    584            *     - 0x04: HSE used as system clock
    585            *     - 0x08: PLL used as system clock
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          uint8_t RCC_GetSYSCLKSource(void)
    588          {
    589            return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40021004
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000000A   0x4770             BX       LR               ;; return
    590          }
    591          
    592          /**
    593            * @brief  Configures the AHB clock (HCLK).
    594            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    595            *   the system clock (SYSCLK).
    596            *   This parameter can be one of the following values:
    597            *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    598            *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    599            *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    600            *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    601            *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    602            *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    603            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    604            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    605            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    606            * @retval None
    607            */

   \                                 In section .text, align 2, keep-with-next
    608          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    609          {
    610            uint32_t tmpreg = 0;
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    611            /* Check the parameters */
    612            //assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    613            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    614            /* Clear HPRE[3:0] bits */
    615            tmpreg &= CFGR_HPRE_Reset_Mask;
   \   00000008   0xF031 0x01F0      BICS     R1,R1,#0xF0
    616            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    617            tmpreg |= RCC_SYSCLK;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    618            /* Store the new value */
    619            RCC->CFGR = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    620          }
   \   00000014   0x4770             BX       LR               ;; return
    621          
    622          /**
    623            * @brief  Configures the Low Speed APB clock (PCLK1).
    624            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    625            *   the AHB clock (HCLK).
    626            *   This parameter can be one of the following values:
    627            *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
    628            *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
    629            *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
    630            *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
    631            *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    632            * @retval None
    633            */

   \                                 In section .text, align 2, keep-with-next
    634          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    635          {
    636            uint32_t tmpreg = 0;
   \                     RCC_PCLK1Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    637            /* Check the parameters */
    638            //assert_param(IS_RCC_PCLK(RCC_HCLK));
    639            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    640            /* Clear PPRE1[2:0] bits */
    641            tmpreg &= CFGR_PPRE1_Reset_Mask;
   \   00000008   0xF431 0x61E0      BICS     R1,R1,#0x700
    642            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    643            tmpreg |= RCC_HCLK;
   \   0000000C   0x4308             ORRS     R0,R0,R1
    644            /* Store the new value */
    645            RCC->CFGR = tmpreg;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    646          }
   \   00000014   0x4770             BX       LR               ;; return
    647          
    648          /**
    649            * @brief  Configures the High Speed APB clock (PCLK2).
    650            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    651            *   the AHB clock (HCLK).
    652            *   This parameter can be one of the following values:
    653            *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
    654            *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
    655            *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
    656            *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
    657            *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    658            * @retval None
    659            */

   \                                 In section .text, align 2, keep-with-next
    660          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    661          {
    662            uint32_t tmpreg = 0;
   \                     RCC_PCLK2Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    663            /* Check the parameters */
    664            //assert_param(IS_RCC_PCLK(RCC_HCLK));
    665            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable39_1  ;; 0x40021004
   \   00000006   0x6809             LDR      R1,[R1, #+0]
    666            /* Clear PPRE2[2:0] bits */
    667            tmpreg &= CFGR_PPRE2_Reset_Mask;
   \   00000008   0xF431 0x5160      BICS     R1,R1,#0x3800
    668            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    669            tmpreg |= RCC_HCLK << 3;
   \   0000000C   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
    670            /* Store the new value */
    671            RCC->CFGR = tmpreg;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40021004
   \   00000014   0x6001             STR      R1,[R0, #+0]
    672          }
   \   00000016   0x4770             BX       LR               ;; return
    673          
    674          /**
    675            * @brief  Enables or disables the specified RCC interrupts.
    676            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
    677            * 
    678            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
    679            *   of the following values        
    680            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    681            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    682            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    683            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    684            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    685            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
    686            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
    687            * 
    688            *   For @b other_STM32_devices, this parameter can be any combination of the 
    689            *   following values        
    690            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    691            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    692            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    693            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    694            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    695            *       
    696            * @param  NewState: new state of the specified RCC interrupts.
    697            *   This parameter can be: ENABLE or DISABLE.
    698            * @retval None
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
    701          {
    702            /* Check the parameters */
    703            //assert_param(IS_RCC_IT(RCC_IT));
    704            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    705            if (NewState != DISABLE)
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD007             BEQ.N    ??RCC_ITConfig_0
    706            {
    707              /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    708              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable39_11  ;; 0x40021009
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x4308             ORRS     R0,R0,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable39_11  ;; 0x40021009
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   \   00000014   0xE007             B.N      ??RCC_ITConfig_1
    709            }
    710            else
    711            {
    712              /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    713              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable39_11  ;; 0x40021009
   \   0000001A   0x7809             LDRB     R1,[R1, #+0]
   \   0000001C   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable39_11  ;; 0x40021009
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    714            }
    715          }
   \                     ??RCC_ITConfig_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    716          
    717          #ifndef STM32F10X_CL
    718          /**
    719            * @brief  Configures the USB clock (USBCLK).
    720            * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
    721            *   derived from the PLL output.
    722            *   This parameter can be one of the following values:
    723            *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
    724            *                                     clock source
    725            *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
    726            * @retval None
    727            */
    728          void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
    729          {
    730            /* Check the parameters */
    731            //assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
    732          
    733            *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
    734          }
    735          #else
    736          /**
    737            * @brief  Configures the USB OTG FS clock (OTGFSCLK).
    738            *   This function applies only to STM32 Connectivity line devices.
    739            * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
    740            *   This clock is derived from the PLL output.
    741            *   This parameter can be one of the following values:
    742            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    743            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    744            * @retval None
    745            */

   \                                 In section .text, align 2, keep-with-next
    746          void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
    747          {
    748            /* Check the parameters */
    749            //assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
    750          
    751            *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
   \                     RCC_OTGFSCLKConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_12  ;; 0x424200d8
   \   00000002   0x6008             STR      R0,[R1, #+0]
    752          }
   \   00000004   0x4770             BX       LR               ;; return
    753          #endif /* STM32F10X_CL */ 
    754          
    755          /**
    756            * @brief  Configures the ADC clock (ADCCLK).
    757            * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
    758            *   the APB2 clock (PCLK2).
    759            *   This parameter can be one of the following values:
    760            *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
    761            *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
    762            *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
    763            *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
    764            * @retval None
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
    767          {
    768            uint32_t tmpreg = 0;
   \                     RCC_ADCCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    769            /* Check the parameters */
    770            //assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
    771            tmpreg = RCC->CFGR;
   \   00000002   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   00000004   0x6809             LDR      R1,[R1, #+0]
    772            /* Clear ADCPRE[1:0] bits */
    773            tmpreg &= CFGR_ADCPRE_Reset_Mask;
   \   00000006   0xF431 0x4140      BICS     R1,R1,#0xC000
    774            /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
    775            tmpreg |= RCC_PCLK2;
   \   0000000A   0x4308             ORRS     R0,R0,R1
    776            /* Store the new value */
    777            RCC->CFGR = tmpreg;
   \   0000000C   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    778          }
   \   00000010   0x4770             BX       LR               ;; return
    779          
    780          #ifdef STM32F10X_CL
    781          /**
    782            * @brief  Configures the I2S2 clock source(I2S2CLK).
    783            * @note
    784            *   - This function must be called before enabling I2S2 APB clock.
    785            *   - This function applies only to STM32 Connectivity line devices.
    786            * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
    787            *   This parameter can be one of the following values:
    788            *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
    789            *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
    790            * @retval None
    791            */

   \                                 In section .text, align 2, keep-with-next
    792          void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
    793          {
    794            /* Check the parameters */
    795            //assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
    796          
    797            *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
   \                     RCC_I2S2CLKConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_13  ;; 0x424205c4
   \   00000002   0x6008             STR      R0,[R1, #+0]
    798          }
   \   00000004   0x4770             BX       LR               ;; return
    799          
    800          /**
    801            * @brief  Configures the I2S3 clock source(I2S2CLK).
    802            * @note
    803            *   - This function must be called before enabling I2S3 APB clock.
    804            *   - This function applies only to STM32 Connectivity line devices.
    805            * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
    806            *   This parameter can be one of the following values:
    807            *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
    808            *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
    809            * @retval None
    810            */

   \                                 In section .text, align 2, keep-with-next
    811          void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
    812          {
    813            /* Check the parameters */
    814            //assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
    815          
    816            *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
   \                     RCC_I2S3CLKConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_14  ;; 0x424205c8
   \   00000002   0x6008             STR      R0,[R1, #+0]
    817          }
   \   00000004   0x4770             BX       LR               ;; return
    818          #endif /* STM32F10X_CL */
    819          
    820          /**
    821            * @brief  Configures the External Low Speed oscillator (LSE).
    822            * @param  RCC_LSE: specifies the new state of the LSE.
    823            *   This parameter can be one of the following values:
    824            *     @arg RCC_LSE_OFF: LSE oscillator OFF
    825            *     @arg RCC_LSE_ON: LSE oscillator ON
    826            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    827            * @retval None
    828            */

   \                                 In section .text, align 2, keep-with-next
    829          void RCC_LSEConfig(uint8_t RCC_LSE)
    830          {
    831            /* Check the parameters */
    832            //assert_param(IS_RCC_LSE(RCC_LSE));
    833            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    834            /* Reset LSEON bit */
    835            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \                     RCC_LSEConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable39_15  ;; 0x40021020
   \   00000004   0x7011             STRB     R1,[R2, #+0]
    836            /* Reset LSEBYP bit */
    837            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable39_15  ;; 0x40021020
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
    838            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    839            switch(RCC_LSE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD002             BEQ.N    ??RCC_LSEConfig_0
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD004             BEQ.N    ??RCC_LSEConfig_1
   \   00000016   0xE007             B.N      ??RCC_LSEConfig_2
    840            {
    841              case RCC_LSE_ON:
    842                /* Set LSEON bit */
    843                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
   \                     ??RCC_LSEConfig_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable39_15  ;; 0x40021020
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    844                break;
   \   0000001E   0xE003             B.N      ??RCC_LSEConfig_3
    845                
    846              case RCC_LSE_Bypass:
    847                /* Set LSEBYP and LSEON bits */
    848                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
   \                     ??RCC_LSEConfig_1: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0x....             LDR.N    R1,??DataTable39_15  ;; 0x40021020
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    849                break;            
   \   00000026   0xE7FF             B.N      ??RCC_LSEConfig_3
    850                
    851              default:
    852                break;      
    853            }
    854          }
   \                     ??RCC_LSEConfig_2: (+1)
   \                     ??RCC_LSEConfig_3: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    855          
    856          /**
    857            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    858            * @note   LSI can not be disabled if the IWDG is running.
    859            * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
    860            * @retval None
    861            */

   \                                 In section .text, align 2, keep-with-next
    862          void RCC_LSICmd(FunctionalState NewState)
    863          {
    864            /* Check the parameters */
    865            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    866            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable39_16  ;; 0x42420480
   \   00000004   0x6008             STR      R0,[R1, #+0]
    867          }
   \   00000006   0x4770             BX       LR               ;; return
    868          
    869          /**
    870            * @brief  Configures the RTC clock (RTCCLK).
    871            * @note   Once the RTC clock is selected it can't be changed unless the Backup domain is reset.
    872            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    873            *   This parameter can be one of the following values:
    874            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    875            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    876            *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
    877            * @retval None
    878            */

   \                                 In section .text, align 2, keep-with-next
    879          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
    880          {
    881            /* Check the parameters */
    882            //assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
    883            /* Select the RTC clock source */
    884            RCC->BDCR |= RCC_RTCCLKSource;
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_15  ;; 0x40021020
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x4308             ORRS     R0,R0,R1
   \   00000006   0x....             LDR.N    R1,??DataTable39_15  ;; 0x40021020
   \   00000008   0x6008             STR      R0,[R1, #+0]
    885          }
   \   0000000A   0x4770             BX       LR               ;; return
    886          
    887          /**
    888            * @brief  Enables or disables the RTC clock.
    889            * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
    890            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
    891            * @retval None
    892            */

   \                                 In section .text, align 2, keep-with-next
    893          void RCC_RTCCLKCmd(FunctionalState NewState)
    894          {
    895            /* Check the parameters */
    896            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    897            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable39_17  ;; 0x4242043c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    898          }
   \   00000006   0x4770             BX       LR               ;; return
    899          
    900          /**
    901            * @brief  Returns the frequencies of different on chip clocks.
    902            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
    903            *         the clocks frequencies.
    904            * @note   The result of this function could be not correct when using 
    905            *         fractional value for HSE crystal.  
    906            * @retval None
    907            */

   \                                 In section .text, align 2, keep-with-next
    908          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    909          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    910            uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2100             MOVS     R1,#+0
    911          
    912          #ifdef  STM32F10X_CL
    913            uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2100             MOVS     R1,#+0
    914          #endif /* STM32F10X_CL */
    915          
    916          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    917            uint32_t prediv1factor = 0;
    918          #endif
    919              
    920            /* Get SYSCLK source -------------------------------------------------------*/
    921            tmp = RCC->CFGR & CFGR_SWS_Mask;
   \   00000012   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF011 0x010C      ANDS     R1,R1,#0xC
    922            
    923            switch (tmp)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD004             BEQ.N    ??RCC_GetClocksFreq_0
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xD005             BEQ.N    ??RCC_GetClocksFreq_1
   \   00000022   0x2908             CMP      R1,#+8
   \   00000024   0xD006             BEQ.N    ??RCC_GetClocksFreq_2
   \   00000026   0xE040             B.N      ??RCC_GetClocksFreq_3
    924            {
    925              case 0x00:  /* HSI used as system clock */
    926                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   00000028   0x....             LDR.N    R1,??DataTable39_18  ;; 0x7a1200
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    927                break;
   \   0000002C   0xE03F             B.N      ??RCC_GetClocksFreq_4
    928              case 0x04:  /* HSE used as system clock */
    929                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   0000002E   0x....             LDR.N    R1,??DataTable39_19  ;; 0x17d7840
   \   00000030   0x6001             STR      R1,[R0, #+0]
    930                break;
   \   00000032   0xE03C             B.N      ??RCC_GetClocksFreq_4
    931              case 0x08:  /* PLL used as system clock */
    932          
    933                /* Get PLL clock source and multiplication factor ----------------------*/
    934                pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   00000034   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF412 0x1270      ANDS     R2,R2,#0x3C0000
    935                pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
   \   0000003C   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xF411 0x3180      ANDS     R1,R1,#0x10000
    936                
    937          #ifndef STM32F10X_CL      
    938                pllmull = ( pllmull >> 18) + 2;
    939                
    940                if (pllsource == 0x00)
    941                {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
    942                  RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
    943                }
    944                else
    945                {
    946           #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    947                 prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
    948                 /* HSE oscillator clock selected as PREDIV1 clock entry */
    949                 RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
    950           #else
    951                  /* HSE selected as PLL clock entry */
    952                  if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
    953                  {/* HSE oscillator clock divided by 2 */
    954                    RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
    955                  }
    956                  else
    957                  {
    958                    RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
    959                  }
    960           #endif
    961                }
    962          #else
    963                pllmull = pllmull >> 18;
   \   00000044   0x0C92             LSRS     R2,R2,#+18
    964                
    965                if (pllmull != 0x0D)
   \   00000046   0x2A0D             CMP      R2,#+13
   \   00000048   0xD001             BEQ.N    ??RCC_GetClocksFreq_5
    966                {
    967                   pllmull += 2;
   \   0000004A   0x1C92             ADDS     R2,R2,#+2
   \   0000004C   0xE000             B.N      ??RCC_GetClocksFreq_6
    968                }
    969                else
    970                { /* PLL multiplication factor = PLL input clock * 6.5 */
    971                  pllmull = 13 / 2; 
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   0000004E   0x2206             MOVS     R2,#+6
    972                }
    973                      
    974                if (pllsource == 0x00)
   \                     ??RCC_GetClocksFreq_6: (+1)
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD103             BNE.N    ??RCC_GetClocksFreq_7
    975                {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
    976                  RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
   \   00000054   0x....             LDR.N    R1,??DataTable39_20  ;; 0x3d0900
   \   00000056   0x434A             MULS     R2,R1,R2
   \   00000058   0x6002             STR      R2,[R0, #+0]
   \   0000005A   0xE025             B.N      ??RCC_GetClocksFreq_8
    977                }
    978                else
    979                {/* PREDIV1 selected as PLL clock entry */
    980                  
    981                  /* Get PREDIV1 clock source and division factor */
    982                  prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
   \                     ??RCC_GetClocksFreq_7: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable39_5  ;; 0x4002102c
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF411 0x3180      ANDS     R1,R1,#0x10000
    983                  prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
   \   00000064   0x....             LDR.N    R3,??DataTable39_5  ;; 0x4002102c
   \   00000066   0x681B             LDR      R3,[R3, #+0]
   \   00000068   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   0000006C   0x1C5B             ADDS     R3,R3,#+1
    984                  
    985                  if (prediv1source == 0)
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD106             BNE.N    ??RCC_GetClocksFreq_9
    986                  { /* HSE oscillator clock selected as PREDIV1 clock entry */
    987                    RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
   \   00000072   0x....             LDR.N    R1,??DataTable39_19  ;; 0x17d7840
   \   00000074   0xFBB1 0xF1F3      UDIV     R1,R1,R3
   \   00000078   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000007C   0x6002             STR      R2,[R0, #+0]
   \   0000007E   0xE013             B.N      ??RCC_GetClocksFreq_8
    988                  }
    989                  else
    990                  {/* PLL2 clock selected as PREDIV1 clock entry */
    991                    
    992                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
    993                    prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
   \                     ??RCC_GetClocksFreq_9: (+1)
   \   00000080   0x....             LDR.N    R1,??DataTable39_5  ;; 0x4002102c
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \   00000088   0x1C49             ADDS     R1,R1,#+1
    994                    pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
   \   0000008A   0x....             LDR.N    R4,??DataTable39_5  ;; 0x4002102c
   \   0000008C   0x6824             LDR      R4,[R4, #+0]
   \   0000008E   0xF3C4 0x2403      UBFX     R4,R4,#+8,#+4
   \   00000092   0x1CA4             ADDS     R4,R4,#+2
    995                    RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
   \   00000094   0x....             LDR.N    R5,??DataTable39_19  ;; 0x17d7840
   \   00000096   0xFBB5 0xF1F1      UDIV     R1,R5,R1
   \   0000009A   0xFB04 0xF401      MUL      R4,R4,R1
   \   0000009E   0xFBB4 0xF1F3      UDIV     R1,R4,R3
   \   000000A2   0xFB02 0xF201      MUL      R2,R2,R1
   \   000000A6   0x6002             STR      R2,[R0, #+0]
    996                  }
    997                }
    998          #endif /* STM32F10X_CL */ 
    999                break;
   \                     ??RCC_GetClocksFreq_8: (+1)
   \   000000A8   0xE001             B.N      ??RCC_GetClocksFreq_4
   1000          
   1001              default:
   1002                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable39_18  ;; 0x7a1200
   \   000000AC   0x6001             STR      R1,[R0, #+0]
   1003                break;
   1004            }
   1005          
   1006            /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
   1007            /* Get HCLK prescaler */
   1008            tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   000000AE   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   1009            tmp = tmp >> 4;
   \   000000B6   0x0909             LSRS     R1,R1,#+4
   1010            presc = APBAHBPrescTable[tmp];
   \   000000B8   0x....             LDR.N    R2,??DataTable39_21
   \   000000BA   0x5C51             LDRB     R1,[R2, R1]
   1011            /* HCLK clock frequency */
   1012            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   000000BC   0x6802             LDR      R2,[R0, #+0]
   \   000000BE   0x40CA             LSRS     R2,R2,R1
   \   000000C0   0x6042             STR      R2,[R0, #+4]
   1013            /* Get PCLK1 prescaler */
   1014            tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
   \   000000C2   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0xF411 0x61E0      ANDS     R1,R1,#0x700
   1015            tmp = tmp >> 8;
   \   000000CA   0x0A09             LSRS     R1,R1,#+8
   1016            presc = APBAHBPrescTable[tmp];
   \   000000CC   0x....             LDR.N    R2,??DataTable39_21
   \   000000CE   0x5C51             LDRB     R1,[R2, R1]
   1017            /* PCLK1 clock frequency */
   1018            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000D0   0x6842             LDR      R2,[R0, #+4]
   \   000000D2   0x40CA             LSRS     R2,R2,R1
   \   000000D4   0x6082             STR      R2,[R0, #+8]
   1019            /* Get PCLK2 prescaler */
   1020            tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
   \   000000D6   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   000000D8   0x6809             LDR      R1,[R1, #+0]
   \   000000DA   0xF411 0x5160      ANDS     R1,R1,#0x3800
   1021            tmp = tmp >> 11;
   \   000000DE   0x0AC9             LSRS     R1,R1,#+11
   1022            presc = APBAHBPrescTable[tmp];
   \   000000E0   0x....             LDR.N    R2,??DataTable39_21
   \   000000E2   0x5C51             LDRB     R1,[R2, R1]
   1023            /* PCLK2 clock frequency */
   1024            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000E4   0x6842             LDR      R2,[R0, #+4]
   \   000000E6   0x40CA             LSRS     R2,R2,R1
   \   000000E8   0x60C2             STR      R2,[R0, #+12]
   1025            /* Get ADCCLK prescaler */
   1026            tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
   \   000000EA   0x....             LDR.N    R1,??DataTable39_1  ;; 0x40021004
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0xF411 0x4140      ANDS     R1,R1,#0xC000
   1027            tmp = tmp >> 14;
   \   000000F2   0x0B89             LSRS     R1,R1,#+14
   1028            presc = ADCPrescTable[tmp];
   \   000000F4   0x....             LDR.N    R2,??DataTable39_22
   \   000000F6   0x5C51             LDRB     R1,[R2, R1]
   1029            /* ADCCLK clock frequency */
   1030            RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
   \   000000F8   0x68C2             LDR      R2,[R0, #+12]
   \   000000FA   0xFBB2 0xF1F1      UDIV     R1,R2,R1
   \   000000FE   0x6101             STR      R1,[R0, #+16]
   1031          }
   \   00000100   0xBC30             POP      {R4,R5}
   \   00000102   0x4770             BX       LR               ;; return
   1032          
   1033          /**
   1034            * @brief  Enables or disables the AHB peripheral clock.
   1035            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1036            *   
   1037            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1038            *   of the following values:        
   1039            *     @arg RCC_AHBPeriph_DMA1
   1040            *     @arg RCC_AHBPeriph_DMA2
   1041            *     @arg RCC_AHBPeriph_SRAM
   1042            *     @arg RCC_AHBPeriph_FLITF
   1043            *     @arg RCC_AHBPeriph_CRC
   1044            *     @arg RCC_AHBPeriph_OTG_FS    
   1045            *     @arg RCC_AHBPeriph_ETH_MAC   
   1046            *     @arg RCC_AHBPeriph_ETH_MAC_Tx
   1047            *     @arg RCC_AHBPeriph_ETH_MAC_Rx
   1048            * 
   1049            *   For @b other_STM32_devices, this parameter can be any combination of the 
   1050            *   following values:        
   1051            *     @arg RCC_AHBPeriph_DMA1
   1052            *     @arg RCC_AHBPeriph_DMA2
   1053            *     @arg RCC_AHBPeriph_SRAM
   1054            *     @arg RCC_AHBPeriph_FLITF
   1055            *     @arg RCC_AHBPeriph_CRC
   1056            *     @arg RCC_AHBPeriph_FSMC
   1057            *     @arg RCC_AHBPeriph_SDIO
   1058            *   
   1059            * @note SRAM and FLITF clock can be disabled only during sleep mode.
   1060            * @param  NewState: new state of the specified peripheral clock.
   1061            *   This parameter can be: ENABLE or DISABLE.
   1062            * @retval None
   1063            */

   \                                 In section .text, align 2, keep-with-next
   1064          void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1065          {
   1066            /* Check the parameters */
   1067            //assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   1068            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1069          
   1070            if (NewState != DISABLE)
   \                     RCC_AHBPeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHBPeriphClockCmd_0
   1071            {
   1072              RCC->AHBENR |= RCC_AHBPeriph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_23  ;; 0x40021014
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_23  ;; 0x40021014
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_AHBPeriphClockCmd_1
   1073            }
   1074            else
   1075            {
   1076              RCC->AHBENR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_23  ;; 0x40021014
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_23  ;; 0x40021014
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1077            }
   1078          }
   \                     ??RCC_AHBPeriphClockCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1079          
   1080          /**
   1081            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1082            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1083            *   This parameter can be any combination of the following values:
   1084            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1085            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1086            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1087            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1088            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
   1089            *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
   1090            *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11     
   1091            * @param  NewState: new state of the specified peripheral clock.
   1092            *   This parameter can be: ENABLE or DISABLE.
   1093            * @retval None
   1094            */

   \                                 In section .text, align 2, keep-with-next
   1095          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1096          {
   1097            /* Check the parameters */
   1098            //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1099            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1100            if (NewState != DISABLE)
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB2PeriphClockCmd_0
   1101            {
   1102              RCC->APB2ENR |= RCC_APB2Periph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_24  ;; 0x40021018
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_24  ;; 0x40021018
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_APB2PeriphClockCmd_1
   1103            }
   1104            else
   1105            {
   1106              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_24  ;; 0x40021018
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_24  ;; 0x40021018
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1107            }
   1108          }
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1109          
   1110          /**
   1111            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1112            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1113            *   This parameter can be any combination of the following values:
   1114            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1115            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1116            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1117            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1118            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1119            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1120            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
   1121            *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14
   1122            * @param  NewState: new state of the specified peripheral clock.
   1123            *   This parameter can be: ENABLE or DISABLE.
   1124            * @retval None
   1125            */

   \                                 In section .text, align 2, keep-with-next
   1126          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1127          {
   1128            /* Check the parameters */
   1129            //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1130            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1131            if (NewState != DISABLE)
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB1PeriphClockCmd_0
   1132            {
   1133              RCC->APB1ENR |= RCC_APB1Periph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_25  ;; 0x4002101c
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_25  ;; 0x4002101c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_APB1PeriphClockCmd_1
   1134            }
   1135            else
   1136            {
   1137              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_25  ;; 0x4002101c
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_25  ;; 0x4002101c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1138            }
   1139          }
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1140          
   1141          #ifdef STM32F10X_CL
   1142          /**
   1143            * @brief  Forces or releases AHB peripheral reset.
   1144            * @note   This function applies only to STM32 Connectivity line devices.
   1145            * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
   1146            *   This parameter can be any combination of the following values:
   1147            *     @arg RCC_AHBPeriph_OTG_FS 
   1148            *     @arg RCC_AHBPeriph_ETH_MAC
   1149            * @param  NewState: new state of the specified peripheral reset.
   1150            *   This parameter can be: ENABLE or DISABLE.
   1151            * @retval None
   1152            */

   \                                 In section .text, align 2, keep-with-next
   1153          void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1154          {
   1155            /* Check the parameters */
   1156            //assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
   1157            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1158          
   1159            if (NewState != DISABLE)
   \                     RCC_AHBPeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHBPeriphResetCmd_0
   1160            {
   1161              RCC->AHBRSTR |= RCC_AHBPeriph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_26  ;; 0x40021028
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_26  ;; 0x40021028
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_AHBPeriphResetCmd_1
   1162            }
   1163            else
   1164            {
   1165              RCC->AHBRSTR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_26  ;; 0x40021028
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_26  ;; 0x40021028
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1166            }
   1167          }
   \                     ??RCC_AHBPeriphResetCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1168          #endif /* STM32F10X_CL */ 
   1169          
   1170          /**
   1171            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1172            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1173            *   This parameter can be any combination of the following values:
   1174            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1175            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1176            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1177            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1178            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
   1179            *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
   1180            *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11  
   1181            * @param  NewState: new state of the specified peripheral reset.
   1182            *   This parameter can be: ENABLE or DISABLE.
   1183            * @retval None
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1186          {
   1187            /* Check the parameters */
   1188            //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1189            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1190            if (NewState != DISABLE)
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB2PeriphResetCmd_0
   1191            {
   1192              RCC->APB2RSTR |= RCC_APB2Periph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_27  ;; 0x4002100c
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_27  ;; 0x4002100c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_APB2PeriphResetCmd_1
   1193            }
   1194            else
   1195            {
   1196              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_27  ;; 0x4002100c
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_27  ;; 0x4002100c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1197            }
   1198          }
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1199          
   1200          /**
   1201            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1202            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1203            *   This parameter can be any combination of the following values:
   1204            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1205            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1206            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1207            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1208            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1209            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1210            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
   1211            *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14  
   1212            * @param  NewState: new state of the specified peripheral clock.
   1213            *   This parameter can be: ENABLE or DISABLE.
   1214            * @retval None
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1217          {
   1218            /* Check the parameters */
   1219            //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1220            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1221            if (NewState != DISABLE)
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB1PeriphResetCmd_0
   1222            {
   1223              RCC->APB1RSTR |= RCC_APB1Periph;
   \   00000006   0x....             LDR.N    R1,??DataTable39_28  ;; 0x40021010
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable39_28  ;; 0x40021010
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??RCC_APB1PeriphResetCmd_1
   1224            }
   1225            else
   1226            {
   1227              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable39_28  ;; 0x40021010
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable39_28  ;; 0x40021010
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1228            }
   1229          }
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1230          
   1231          /**
   1232            * @brief  Forces or releases the Backup domain reset.
   1233            * @param  NewState: new state of the Backup domain reset.
   1234            *   This parameter can be: ENABLE or DISABLE.
   1235            * @retval None
   1236            */

   \                                 In section .text, align 2, keep-with-next
   1237          void RCC_BackupResetCmd(FunctionalState NewState)
   1238          {
   1239            /* Check the parameters */
   1240            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1241            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   \                     RCC_BackupResetCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable39_29  ;; 0x42420440
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1242          }
   \   00000006   0x4770             BX       LR               ;; return
   1243          
   1244          /**
   1245            * @brief  Enables or disables the Clock Security System.
   1246            * @param  NewState: new state of the Clock Security System..
   1247            *   This parameter can be: ENABLE or DISABLE.
   1248            * @retval None
   1249            */

   \                                 In section .text, align 2, keep-with-next
   1250          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
   1251          {
   1252            /* Check the parameters */
   1253            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1254            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable39_30  ;; 0x4242004c
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1255          }
   \   00000006   0x4770             BX       LR               ;; return
   1256          
   1257          /**
   1258            * @brief  Selects the clock source to output on MCO pin.
   1259            * @param  RCC_MCO: specifies the clock source to output.
   1260            *   
   1261            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1262            *   following values:       
   1263            *     @arg RCC_MCO_NoClock: No clock selected
   1264            *     @arg RCC_MCO_SYSCLK: System clock selected
   1265            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1266            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1267            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1268            *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected                     
   1269            *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected   
   1270            *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected  
   1271            *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected 
   1272            * 
   1273            *   For  @b other_STM32_devices, this parameter can be one of the following values:        
   1274            *     @arg RCC_MCO_NoClock: No clock selected
   1275            *     @arg RCC_MCO_SYSCLK: System clock selected
   1276            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1277            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1278            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1279            *   
   1280            * @retval None
   1281            */

   \                                 In section .text, align 2, keep-with-next
   1282          void RCC_MCOConfig(uint8_t RCC_MCO)
   1283          {
   1284            /* Check the parameters */
   1285            //assert_param(IS_RCC_MCO(RCC_MCO));
   1286          
   1287            /* Perform Byte access to MCO bits to select the MCO source */
   1288            *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
   \                     RCC_MCOConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_31  ;; 0x40021007
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   1289          }
   \   00000004   0x4770             BX       LR               ;; return
   1290          
   1291          /**
   1292            * @brief  Checks whether the specified RCC flag is set or not.
   1293            * @param  RCC_FLAG: specifies the flag to check.
   1294            *   
   1295            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1296            *   following values:
   1297            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1298            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1299            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1300            *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready      
   1301            *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready                           
   1302            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1303            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1304            *     @arg RCC_FLAG_PINRST: Pin reset
   1305            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1306            *     @arg RCC_FLAG_SFTRST: Software reset
   1307            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1308            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1309            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1310            * 
   1311            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1312            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1313            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1314            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1315            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1316            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1317            *     @arg RCC_FLAG_PINRST: Pin reset
   1318            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1319            *     @arg RCC_FLAG_SFTRST: Software reset
   1320            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1321            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1322            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1323            *   
   1324            * @retval The new state of RCC_FLAG (SET or RESET).
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1327          {
   1328            uint32_t tmp = 0;
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1329            uint32_t statusreg = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1330            FlagStatus bitstatus = RESET;
   \   00000004   0x2100             MOVS     R1,#+0
   1331            /* Check the parameters */
   1332            //assert_param(IS_RCC_FLAG(RCC_FLAG));
   1333          
   1334            /* Get the RCC register index */
   1335            tmp = RCC_FLAG >> 5;
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0949             LSRS     R1,R1,#+5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   1336            if (tmp == 1)               /* The flag to check is in CR register */
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD102             BNE.N    ??RCC_GetFlagStatus_0
   1337            {
   1338              statusreg = RCC->CR;
   \   00000012   0x....             LDR.N    R1,??DataTable39  ;; 0x40021000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xE006             B.N      ??RCC_GetFlagStatus_1
   1339            }
   1340            else if (tmp == 2)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD102             BNE.N    ??RCC_GetFlagStatus_2
   1341            {
   1342              statusreg = RCC->BDCR;
   \   0000001C   0x....             LDR.N    R1,??DataTable39_15  ;; 0x40021020
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xE001             B.N      ??RCC_GetFlagStatus_1
   1343            }
   1344            else                       /* The flag to check is in CSR register */
   1345            {
   1346              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable39_32  ;; 0x40021024
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   1347            }
   1348          
   1349            /* Get the flag position */
   1350            tmp = RCC_FLAG & FLAG_Mask;
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xF010 0x001F      ANDS     R0,R0,#0x1F
   1351            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   0000002C   0x40C1             LSRS     R1,R1,R0
   \   0000002E   0x07C8             LSLS     R0,R1,#+31
   \   00000030   0xD501             BPL.N    ??RCC_GetFlagStatus_3
   1352            {
   1353              bitstatus = SET;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B.N      ??RCC_GetFlagStatus_4
   1354            }
   1355            else
   1356            {
   1357              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   1358            }
   1359          
   1360            /* Return the flag status */
   1361            return bitstatus;
   \                     ??RCC_GetFlagStatus_4: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x4770             BX       LR               ;; return
   1362          }
   1363          
   1364          /**
   1365            * @brief  Clears the RCC reset flags.
   1366            * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
   1367            *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   1368            * @param  None
   1369            * @retval None
   1370            */

   \                                 In section .text, align 2, keep-with-next
   1371          void RCC_ClearFlag(void)
   1372          {
   1373            /* Set RMVF bit to clear the reset flags */
   1374            RCC->CSR |= CSR_RMVF_Set;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_32  ;; 0x40021024
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000008   0x....             LDR.N    R1,??DataTable39_32  ;; 0x40021024
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1375          }
   \   0000000C   0x4770             BX       LR               ;; return
   1376          
   1377          /**
   1378            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1379            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1380            *   
   1381            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1382            *   following values:
   1383            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1384            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1385            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1386            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1387            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1388            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1389            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1390            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1391            * 
   1392            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1393            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1394            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1395            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1396            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1397            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1398            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1399            *   
   1400            * @retval The new state of RCC_IT (SET or RESET).
   1401            */

   \                                 In section .text, align 2, keep-with-next
   1402          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1403          {
   1404            ITStatus bitstatus = RESET;
   \                     RCC_GetITStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1405            /* Check the parameters */
   1406            //assert_param(IS_RCC_GET_IT(RCC_IT));
   1407          
   1408            /* Check the status of the specified RCC interrupt */
   1409            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable39_4  ;; 0x40021008
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4201             TST      R1,R0
   \   0000000A   0xD001             BEQ.N    ??RCC_GetITStatus_0
   1410            {
   1411              bitstatus = SET;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??RCC_GetITStatus_1
   1412            }
   1413            else
   1414            {
   1415              bitstatus = RESET;
   \                     ??RCC_GetITStatus_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   1416            }
   1417          
   1418            /* Return the RCC_IT status */
   1419            return  bitstatus;
   \                     ??RCC_GetITStatus_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1420          }
   1421          
   1422          /**
   1423            * @brief  Clears the RCC's interrupt pending bits.
   1424            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1425            *   
   1426            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1427            *   of the following values:
   1428            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1429            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1430            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1431            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1432            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1433            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1434            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1435            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1436            * 
   1437            *   For @b other_STM32_devices, this parameter can be any combination of the
   1438            *   following values:        
   1439            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1440            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1441            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1442            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1443            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1444            *   
   1445            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1446            * @retval None
   1447            */

   \                                 In section .text, align 2, keep-with-next
   1448          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1449          {
   1450            /* Check the parameters */
   1451            //assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   1452          
   1453            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1454               pending bits */
   1455            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable39_33  ;; 0x4002100a
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   1456          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \   00000000   0x40021004         DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_2:
   \   00000000   0xF0FF0000         DC32     0xf0ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_3:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_4:
   \   00000000   0x40021008         DC32     0x40021008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_5:
   \   00000000   0x4002102C         DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_6:
   \   00000000   0x42420000         DC32     0x42420000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_7:
   \   00000000   0x42420060         DC32     0x42420060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_8:
   \   00000000   0xFFFEFFF0         DC32     0xfffefff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_9:
   \   00000000   0x42420068         DC32     0x42420068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_10:
   \   00000000   0x42420070         DC32     0x42420070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_11:
   \   00000000   0x40021009         DC32     0x40021009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_12:
   \   00000000   0x424200D8         DC32     0x424200d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_13:
   \   00000000   0x424205C4         DC32     0x424205c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_14:
   \   00000000   0x424205C8         DC32     0x424205c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_15:
   \   00000000   0x40021020         DC32     0x40021020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_16:
   \   00000000   0x42420480         DC32     0x42420480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_17:
   \   00000000   0x4242043C         DC32     0x4242043c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_18:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_19:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_20:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_21:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_22:
   \   00000000   0x........         DC32     ADCPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_23:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_24:
   \   00000000   0x40021018         DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_25:
   \   00000000   0x4002101C         DC32     0x4002101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_26:
   \   00000000   0x40021028         DC32     0x40021028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_27:
   \   00000000   0x4002100C         DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_28:
   \   00000000   0x40021010         DC32     0x40021010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_29:
   \   00000000   0x42420440         DC32     0x42420440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_30:
   \   00000000   0x4242004C         DC32     0x4242004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_31:
   \   00000000   0x40021007         DC32     0x40021007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_32:
   \   00000000   0x40021024         DC32     0x40021024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_33:
   \   00000000   0x4002100A         DC32     0x4002100a
   1457          
   1458          /**
   1459            * @}
   1460            */
   1461          
   1462          /**
   1463            * @}
   1464            */
   1465          
   1466          /**
   1467            * @}
   1468            */
   1469          
   1470          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   RCC_ADCCLKConfig
       0   RCC_AHBPeriphClockCmd
       0   RCC_AHBPeriphResetCmd
       0   RCC_APB1PeriphClockCmd
       0   RCC_APB1PeriphResetCmd
       0   RCC_APB2PeriphClockCmd
       0   RCC_APB2PeriphResetCmd
       0   RCC_AdjustHSICalibrationValue
       0   RCC_BackupResetCmd
       0   RCC_ClearFlag
       0   RCC_ClearITPendingBit
       0   RCC_ClockSecuritySystemCmd
       0   RCC_DeInit
       8   RCC_GetClocksFreq
       0   RCC_GetFlagStatus
       0   RCC_GetITStatus
       0   RCC_GetSYSCLKSource
       0   RCC_HCLKConfig
       0   RCC_HSEConfig
       0   RCC_HSICmd
       0   RCC_I2S2CLKConfig
       0   RCC_I2S3CLKConfig
       0   RCC_ITConfig
       0   RCC_LSEConfig
       0   RCC_LSICmd
       0   RCC_MCOConfig
       0   RCC_OTGFSCLKConfig
       0   RCC_PCLK1Config
       0   RCC_PCLK2Config
       0   RCC_PLL2Cmd
       0   RCC_PLL2Config
       0   RCC_PLL3Cmd
       0   RCC_PLL3Config
       0   RCC_PLLCmd
       0   RCC_PLLConfig
       0   RCC_PREDIV1Config
       0   RCC_PREDIV2Config
       0   RCC_RTCCLKCmd
       0   RCC_RTCCLKConfig
       0   RCC_SYSCLKConfig
       8   RCC_WaitForHSEStartUp
         8   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_11
       4  ??DataTable39_12
       4  ??DataTable39_13
       4  ??DataTable39_14
       4  ??DataTable39_15
       4  ??DataTable39_16
       4  ??DataTable39_17
       4  ??DataTable39_18
       4  ??DataTable39_19
       4  ??DataTable39_2
       4  ??DataTable39_20
       4  ??DataTable39_21
       4  ??DataTable39_22
       4  ??DataTable39_23
       4  ??DataTable39_24
       4  ??DataTable39_25
       4  ??DataTable39_26
       4  ??DataTable39_27
       4  ??DataTable39_28
       4  ??DataTable39_29
       4  ??DataTable39_3
       4  ??DataTable39_30
       4  ??DataTable39_31
       4  ??DataTable39_32
       4  ??DataTable39_33
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
       4  ADCPrescTable
      16  APBAHBPrescTable
      18  RCC_ADCCLKConfig
      32  RCC_AHBPeriphClockCmd
      32  RCC_AHBPeriphResetCmd
      32  RCC_APB1PeriphClockCmd
      32  RCC_APB1PeriphResetCmd
      32  RCC_APB2PeriphClockCmd
      32  RCC_APB2PeriphResetCmd
      26  RCC_AdjustHSICalibrationValue
       8  RCC_BackupResetCmd
      14  RCC_ClearFlag
       6  RCC_ClearITPendingBit
       8  RCC_ClockSecuritySystemCmd
     120  RCC_DeInit
     260  RCC_GetClocksFreq
      60  RCC_GetFlagStatus
      22  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      22  RCC_HCLKConfig
      84  RCC_HSEConfig
      10  RCC_HSICmd
       6  RCC_I2S2CLKConfig
       6  RCC_I2S3CLKConfig
      40  RCC_ITConfig
      42  RCC_LSEConfig
       8  RCC_LSICmd
       6  RCC_MCOConfig
       6  RCC_OTGFSCLKConfig
      22  RCC_PCLK1Config
      24  RCC_PCLK2Config
      10  RCC_PLL2Cmd
      22  RCC_PLL2Config
      10  RCC_PLL3Cmd
      22  RCC_PLL3Config
      10  RCC_PLLCmd
      24  RCC_PLLConfig
      26  RCC_PREDIV1Config
      22  RCC_PREDIV2Config
       8  RCC_RTCCLKCmd
      12  RCC_RTCCLKConfig
      22  RCC_SYSCLKConfig
      56  RCC_WaitForHSEStartUp

 
    20 bytes in section .data
 1 402 bytes in section .text
 
 1 402 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
