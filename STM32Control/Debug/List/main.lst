###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       22/Nov/2021  19:53:32
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\pnu3\Desktop\Embedded-main\user\main.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EWA2EF.tmp
#        (C:\Users\pnu3\Desktop\Embedded-main\user\main.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\List -o
#        C:\Users\pnu3\Desktop\Embedded-main\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\pnu3\Desktop\Embedded-main\Libraries\CMSIS\DeviceSupport\
#        -I C:\Users\pnu3\Desktop\Embedded-main\Libraries\LCD\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\Embedded-main\user\inc\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\user\ -I
#        C:\Users\pnu3\Desktop\Embedded-main\Libraries\DHT11\ -Ol -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\Users\pnu3\Desktop\Embedded-main\Debug\List\main.lst
#    Object file  =  C:\Users\pnu3\Desktop\Embedded-main\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu3\Desktop\Embedded-main\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      2          #include "stm32f10x_exti.h"
      3          #include "stm32f10x_gpio.h"
      4          #include "stm32f10x_usart.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "DHT11.h"
      7          #include "misc.h"
      8          
      9          #define DHT11_DATA_GPIO_Port    GPIOA
     10          #define DHT11_DATA_Pin          GPIO_Pin_14

   \                                 In section .bss, align 4
     11          DHT11DATA dht11_data;
   \                     dht11_data:
   \   00000000                      DS8 8
     12          
     13          /* function prototype */
     14          void RCC_Configure(void);
     15          void GPIO_Configure(void);
     16          void EXTI_Configure(void);
     17          void Init_USART(void);
     18          void NVIC_Configure(void);
     19          
     20          void EXTI15_10_IRQHandler(void);
     21          
     22          void Delay(void);
     23          
     24          void sendDataUART1(uint16_t data);
     25          void sendDataUART2(uint16_t data);
     26          

   \                                 In section .text, align 2, keep-with-next
     27          void Delay_us(uint32_t us){  
     28                          if(us>1){
   \                     Delay_us: (+1)
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD307             BCC.N    ??Delay_us_0
     29                                   uint32_t count=us*7200;
   \   00000004   0xF44F 0x51E1      MOV      R1,#+7200
   \   00000008   0x4348             MULS     R0,R1,R0
     30                                   while(count--); 
   \                     ??Delay_us_1: (+1)
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x1E48             SUBS     R0,R1,#+1
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD1FB             BNE.N    ??Delay_us_1
   \   00000012   0xE004             B.N      ??Delay_us_2
     31                           }else{
     32                                   uint32_t count=2;
   \                     ??Delay_us_0: (+1)
   \   00000014   0x2102             MOVS     R1,#+2
     33                                   while(count--); 
   \                     ??Delay_us_3: (+1)
   \   00000016   0x0008             MOVS     R0,R1
   \   00000018   0x1E41             SUBS     R1,R0,#+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1FB             BNE.N    ??Delay_us_3
     34                            }
     35          }
   \                     ??Delay_us_2: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
     36          

   \                                 In section .text, align 2, keep-with-next
     37          uint8_t DHT11ReadData(DHT11DATA *pData)
     38          {
   \                     DHT11ReadData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
     39              uint32_t tmp;
     40              uint32_t i;
     41              uint16_t data[DHT11_DATA_BITS] = {0,};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2150             MOVS     R1,#+80
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
     42           
     43              pData->humid = pData->temp = pData->checksum = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7120             STRB     R0,[R4, #+4]
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x8060             STRH     R0,[R4, #+2]
   \   00000016   0x8860             LDRH     R0,[R4, #+2]
   \   00000018   0x8020             STRH     R0,[R4, #+0]
     44              // set DHT11_DATA Pin for output
     45              tmp = DHT11_DATA_GPIO_Port->CRH;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0x40010804
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
     46              tmp &= 0x0FFFFFFF;
   \   00000020   0xF020 0x4070      BIC      R0,R0,#0xF0000000
     47              tmp |= 0x20000000;
   \   00000024   0xF050 0x5000      ORRS     R0,R0,#0x20000000
     48              DHT11_DATA_GPIO_Port->CRH = tmp;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40010804
   \   0000002C   0x6008             STR      R0,[R1, #+0]
     49           
     50              // transmit start signal
     51              DHT11_DATA_GPIO_Port->BSRR = DHT11_DATA_Pin;
   \   0000002E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x40010810
   \   00000036   0x6008             STR      R0,[R1, #+0]
     52              Delay_us(250);
   \   00000038   0x20FA             MOVS     R0,#+250
   \   0000003A   0x.... 0x....      BL       Delay_us
     53              DHT11_DATA_GPIO_Port->BRR = DHT11_DATA_Pin;
   \   0000003E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x40010814
   \   00000046   0x6008             STR      R0,[R1, #+0]
     54              Delay_us(1);
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       Delay_us
     55              DHT11_DATA_GPIO_Port->BSRR = DHT11_DATA_Pin;
   \   0000004E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x40010810
   \   00000056   0x6008             STR      R0,[R1, #+0]
     56           
     57              // set DHT11_DATA Pin for  pull-up input
     58              tmp = DHT11_DATA_GPIO_Port->CRH;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0x40010804
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
     59              DHT11_DATA_GPIO_Port->ODR = DHT11_DATA_Pin;
   \   0000005E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable10_4  ;; 0x4001080c
   \   00000066   0x6011             STR      R1,[R2, #+0]
     60              tmp &= 0x0FFFFFFF;
   \   00000068   0xF020 0x4070      BIC      R0,R0,#0xF0000000
     61              tmp |= 0x80000000;
   \   0000006C   0xF050 0x4000      ORRS     R0,R0,#0x80000000
     62              DHT11_DATA_GPIO_Port->CRH = tmp;
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40010804
   \   00000074   0x6008             STR      R0,[R1, #+0]
     63           
     64              // wait for DHT11's reply
     65              if(WaitForLow(DHT11_MAX_REPLY_TIME) > DHT11_MAX_REPLY_TIME)
   \   00000076   0x2064             MOVS     R0,#+100
   \   00000078   0x.... 0x....      BL       WaitForLow
   \   0000007C   0x2865             CMP      R0,#+101
   \   0000007E   0xD301             BCC.N    ??DHT11ReadData_0
     66                  return DHT11_NOT_REPLY;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE085             B.N      ??DHT11ReadData_1
     67           
     68              // DHT11's low signal
     69              if(WaitForHigh(DHT11_SIGNAL_LENGTH) > DHT11_SIGNAL_LENGTH)
   \                     ??DHT11ReadData_0: (+1)
   \   00000084   0x2084             MOVS     R0,#+132
   \   00000086   0x.... 0x....      BL       WaitForHigh
   \   0000008A   0x2885             CMP      R0,#+133
   \   0000008C   0xD301             BCC.N    ??DHT11ReadData_2
     70                  return DHT11_SIGNAL_ERR;
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0xE07E             B.N      ??DHT11ReadData_1
     71           
     72              // wait for data
     73              if(WaitForLow(DHT11_SIGNAL_LENGTH) > DHT11_SIGNAL_LENGTH)
   \                     ??DHT11ReadData_2: (+1)
   \   00000092   0x2084             MOVS     R0,#+132
   \   00000094   0x.... 0x....      BL       WaitForLow
   \   00000098   0x2885             CMP      R0,#+133
   \   0000009A   0xD301             BCC.N    ??DHT11ReadData_3
     74                  return DHT11_DATA_NOT_START;
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0xE077             B.N      ??DHT11ReadData_1
     75           
     76              // put 40 wait repeat times to array data[]
     77              for(i = 0;i < DHT11_DATA_BITS;i++)
   \                     ??DHT11ReadData_3: (+1)
   \   000000A0   0x2500             MOVS     R5,#+0
   \   000000A2   0xE000             B.N      ??DHT11ReadData_4
   \                     ??DHT11ReadData_5: (+1)
   \   000000A4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??DHT11ReadData_4: (+1)
   \   000000A6   0x2D28             CMP      R5,#+40
   \   000000A8   0xD211             BCS.N    ??DHT11ReadData_6
     78              {
     79                  WaitForHigh(DHT11_DATA_LOW_LENGTH);
   \   000000AA   0x206E             MOVS     R0,#+110
   \   000000AC   0x.... 0x....      BL       WaitForHigh
     80                  data[i] = WaitForLow(DHT11_DATA_HIGH_LENGTH_1);
   \   000000B0   0x2084             MOVS     R0,#+132
   \   000000B2   0x.... 0x....      BL       WaitForLow
   \   000000B6   0x4669             MOV      R1,SP
   \   000000B8   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
     81                  if(data[i] > DHT11_DATA_HIGH_LENGTH_1)                 // error occurred
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   000000C2   0x2885             CMP      R0,#+133
   \   000000C4   0xD3EE             BCC.N    ??DHT11ReadData_5
     82                      return (DHT11_DATA_HIGH_ERR + i);
   \   000000C6   0x3564             ADDS     R5,R5,#+100
   \   000000C8   0x0028             MOVS     R0,R5
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0xE060             B.N      ??DHT11ReadData_1
     83              }
     84           
     85              // calculate humidity
     86              for(i = 0;i < 16;i++)
   \                     ??DHT11ReadData_6: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE00E             B.N      ??DHT11ReadData_7
     87              {
     88                  if(i > 0) pData->humid <<= 1;
   \                     ??DHT11ReadData_8: (+1)
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD002             BEQ.N    ??DHT11ReadData_9
   \   000000D6   0x8821             LDRH     R1,[R4, #+0]
   \   000000D8   0x0049             LSLS     R1,R1,#+1
   \   000000DA   0x8021             STRH     R1,[R4, #+0]
     89                  if(data[i] > DHT11_DATA_HIGH_LENGTH_0)
   \                     ??DHT11ReadData_9: (+1)
   \   000000DC   0x4669             MOV      R1,SP
   \   000000DE   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   000000E2   0x2943             CMP      R1,#+67
   \   000000E4   0xD303             BCC.N    ??DHT11ReadData_10
     90                      pData->humid |= 1;
   \   000000E6   0x8821             LDRH     R1,[R4, #+0]
   \   000000E8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   000000EC   0x8021             STRH     R1,[R4, #+0]
     91              }
   \                     ??DHT11ReadData_10: (+1)
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \                     ??DHT11ReadData_7: (+1)
   \   000000F0   0x2810             CMP      R0,#+16
   \   000000F2   0xD3EE             BCC.N    ??DHT11ReadData_8
     92           
     93              // calculate temp
     94              for(;i < 32;i++)
   \                     ??DHT11ReadData_11: (+1)
   \   000000F4   0x2820             CMP      R0,#+32
   \   000000F6   0xD21E             BCS.N    ??DHT11ReadData_12
     95              {
     96                  if(i > 16) pData->temp <<= 1;
   \   000000F8   0x2811             CMP      R0,#+17
   \   000000FA   0xD302             BCC.N    ??DHT11ReadData_13
   \   000000FC   0x8861             LDRH     R1,[R4, #+2]
   \   000000FE   0x0049             LSLS     R1,R1,#+1
   \   00000100   0x8061             STRH     R1,[R4, #+2]
     97                  if(data[i] > DHT11_DATA_HIGH_LENGTH_0)
   \                     ??DHT11ReadData_13: (+1)
   \   00000102   0x4669             MOV      R1,SP
   \   00000104   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000108   0x2943             CMP      R1,#+67
   \   0000010A   0xD303             BCC.N    ??DHT11ReadData_14
     98                      pData->temp |= 1;
   \   0000010C   0x8861             LDRH     R1,[R4, #+2]
   \   0000010E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000112   0x8061             STRH     R1,[R4, #+2]
     99              }
   \                     ??DHT11ReadData_14: (+1)
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \   00000116   0xE7ED             B.N      ??DHT11ReadData_11
    100           
    101              // calculate checksum
    102              for(;i < DHT11_DATA_BITS;i++)
    103              {
    104                  if(i > 32) pData->checksum <<= 1;
   \                     ??DHT11ReadData_15: (+1)
   \   00000118   0x2821             CMP      R0,#+33
   \   0000011A   0xD302             BCC.N    ??DHT11ReadData_16
   \   0000011C   0x7921             LDRB     R1,[R4, #+4]
   \   0000011E   0x0049             LSLS     R1,R1,#+1
   \   00000120   0x7121             STRB     R1,[R4, #+4]
    105                  if(data[i] > DHT11_DATA_HIGH_LENGTH_0)
   \                     ??DHT11ReadData_16: (+1)
   \   00000122   0x4669             MOV      R1,SP
   \   00000124   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000128   0x2943             CMP      R1,#+67
   \   0000012A   0xD303             BCC.N    ??DHT11ReadData_17
    106                      pData->checksum |= 1;
   \   0000012C   0x7921             LDRB     R1,[R4, #+4]
   \   0000012E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000132   0x7121             STRB     R1,[R4, #+4]
    107              }
   \                     ??DHT11ReadData_17: (+1)
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \                     ??DHT11ReadData_12: (+1)
   \   00000136   0x2828             CMP      R0,#+40
   \   00000138   0xD3EE             BCC.N    ??DHT11ReadData_15
    108           
    109              // check checksum
    110              if(pData->checksum != (pData->humid / 256 + pData->humid % 256 + pData->temp / 256 + pData->temp % 256) % 256)
   \   0000013A   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   0000013E   0xF44F 0x7180      MOV      R1,#+256
   \   00000142   0xF9B4 0x2002      LDRSH    R2,[R4, #+2]
   \   00000146   0xF44F 0x7380      MOV      R3,#+256
   \   0000014A   0xF9B4 0x5000      LDRSH    R5,[R4, #+0]
   \   0000014E   0xF44F 0x7680      MOV      R6,#+256
   \   00000152   0xFB95 0xF5F6      SDIV     R5,R5,R6
   \   00000156   0x1945             ADDS     R5,R0,R5
   \   00000158   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000015C   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000160   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   00000164   0xF44F 0x7580      MOV      R5,#+256
   \   00000168   0xFB90 0xF0F5      SDIV     R0,R0,R5
   \   0000016C   0x1841             ADDS     R1,R0,R1
   \   0000016E   0x1851             ADDS     R1,R2,R1
   \   00000170   0xFB92 0xF0F3      SDIV     R0,R2,R3
   \   00000174   0xFB03 0x1110      MLS      R1,R3,R0,R1
   \   00000178   0xF44F 0x7080      MOV      R0,#+256
   \   0000017C   0x7922             LDRB     R2,[R4, #+4]
   \   0000017E   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \   00000182   0xFB00 0x1113      MLS      R1,R0,R3,R1
   \   00000186   0x428A             CMP      R2,R1
   \   00000188   0xD001             BEQ.N    ??DHT11ReadData_18
    111                  return DHT11_CHKSUM_ERR;
   \   0000018A   0x2004             MOVS     R0,#+4
   \   0000018C   0xE000             B.N      ??DHT11ReadData_1
    112              return DHT11_SUCCESS;
   \                     ??DHT11ReadData_18: (+1)
   \   0000018E   0x2000             MOVS     R0,#+0
   \                     ??DHT11ReadData_1: (+1)
   \   00000190   0xB014             ADD      SP,SP,#+80
   \   00000192   0xBD70             POP      {R4-R6,PC}       ;; return
    113          }
    114           

   \                                 In section .text, align 2, keep-with-next
    115          uint32_t WaitForLow(uint32_t max)
    116          {
   \                     WaitForLow: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    117              uint32_t time = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    118              while((DHT11_DATA_GPIO_Port->IDR & DHT11_DATA_Pin) && (time++ < max));
   \                     ??WaitForLow_0: (+1)
   \   00000004   0x....             LDR.N    R2,??DataTable10_5  ;; 0x40010808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0452             LSLS     R2,R2,#+17
   \   0000000A   0xD503             BPL.N    ??WaitForLow_1
   \   0000000C   0x0002             MOVS     R2,R0
   \   0000000E   0x1C50             ADDS     R0,R2,#+1
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD3F7             BCC.N    ??WaitForLow_0
    119              return time;
   \                     ??WaitForLow_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    120          }
    121           

   \                                 In section .text, align 2, keep-with-next
    122          uint32_t WaitForHigh(uint32_t max)
    123          {
   \                     WaitForHigh: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    124              uint32_t time = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    125              while(!(DHT11_DATA_GPIO_Port->IDR & DHT11_DATA_Pin) && (time++ < max));
   \                     ??WaitForHigh_0: (+1)
   \   00000004   0x....             LDR.N    R2,??DataTable10_5  ;; 0x40010808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0452             LSLS     R2,R2,#+17
   \   0000000A   0xD403             BMI.N    ??WaitForHigh_1
   \   0000000C   0x0002             MOVS     R2,R0
   \   0000000E   0x1C50             ADDS     R0,R2,#+1
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD3F7             BCC.N    ??WaitForHigh_0
    126              return time;
   \                     ??WaitForHigh_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void RCC_Configure(void)
    130          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    131              /* UART TX/RX port clock enable */ // PA9, PA10
    132              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    133              /* USART1 clock enable */ //
    134              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    135              /* USART2 clock enable */ //
    136              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000001A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    137          
    138              /* Alternate Function IO clock enable */
    139              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    140          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    141          

   \                                 In section .text, align 2, keep-with-next
    142          void GPIO_Configure(void)
    143          {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    144              GPIO_InitTypeDef GPIO_InitStructure;
    145          
    146              /* UART1 pin setting */
    147              //TX
    148              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000002   0xF44F 0x7000      MOV      R0,#+512
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    149              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    150              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000010   0x2018             MOVS     R0,#+24
   \   00000012   0xF88D 0x0003      STRB     R0,[SP, #+3]
    151              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40010800
   \   0000001A   0x.... 0x....      BL       GPIO_Init
    152             
    153              //RX
    154              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    155              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0xF88D 0x0003      STRB     R0,[SP, #+3]
    156              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40010800
   \   00000030   0x.... 0x....      BL       GPIO_Init
    157          
    158              //TEMP
    159              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    160              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    161              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000042   0x2010             MOVS     R0,#+16
   \   00000044   0xF88D 0x0003      STRB     R0,[SP, #+3]
    162              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40010800
   \   0000004C   0x.... 0x....      BL       GPIO_Init
    163          
    164              /* UART2 pin setting */
    165              //TX
    166              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   00000050   0x2004             MOVS     R0,#+4
   \   00000052   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    167              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xF88D 0x0002      STRB     R0,[SP, #+2]
    168              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000005C   0x2018             MOVS     R0,#+24
   \   0000005E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    169              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40010800
   \   00000066   0x.... 0x....      BL       GPIO_Init
    170             
    171              //RX
    172              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   0000006A   0x2008             MOVS     R0,#+8
   \   0000006C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    173              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000070   0x2028             MOVS     R0,#+40
   \   00000072   0xF88D 0x0003      STRB     R0,[SP, #+3]
    174              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000076   0x4669             MOV      R1,SP
   \   00000078   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40010800
   \   0000007A   0x.... 0x....      BL       GPIO_Init
    175          
    176          }
   \   0000007E   0xBD01             POP      {R0,PC}          ;; return
    177          

   \                                 In section .text, align 2, keep-with-next
    178          void EXTI_Configure(void)
    179          {
   \                     EXTI_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    180              EXTI_InitTypeDef EXTI_InitStructure;
    181          
    182              /* USART1: RX*/
    183              GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource10);
   \   00000002   0x210A             MOVS     R1,#+10
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
    184              EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   0000000A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    185              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    186              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000016   0x200C             MOVS     R0,#+12
   \   00000018   0xF88D 0x0005      STRB     R0,[SP, #+5]
    187              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    188              EXTI_Init(&EXTI_InitStructure);
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       EXTI_Init
    189          
    190              /* USART2: RX*/
    191              GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource3);
   \   00000028   0x2103             MOVS     R1,#+3
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       GPIO_EXTILineConfig
    192              EXTI_InitStructure.EXTI_Line = EXTI_Line3;
   \   00000030   0x2008             MOVS     R0,#+8
   \   00000032   0x9000             STR      R0,[SP, #+0]
    193              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
    194              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   0000003A   0x200C             MOVS     R0,#+12
   \   0000003C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    195              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0006      STRB     R0,[SP, #+6]
    196              EXTI_Init(&EXTI_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       EXTI_Init
    197          }
   \   0000004C   0xBD07             POP      {R0-R2,PC}       ;; return
    198          

   \                                 In section .text, align 2, keep-with-next
    199          void Init_USART(void)
    200          {
   \                     Init_USART: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    201              USART_InitTypeDef USART1_InitStructure;
    202              USART_InitTypeDef USART2_InitStructure;
    203          
    204              // Enable the USART1, 2 peripheral
    205              USART_Cmd(USART1, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_Cmd
    206              USART_Cmd(USART2, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000010   0x.... 0x....      BL       USART_Cmd
    207              
    208              USART1_InitStructure.USART_BaudRate = 9600;
   \   00000014   0xF44F 0x5016      MOV      R0,#+9600
   \   00000018   0x9004             STR      R0,[SP, #+16]
    209              USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    210              USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    211              USART1_InitStructure.USART_Parity = USART_Parity_No;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    212              USART1_InitStructure.USART_Mode = (USART_CR1_RE | USART_CR1_TE | USART_CR1_UE);
   \   0000002C   0xF242 0x000C      MOVW     R0,#+8204
   \   00000030   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    213              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    214              USART_Init(USART1, &USART1_InitStructure);
   \   0000003A   0xA904             ADD      R1,SP,#+16
   \   0000003C   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   0000003E   0x.... 0x....      BL       USART_Init
    215          
    216              USART2_InitStructure.USART_BaudRate = 9600;
   \   00000042   0xF44F 0x5016      MOV      R0,#+9600
   \   00000046   0x9000             STR      R0,[SP, #+0]
    217              USART2_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    218              USART2_InitStructure.USART_StopBits = USART_StopBits_1;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    219              USART2_InitStructure.USART_Parity = USART_Parity_No;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    220              USART2_InitStructure.USART_Mode = (USART_CR1_RE | USART_CR1_TE | USART_CR1_UE);
   \   0000005A   0xF242 0x000C      MOVW     R0,#+8204
   \   0000005E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    221              USART2_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    222              USART_Init(USART2, &USART2_InitStructure);
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   0000006C   0x.... 0x....      BL       USART_Init
    223              
    224              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0xF240 0x5125      MOVW     R1,#+1317
   \   00000076   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000078   0x.... 0x....      BL       USART_ITConfig
    225              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0xF240 0x5125      MOVW     R1,#+1317
   \   00000082   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000084   0x.... 0x....      BL       USART_ITConfig
    226          }
   \   00000088   0xB009             ADD      SP,SP,#+36
   \   0000008A   0xBD00             POP      {PC}             ;; return
    227          
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    230          
    231              NVIC_InitTypeDef NVIC_InitStructure;
    232              
    233              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
   \   00000002   0xF44F 0x60E0      MOV      R0,#+1792
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    234          
    235              // UART1
    236              // 'NVIC_EnableIRQ' is only required for USART setting
    237              NVIC_EnableIRQ(USART1_IRQn);
   \   0000000A   0x2025             MOVS     R0,#+37
   \   0000000C   0x.... 0x....      BL       __NVIC_EnableIRQ
    238              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000010   0x2025             MOVS     R0,#+37
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    239              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_IPR0_PRI_0;
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    240              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    241              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    242              NVIC_Init(&NVIC_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       NVIC_Init
    243          
    244              // UART2
    245              // 'NVIC_EnableIRQ' is only required for USART setting
    246              NVIC_EnableIRQ(USART2_IRQn);
   \   0000002E   0x2026             MOVS     R0,#+38
   \   00000030   0x.... 0x....      BL       __NVIC_EnableIRQ
    247              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   00000034   0x2026             MOVS     R0,#+38
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    248              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_IPR0_PRI_0;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    249              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0002      STRB     R0,[SP, #+2]
    250              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
    251              NVIC_Init(&NVIC_InitStructure);
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x.... 0x....      BL       NVIC_Init
    252          }
   \   00000052   0xBD01             POP      {R0,PC}          ;; return
    253          

   \                                 In section .text, align 2, keep-with-next
    254          void USART1_IRQHandler() {      // board --> app
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255              uint16_t word;
    256              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00A             BEQ.N    ??USART1_IRQHandler_0
    257                  // the most recent received data by the USART1 peripheral
    258                  word = USART_ReceiveData(USART1);
   \   00000010   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    259          
    260               
    261                  sendDataUART2(word);
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       sendDataUART2
    262          
    263                  // clear 'Read data register not empty' flag
    264                  USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \   0000001C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000020   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000022   0x.... 0x....      BL       USART_ClearITPendingBit
    265              }
    266          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    267          
    268          // TODO!!!: USART2 handler

   \                                 In section .text, align 2, keep-with-next
    269          void USART2_IRQHandler() {      // app -> board
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    270          
    271              uint16_t word;
    272              if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00A             BEQ.N    ??USART2_IRQHandler_0
    273                  // the most recent received data by the USART1 peripheral
    274                  word = USART_ReceiveData(USART2);
   \   00000010   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    275          
    276                  sendDataUART1(word);
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       sendDataUART1
    277                  // clear 'Read data register not empty' flag
    278                  USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \   0000001C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000020   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000022   0x.... 0x....      BL       USART_ClearITPendingBit
    279              }
    280          }
   \                     ??USART2_IRQHandler_0: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    281          
    282          

   \                                 In section .text, align 2, keep-with-next
    283          void sendTempHumedity(){
    284            
    285          }
   \                     sendTempHumedity: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void sendLight(){
    288            
    289          }
   \                     sendLight: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    292              
    293              USART_SendData(USART1, data);
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_SendData
    294          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    295          

   \                                 In section .text, align 2, keep-with-next
    296          void sendDataUART2(uint16_t data) {
   \                     sendDataUART2: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    297              
    298              USART_SendData(USART2, data);
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004400
   \   00000008   0x.... 0x....      BL       USART_SendData
    299          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    300          
    301          

   \                                 In section .text, align 2, keep-with-next
    302          int main(void)
    303          {
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    304          
    305              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    306          
    307              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    308          
    309              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    310          
    311              //EXTI_Configure();
    312          
    313              Init_USART();
   \   0000000E   0x.... 0x....      BL       Init_USART
    314          
    315              NVIC_Configure();
   \   00000012   0x.... 0x....      BL       NVIC_Configure
    316          
    317              while (1){
    318                sendDataUART1('A');
   \                     ??main_0: (+1)
   \   00000016   0x2041             MOVS     R0,#+65
   \   00000018   0x.... 0x....      BL       sendDataUART1
    319                int ret = DHT11ReadData(&dht11_data);
   \   0000001C   0x....             LDR.N    R0,??DataTable10_9
   \   0000001E   0x.... 0x....      BL       DHT11ReadData
    320                //char buf[16];
    321                //sprintf(buf, "%d %d", dht11_data.humid, dht11_data.temp);
    322                
    323                //for(int i = 0; buf[i] != '\0'; i++){
    324                  sendDataUART1(((char*)dht11_data.humid)[0]);
   \   00000022   0x....             LDR.N    R0,??DataTable10_9
   \   00000024   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x.... 0x....      BL       sendDataUART1
    325                  sendDataUART1(((char*)dht11_data.humid)[1]);
   \   00000032   0x....             LDR.N    R0,??DataTable10_9
   \   00000034   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000038   0x7840             LDRB     R0,[R0, #+1]
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0x.... 0x....      BL       sendDataUART1
    326                  sendDataUART1(((char*)dht11_data.temp)[0]);
   \   00000040   0x....             LDR.N    R0,??DataTable10_9
   \   00000042   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x.... 0x....      BL       sendDataUART1
    327                  sendDataUART1(((char*)dht11_data.temp)[1]);
   \   00000050   0x....             LDR.N    R0,??DataTable10_9
   \   00000052   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000056   0x7840             LDRB     R0,[R0, #+1]
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x.... 0x....      BL       sendDataUART1
    328                //}
    329                Delay_us(1000);
   \   0000005E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000062   0x.... 0x....      BL       Delay_us
   \   00000066   0xE7D6             B.N      ??main_0
    330              }
    331          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40010804         DC32     0x40010804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40010810         DC32     0x40010810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40010814         DC32     0x40010814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x4001080C         DC32     0x4001080c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40010808         DC32     0x40010808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     dht11_data

   \                                 In section .rodata, align 4
   \   00000000   0x0000 0x0000      DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \   0000002C   0x0000 0x0000      DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      96   DHT11ReadData
        96   -> Delay_us
        96   -> WaitForHigh
        96   -> WaitForLow
        96   -> __aeabi_memclr4
       0   Delay_us
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configure
         8   -> GPIO_Init
      40   Init_USART
        40   -> USART_Cmd
        40   -> USART_ITConfig
        40   -> USART_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> sendDataUART2
       8   USART2_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> sendDataUART1
       0   WaitForHigh
       0   WaitForLow
       0   __NVIC_EnableIRQ
       8   main
         8   -> DHT11ReadData
         8   -> Delay_us
         8   -> GPIO_Configure
         8   -> Init_USART
         8   -> NVIC_Configure
         8   -> RCC_Configure
         8   -> SystemInit
         8   -> sendDataUART1
       8   sendDataUART1
         8   -> USART_SendData
       8   sendDataUART2
         8   -> USART_SendData
       0   sendLight
       0   sendTempHumedity


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      80  ?_0
     404  DHT11ReadData
      32  Delay_us
      78  EXTI_Configure
     128  GPIO_Configure
     140  Init_USART
      84  NVIC_Configure
      40  RCC_Configure
      40  USART1_IRQHandler
      40  USART2_IRQHandler
      22  WaitForHigh
      22  WaitForLow
      30  __NVIC_EnableIRQ
       8  dht11_data
     104  main
      14  sendDataUART1
      14  sendDataUART2
       2  sendLight
       2  sendTempHumedity

 
     8 bytes in section .bss
    80 bytes in section .rodata
 1 236 bytes in section .text
 
 1 236 bytes of CODE  memory
    80 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
