###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         03/Nov/2021  18:48:26
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_fsmc.c
#    Command line      =
#        -f
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_fsmc.o.rsp
#        (C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_fsmc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries -o
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\inc\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\user\ -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\Startup\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\juhyeonlee\Desktop\Embedded\Libraries\LCD\ -Ol -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_fsmc.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\List\Libraries\stm32f10x_fsmc.lst
#    Object file       =
#        C:\Users\juhyeonlee\Desktop\Embedded\Debug\Obj\Libraries\stm32f10x_fsmc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\juhyeonlee\Desktop\Embedded\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\stm32f10x_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the FSMC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_fsmc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup FSMC 
     31            * @brief FSMC driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup FSMC_Private_TypesDefinitions
     36            * @{
     37            */ 
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup FSMC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* --------------------- FSMC registers bit mask ---------------------------- */
     47          
     48          /* FSMC BCRx Mask */
     49          #define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
     50          #define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
     51          #define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
     52          
     53          /* FSMC PCRx Mask */
     54          #define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
     55          #define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
     56          #define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
     57          #define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
     58          #define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
     59          /**
     60            * @}
     61            */
     62          
     63          /** @defgroup FSMC_Private_Macros
     64            * @{
     65            */
     66          
     67          /**
     68            * @}
     69            */
     70          
     71          /** @defgroup FSMC_Private_Variables
     72            * @{
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @defgroup FSMC_Private_FunctionPrototypes
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup FSMC_Private_Functions
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     93            *         reset values.
     94            * @param  FSMC_Bank: specifies the FSMC Bank to be used
     95            *   This parameter can be one of the following values:
     96            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     97            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     98            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     99            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    103          {
    104            /* Check the parameter */
    105            //assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    106            
    107            /* FSMC_Bank1_NORSRAM1 */
    108            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     FSMC_NORSRAMDeInit: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD106             BNE.N    ??FSMC_NORSRAMDeInit_0
    109            {
    110              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \        0x4   0xF243 0x01DB      MOVW     R1,#+12507
   \        0x8   0xF05F 0x4220      MOVS     R2,#+2684354560
   \        0xC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \       0x10   0xE005             B.N      ??FSMC_NORSRAMDeInit_1
    111            }
    112            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    113            else
    114            {   
    115              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_0: (+1)
   \       0x12   0xF243 0x01D2      MOVW     R1,#+12498
   \       0x16   0xF05F 0x4220      MOVS     R2,#+2684354560
   \       0x1A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    116            }
    117            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_1: (+1)
   \       0x1E   0xF07F 0x4170      MVNS     R1,#+4026531840
   \       0x22   0xF05F 0x4220      MOVS     R2,#+2684354560
   \       0x26   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \       0x2A   0x6051             STR      R1,[R2, #+4]
    118            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \       0x2C   0xF07F 0x4170      MVNS     R1,#+4026531840
   \       0x30   0x.... 0x....      LDR.W    R2,??DataTable15
   \       0x34   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    119          }
   \       0x38   0x4770             BX       LR
    120          
    121          /**
    122            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    123            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    124            *   This parameter can be one of the following values:
    125            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    126            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    127            * @retval None
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    130          {
    131            /* Check the parameter */
    132            //assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    133            
    134            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD112             BNE.N    ??FSMC_NANDDeInit_0
    135            {
    136              /* Set the FSMC_Bank2 registers to their reset values */
    137              FSMC_Bank2->PCR2 = 0x00000018;
   \        0x4   0x2018             MOVS     R0,#+24
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \        0xA   0x6008             STR      R0,[R1, #+0]
    138              FSMC_Bank2->SR2 = 0x00000040;
   \        0xC   0x2040             MOVS     R0,#+64
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0x12   0x6008             STR      R0,[R1, #+0]
    139              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \       0x14   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    140              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \       0x1E   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE011             B.N      ??FSMC_NANDDeInit_1
    141            }
    142            /* FSMC_Bank3_NAND */  
    143            else
    144            {
    145              /* Set the FSMC_Bank3 registers to their reset values */
    146              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0: (+1)
   \       0x2A   0x2018             MOVS     R0,#+24
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \       0x30   0x6008             STR      R0,[R1, #+0]
    147              FSMC_Bank3->SR3 = 0x00000040;
   \       0x32   0x2040             MOVS     R0,#+64
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \       0x38   0x6008             STR      R0,[R1, #+0]
    148              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \       0x3A   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable15_7
   \       0x42   0x6008             STR      R0,[R1, #+0]
    149              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \       0x44   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable15_8
   \       0x4C   0x6008             STR      R0,[R1, #+0]
    150            }  
    151          }
   \                     ??FSMC_NANDDeInit_1: (+1)
   \       0x4E   0x4770             BX       LR
    152          
    153          /**
    154            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    155            * @param  None                       
    156            * @retval None
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          void FSMC_PCCARDDeInit(void)
    159          {
    160            /* Set the FSMC_Bank4 registers to their reset values */
    161            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit: (+1)
   \        0x0   0x2018             MOVS     R0,#+24
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \        0x6   0x6008             STR      R0,[R1, #+0]
    162            FSMC_Bank4->SR4 = 0x00000000;	
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \        0xE   0x6008             STR      R0,[R1, #+0]
    163            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \       0x10   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \       0x18   0x6008             STR      R0,[R1, #+0]
    164            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \       0x1A   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \       0x22   0x6008             STR      R0,[R1, #+0]
    165            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \       0x24   0xF05F 0x30FC      MOVS     R0,#+4244438268
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    166          }
   \       0x2E   0x4770             BX       LR
    167          
    168          /**
    169            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    170            *         parameters in the FSMC_NORSRAMInitStruct.
    171            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    172            *         structure that contains the configuration information for 
    173            *        the FSMC NOR/SRAM specified Banks.                       
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    177          { 
    178            /* Check the parameters */
    179            //assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    180            //assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    181            //assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    182            //assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    183            //assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    184            //assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    185            //assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    186            //assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    187            //assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    188            //assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    189            //assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    190            //assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    191            //assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));
    192            //assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    193            //assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    194            //assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    195            //assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    196            //assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    197            //assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    198            //assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode));
    199            
    200            /* Bank1 NOR/SRAM control register configuration */ 
    201            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    202                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    203                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    204                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    205                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    206                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    207                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    208                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    209                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    210                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    211                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    212                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    213                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \                     FSMC_NORSRAMInit: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0x6881             LDR      R1,[R0, #+8]
   \        0x4   0x430A             ORRS     R2,R1,R2
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0x430A             ORRS     R2,R1,R2
   \        0xA   0x6901             LDR      R1,[R0, #+16]
   \        0xC   0x430A             ORRS     R2,R1,R2
   \        0xE   0x6941             LDR      R1,[R0, #+20]
   \       0x10   0x430A             ORRS     R2,R1,R2
   \       0x12   0x6981             LDR      R1,[R0, #+24]
   \       0x14   0x430A             ORRS     R2,R1,R2
   \       0x16   0x69C1             LDR      R1,[R0, #+28]
   \       0x18   0x430A             ORRS     R2,R1,R2
   \       0x1A   0x6A01             LDR      R1,[R0, #+32]
   \       0x1C   0x430A             ORRS     R2,R1,R2
   \       0x1E   0x6A41             LDR      R1,[R0, #+36]
   \       0x20   0x430A             ORRS     R2,R1,R2
   \       0x22   0x6A81             LDR      R1,[R0, #+40]
   \       0x24   0x430A             ORRS     R2,R1,R2
   \       0x26   0x6AC1             LDR      R1,[R0, #+44]
   \       0x28   0x430A             ORRS     R2,R1,R2
   \       0x2A   0x6B01             LDR      R1,[R0, #+48]
   \       0x2C   0x430A             ORRS     R2,R1,R2
   \       0x2E   0xF05F 0x4120      MOVS     R1,#+2684354560
   \       0x32   0x6803             LDR      R3,[R0, #+0]
   \       0x34   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
    214          
    215            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \       0x38   0x6881             LDR      R1,[R0, #+8]
   \       0x3A   0x2908             CMP      R1,#+8
   \       0x3C   0xD10B             BNE.N    ??FSMC_NORSRAMInit_0
    216            {
    217              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
   \       0x3E   0xF05F 0x4120      MOVS     R1,#+2684354560
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \       0x48   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x4C   0xF05F 0x4220      MOVS     R2,#+2684354560
   \       0x50   0x6803             LDR      R3,[R0, #+0]
   \       0x52   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
    218            }
    219            
    220            /* Bank1 NOR/SRAM timing register configuration */
    221            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    222                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    223                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    224                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    225                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    226                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    227                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    228                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0: (+1)
   \       0x56   0x6B41             LDR      R1,[R0, #+52]
   \       0x58   0x680A             LDR      R2,[R1, #+0]
   \       0x5A   0x6B41             LDR      R1,[R0, #+52]
   \       0x5C   0x6849             LDR      R1,[R1, #+4]
   \       0x5E   0xEA52 0x1201      ORRS     R2,R2,R1, LSL #+4
   \       0x62   0x6B41             LDR      R1,[R0, #+52]
   \       0x64   0x6889             LDR      R1,[R1, #+8]
   \       0x66   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0x6A   0x6B41             LDR      R1,[R0, #+52]
   \       0x6C   0x68C9             LDR      R1,[R1, #+12]
   \       0x6E   0xEA52 0x4201      ORRS     R2,R2,R1, LSL #+16
   \       0x72   0x6B41             LDR      R1,[R0, #+52]
   \       0x74   0x6909             LDR      R1,[R1, #+16]
   \       0x76   0xEA52 0x5201      ORRS     R2,R2,R1, LSL #+20
   \       0x7A   0x6B41             LDR      R1,[R0, #+52]
   \       0x7C   0x6949             LDR      R1,[R1, #+20]
   \       0x7E   0xEA52 0x6201      ORRS     R2,R2,R1, LSL #+24
   \       0x82   0x6B41             LDR      R1,[R0, #+52]
   \       0x84   0x6989             LDR      R1,[R1, #+24]
   \       0x86   0x430A             ORRS     R2,R1,R2
   \       0x88   0xF05F 0x4120      MOVS     R1,#+2684354560
   \       0x8C   0x6803             LDR      R3,[R0, #+0]
   \       0x8E   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   \       0x92   0x604A             STR      R2,[R1, #+4]
    229                      
    230              
    231            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    232            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \       0x94   0x6AC1             LDR      R1,[R0, #+44]
   \       0x96   0xF5B1 0x4F80      CMP      R1,#+16384
   \       0x9A   0xD11A             BNE.N    ??FSMC_NORSRAMInit_1
    233            {
    234              //assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    235              //assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    236              //assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    237              //assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    238              //assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    239              //assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    240              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    241                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    242                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    243                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    244                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    245                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    246                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \       0x9C   0x6B81             LDR      R1,[R0, #+56]
   \       0x9E   0x680A             LDR      R2,[R1, #+0]
   \       0xA0   0x6B81             LDR      R1,[R0, #+56]
   \       0xA2   0x6849             LDR      R1,[R1, #+4]
   \       0xA4   0xEA52 0x1201      ORRS     R2,R2,R1, LSL #+4
   \       0xA8   0x6B81             LDR      R1,[R0, #+56]
   \       0xAA   0x6889             LDR      R1,[R1, #+8]
   \       0xAC   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0xB0   0x6B81             LDR      R1,[R0, #+56]
   \       0xB2   0x6909             LDR      R1,[R1, #+16]
   \       0xB4   0xEA52 0x5201      ORRS     R2,R2,R1, LSL #+20
   \       0xB8   0x6B81             LDR      R1,[R0, #+56]
   \       0xBA   0x6949             LDR      R1,[R1, #+20]
   \       0xBC   0xEA52 0x6201      ORRS     R2,R2,R1, LSL #+24
   \       0xC0   0x6B81             LDR      R1,[R0, #+56]
   \       0xC2   0x6989             LDR      R1,[R1, #+24]
   \       0xC4   0x430A             ORRS     R2,R1,R2
   \       0xC6   0x.... 0x....      LDR.W    R1,??DataTable15
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0xD0   0xE006             B.N      ??FSMC_NORSRAMInit_2
    247            }
    248            else
    249            {
    250              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1: (+1)
   \       0xD2   0xF07F 0x4170      MVNS     R1,#+4026531840
   \       0xD6   0x.... 0x....      LDR.W    R2,??DataTable15
   \       0xDA   0x6800             LDR      R0,[R0, #+0]
   \       0xDC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    251            }
    252          }
   \                     ??FSMC_NORSRAMInit_2: (+1)
   \       0xE0   0x4770             BX       LR
    253          
    254          /**
    255            * @brief  Initializes the FSMC NAND Banks according to the specified 
    256            *         parameters in the FSMC_NANDInitStruct.
    257            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    258            *         structure that contains the configuration information for the FSMC 
    259            *         NAND specified Banks.                       
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    263          {
   \                     FSMC_NANDInit: (+1)
   \        0x0   0xB410             PUSH     {R4}
    264            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2100             MOVS     R1,#+0
    265              
    266            /* Check the parameters */
    267            //assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    268            //assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    269            //assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    270            //assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    271            //assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    272            //assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    273            //assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    274            //assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    275            //assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    276            //assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    277            //assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    278            //assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    279            //assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    280            //assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    281            //assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    282            
    283            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    284            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    285                      PCR_MemoryType_NAND |
    286                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    287                      FSMC_NANDInitStruct->FSMC_ECC |
    288                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    289                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    290                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \        0x8   0x6842             LDR      R2,[R0, #+4]
   \        0xA   0x6881             LDR      R1,[R0, #+8]
   \        0xC   0x430A             ORRS     R2,R1,R2
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x430A             ORRS     R2,R1,R2
   \       0x12   0x6901             LDR      R1,[R0, #+16]
   \       0x14   0x430A             ORRS     R2,R1,R2
   \       0x16   0x6941             LDR      R1,[R0, #+20]
   \       0x18   0xEA52 0x2241      ORRS     R2,R2,R1, LSL #+9
   \       0x1C   0x6981             LDR      R1,[R0, #+24]
   \       0x1E   0xEA52 0x3241      ORRS     R2,R2,R1, LSL #+13
   \       0x22   0xF052 0x0208      ORRS     R2,R2,#0x8
    291                      
    292            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    293            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    294                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    295                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    296                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \       0x26   0x69C1             LDR      R1,[R0, #+28]
   \       0x28   0x6809             LDR      R1,[R1, #+0]
   \       0x2A   0x69C3             LDR      R3,[R0, #+28]
   \       0x2C   0x685B             LDR      R3,[R3, #+4]
   \       0x2E   0xEA51 0x2103      ORRS     R1,R1,R3, LSL #+8
   \       0x32   0x69C3             LDR      R3,[R0, #+28]
   \       0x34   0x689B             LDR      R3,[R3, #+8]
   \       0x36   0xEA51 0x4103      ORRS     R1,R1,R3, LSL #+16
   \       0x3A   0x69C3             LDR      R3,[R0, #+28]
   \       0x3C   0x68DB             LDR      R3,[R3, #+12]
   \       0x3E   0xEA51 0x6103      ORRS     R1,R1,R3, LSL #+24
    297                      
    298            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    299            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    300                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    301                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    302                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \       0x42   0x6A03             LDR      R3,[R0, #+32]
   \       0x44   0x681B             LDR      R3,[R3, #+0]
   \       0x46   0x6A04             LDR      R4,[R0, #+32]
   \       0x48   0x6864             LDR      R4,[R4, #+4]
   \       0x4A   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x4E   0x6A04             LDR      R4,[R0, #+32]
   \       0x50   0x68A4             LDR      R4,[R4, #+8]
   \       0x52   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x56   0x6A04             LDR      R4,[R0, #+32]
   \       0x58   0x68E4             LDR      R4,[R4, #+12]
   \       0x5A   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
    303            
    304            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x2810             CMP      R0,#+16
   \       0x62   0xD109             BNE.N    ??FSMC_NANDInit_0
    305            {
    306              /* FSMC_Bank2_NAND registers configuration */
    307              FSMC_Bank2->PCR2 = tmppcr;
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x68   0x6002             STR      R2,[R0, #+0]
    308              FSMC_Bank2->PMEM2 = tmppmem;
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0x6E   0x6001             STR      R1,[R0, #+0]
    309              FSMC_Bank2->PATT2 = tmppatt;
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \       0x74   0x6003             STR      R3,[R0, #+0]
   \       0x76   0xE008             B.N      ??FSMC_NANDInit_1
    310            }
    311            else
    312            {
    313              /* FSMC_Bank3_NAND registers configuration */
    314              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0: (+1)
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0x7C   0x6002             STR      R2,[R0, #+0]
    315              FSMC_Bank3->PMEM3 = tmppmem;
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x82   0x6001             STR      R1,[R0, #+0]
    316              FSMC_Bank3->PATT3 = tmppatt;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x88   0x6003             STR      R3,[R0, #+0]
    317            }
    318          }
   \                     ??FSMC_NANDInit_1: (+1)
   \       0x8A   0xBC10             POP      {R4}
   \       0x8C   0x4770             BX       LR
    319          
    320          /**
    321            * @brief  Initializes the FSMC PCCARD Bank according to the specified 
    322            *         parameters in the FSMC_PCCARDInitStruct.
    323            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    324            *         structure that contains the configuration information for the FSMC 
    325            *         PCCARD Bank.                       
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    329          {
    330            /* Check the parameters */
    331            //assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    332            //assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    333            //assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    334           
    335            //assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    336            //assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    337            //assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    338            //assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    339            
    340            //assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    341            //assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    342            //assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    343            //assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    344            //assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    345            //assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    346            //assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    347            //assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    348            
    349            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    350            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    351                               FSMC_MemoryDataWidth_16b |  
    352                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    353                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \                     FSMC_PCCARDInit: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   \        0x4   0xEA51 0x2142      ORRS     R1,R1,R2, LSL #+9
   \        0x8   0x6882             LDR      R2,[R0, #+8]
   \        0xA   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \        0xE   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x12   0x.... 0x....      LDR.W    R2,??DataTable15_9
   \       0x16   0x6011             STR      R1,[R2, #+0]
    354                      
    355            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    356            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    357                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    358                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    359                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \       0x18   0x68C1             LDR      R1,[R0, #+12]
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0x68C2             LDR      R2,[R0, #+12]
   \       0x1E   0x6852             LDR      R2,[R2, #+4]
   \       0x20   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x24   0x68C2             LDR      R2,[R0, #+12]
   \       0x26   0x6892             LDR      R2,[R2, #+8]
   \       0x28   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x2C   0x68C2             LDR      R2,[R0, #+12]
   \       0x2E   0x68D2             LDR      R2,[R2, #+12]
   \       0x30   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \       0x34   0x.... 0x....      LDR.W    R2,??DataTable15_11
   \       0x38   0x6011             STR      R1,[R2, #+0]
    360                      
    361            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    362            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    363                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    364                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    365                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \       0x3A   0x6901             LDR      R1,[R0, #+16]
   \       0x3C   0x6809             LDR      R1,[R1, #+0]
   \       0x3E   0x6902             LDR      R2,[R0, #+16]
   \       0x40   0x6852             LDR      R2,[R2, #+4]
   \       0x42   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x46   0x6902             LDR      R2,[R0, #+16]
   \       0x48   0x6892             LDR      R2,[R2, #+8]
   \       0x4A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x4E   0x6902             LDR      R2,[R0, #+16]
   \       0x50   0x68D2             LDR      R2,[R2, #+12]
   \       0x52   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \       0x56   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \       0x5A   0x6011             STR      R1,[R2, #+0]
    366                      
    367            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    368            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    369                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    370                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    371                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \       0x5C   0x6941             LDR      R1,[R0, #+20]
   \       0x5E   0x6809             LDR      R1,[R1, #+0]
   \       0x60   0x6942             LDR      R2,[R0, #+20]
   \       0x62   0x6852             LDR      R2,[R2, #+4]
   \       0x64   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x68   0x6942             LDR      R2,[R0, #+20]
   \       0x6A   0x6892             LDR      R2,[R2, #+8]
   \       0x6C   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x70   0x6940             LDR      R0,[R0, #+20]
   \       0x72   0x68C0             LDR      R0,[R0, #+12]
   \       0x74   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \       0x7C   0x6001             STR      R1,[R0, #+0]
    372          }
   \       0x7E   0x4770             BX       LR
    373          
    374          /**
    375            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    376            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    377            *         structure which will be initialized.
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    381          {  
    382            /* Reset NOR/SRAM Init structure parameters values */
    383            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    384            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x6041             STR      R1,[R0, #+4]
    385            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    386            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    387            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    388            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    389            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    390            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x61C1             STR      R1,[R0, #+28]
    391            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6201             STR      R1,[R0, #+32]
    392            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \       0x24   0xF44F 0x5180      MOV      R1,#+4096
   \       0x28   0x6241             STR      R1,[R0, #+36]
    393            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \       0x2A   0xF44F 0x5100      MOV      R1,#+8192
   \       0x2E   0x6281             STR      R1,[R0, #+40]
    394            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x62C1             STR      R1,[R0, #+44]
    395            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6301             STR      R1,[R0, #+48]
    396            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \       0x38   0x210F             MOVS     R1,#+15
   \       0x3A   0x6B42             LDR      R2,[R0, #+52]
   \       0x3C   0x6011             STR      R1,[R2, #+0]
    397            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \       0x3E   0x210F             MOVS     R1,#+15
   \       0x40   0x6B42             LDR      R2,[R0, #+52]
   \       0x42   0x6051             STR      R1,[R2, #+4]
    398            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \       0x44   0x21FF             MOVS     R1,#+255
   \       0x46   0x6B42             LDR      R2,[R0, #+52]
   \       0x48   0x6091             STR      R1,[R2, #+8]
    399            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \       0x4A   0x210F             MOVS     R1,#+15
   \       0x4C   0x6B42             LDR      R2,[R0, #+52]
   \       0x4E   0x60D1             STR      R1,[R2, #+12]
    400            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \       0x50   0x210F             MOVS     R1,#+15
   \       0x52   0x6B42             LDR      R2,[R0, #+52]
   \       0x54   0x6111             STR      R1,[R2, #+16]
    401            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \       0x56   0x210F             MOVS     R1,#+15
   \       0x58   0x6B42             LDR      R2,[R0, #+52]
   \       0x5A   0x6151             STR      R1,[R2, #+20]
    402            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x6B42             LDR      R2,[R0, #+52]
   \       0x60   0x6191             STR      R1,[R2, #+24]
    403            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \       0x62   0x210F             MOVS     R1,#+15
   \       0x64   0x6B82             LDR      R2,[R0, #+56]
   \       0x66   0x6011             STR      R1,[R2, #+0]
    404            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \       0x68   0x210F             MOVS     R1,#+15
   \       0x6A   0x6B82             LDR      R2,[R0, #+56]
   \       0x6C   0x6051             STR      R1,[R2, #+4]
    405            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \       0x6E   0x21FF             MOVS     R1,#+255
   \       0x70   0x6B82             LDR      R2,[R0, #+56]
   \       0x72   0x6091             STR      R1,[R2, #+8]
    406            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \       0x74   0x210F             MOVS     R1,#+15
   \       0x76   0x6B82             LDR      R2,[R0, #+56]
   \       0x78   0x60D1             STR      R1,[R2, #+12]
    407            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \       0x7A   0x210F             MOVS     R1,#+15
   \       0x7C   0x6B82             LDR      R2,[R0, #+56]
   \       0x7E   0x6111             STR      R1,[R2, #+16]
    408            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \       0x80   0x210F             MOVS     R1,#+15
   \       0x82   0x6B82             LDR      R2,[R0, #+56]
   \       0x84   0x6151             STR      R1,[R2, #+20]
    409            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \       0x86   0x2100             MOVS     R1,#+0
   \       0x88   0x6B80             LDR      R0,[R0, #+56]
   \       0x8A   0x6181             STR      R1,[R0, #+24]
    410          }
   \       0x8C   0x4770             BX       LR
    411          
    412          /**
    413            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    414            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
    415            *         structure which will be initialized.
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    419          { 
    420            /* Reset NAND Init structure parameters values */
    421            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit: (+1)
   \        0x0   0x2110             MOVS     R1,#+16
   \        0x2   0x6001             STR      R1,[R0, #+0]
    422            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    423            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    424            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    425            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    426            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    427            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    428            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x1C   0x21FC             MOVS     R1,#+252
   \       0x1E   0x69C2             LDR      R2,[R0, #+28]
   \       0x20   0x6011             STR      R1,[R2, #+0]
    429            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x22   0x21FC             MOVS     R1,#+252
   \       0x24   0x69C2             LDR      R2,[R0, #+28]
   \       0x26   0x6051             STR      R1,[R2, #+4]
    430            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x28   0x21FC             MOVS     R1,#+252
   \       0x2A   0x69C2             LDR      R2,[R0, #+28]
   \       0x2C   0x6091             STR      R1,[R2, #+8]
    431            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \       0x2E   0x21FC             MOVS     R1,#+252
   \       0x30   0x69C2             LDR      R2,[R0, #+28]
   \       0x32   0x60D1             STR      R1,[R2, #+12]
    432            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x34   0x21FC             MOVS     R1,#+252
   \       0x36   0x6A02             LDR      R2,[R0, #+32]
   \       0x38   0x6011             STR      R1,[R2, #+0]
    433            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x3A   0x21FC             MOVS     R1,#+252
   \       0x3C   0x6A02             LDR      R2,[R0, #+32]
   \       0x3E   0x6051             STR      R1,[R2, #+4]
    434            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x40   0x21FC             MOVS     R1,#+252
   \       0x42   0x6A02             LDR      R2,[R0, #+32]
   \       0x44   0x6091             STR      R1,[R2, #+8]
    435            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \       0x46   0x21FC             MOVS     R1,#+252
   \       0x48   0x6A00             LDR      R0,[R0, #+32]
   \       0x4A   0x60C1             STR      R1,[R0, #+12]
    436          }
   \       0x4C   0x4770             BX       LR
    437          
    438          /**
    439            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    440            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    441            *         structure which will be initialized.
    442            * @retval None
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    445          {
    446            /* Reset PCCARD Init structure parameters values */
    447            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    448            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    449            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    450            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \        0xC   0x21FC             MOVS     R1,#+252
   \        0xE   0x68C2             LDR      R2,[R0, #+12]
   \       0x10   0x6011             STR      R1,[R2, #+0]
    451            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x12   0x21FC             MOVS     R1,#+252
   \       0x14   0x68C2             LDR      R2,[R0, #+12]
   \       0x16   0x6051             STR      R1,[R2, #+4]
    452            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x18   0x21FC             MOVS     R1,#+252
   \       0x1A   0x68C2             LDR      R2,[R0, #+12]
   \       0x1C   0x6091             STR      R1,[R2, #+8]
    453            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \       0x1E   0x21FC             MOVS     R1,#+252
   \       0x20   0x68C2             LDR      R2,[R0, #+12]
   \       0x22   0x60D1             STR      R1,[R2, #+12]
    454            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x24   0x21FC             MOVS     R1,#+252
   \       0x26   0x6902             LDR      R2,[R0, #+16]
   \       0x28   0x6011             STR      R1,[R2, #+0]
    455            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x2A   0x21FC             MOVS     R1,#+252
   \       0x2C   0x6902             LDR      R2,[R0, #+16]
   \       0x2E   0x6051             STR      R1,[R2, #+4]
    456            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x30   0x21FC             MOVS     R1,#+252
   \       0x32   0x6902             LDR      R2,[R0, #+16]
   \       0x34   0x6091             STR      R1,[R2, #+8]
    457            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \       0x36   0x21FC             MOVS     R1,#+252
   \       0x38   0x6902             LDR      R2,[R0, #+16]
   \       0x3A   0x60D1             STR      R1,[R2, #+12]
    458            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x3C   0x21FC             MOVS     R1,#+252
   \       0x3E   0x6942             LDR      R2,[R0, #+20]
   \       0x40   0x6011             STR      R1,[R2, #+0]
    459            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x42   0x21FC             MOVS     R1,#+252
   \       0x44   0x6942             LDR      R2,[R0, #+20]
   \       0x46   0x6051             STR      R1,[R2, #+4]
    460            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x48   0x21FC             MOVS     R1,#+252
   \       0x4A   0x6942             LDR      R2,[R0, #+20]
   \       0x4C   0x6091             STR      R1,[R2, #+8]
    461            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \       0x4E   0x21FC             MOVS     R1,#+252
   \       0x50   0x6940             LDR      R0,[R0, #+20]
   \       0x52   0x60C1             STR      R1,[R0, #+12]
    462          }
   \       0x54   0x4770             BX       LR
    463          
    464          /**
    465            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    466            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    467            *   This parameter can be one of the following values:
    468            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    469            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    470            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    471            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    472            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    473            * @retval None
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    476          {
    477            //assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    478            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    479            
    480            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00A             BEQ.N    ??FSMC_NORSRAMCmd_0
    481            {
    482              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    483              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
   \        0x6   0xF05F 0x4120      MOVS     R1,#+2684354560
   \        0xA   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \        0xE   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x12   0xF05F 0x4220      MOVS     R2,#+2684354560
   \       0x16   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \       0x1A   0xE009             B.N      ??FSMC_NORSRAMCmd_1
    484            }
    485            else
    486            {
    487              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    488              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
   \                     ??FSMC_NORSRAMCmd_0: (+1)
   \       0x1C   0xF05F 0x4120      MOVS     R1,#+2684354560
   \       0x20   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \       0x24   0x....             LDR.N    R1,??DataTable15_14
   \       0x26   0x400A             ANDS     R2,R1,R2
   \       0x28   0xF05F 0x4120      MOVS     R1,#+2684354560
   \       0x2C   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    489            }
    490          }
   \                     ??FSMC_NORSRAMCmd_1: (+1)
   \       0x30   0x4770             BX       LR
    491          
    492          /**
    493            * @brief  Enables or disables the specified NAND Memory Bank.
    494            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    495            *   This parameter can be one of the following values:
    496            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    497            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    498            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    499            * @retval None
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    502          {
    503            //assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    504            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    505            
    506            if (NewState != DISABLE)
   \                     FSMC_NANDCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00F             BEQ.N    ??FSMC_NANDCmd_0
    507            {
    508              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    509              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD106             BNE.N    ??FSMC_NANDCmd_1
    510              {
    511                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
   \        0xA   0x....             LDR.N    R0,??DataTable15_1
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x12   0x....             LDR.N    R1,??DataTable15_1
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0xE015             B.N      ??FSMC_NANDCmd_2
    512              }
    513              else
    514              {
    515                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
   \                     ??FSMC_NANDCmd_1: (+1)
   \       0x18   0x....             LDR.N    R0,??DataTable15_5
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x20   0x....             LDR.N    R1,??DataTable15_5
   \       0x22   0x6008             STR      R0,[R1, #+0]
   \       0x24   0xE00E             B.N      ??FSMC_NANDCmd_2
    516              }
    517            }
    518            else
    519            {
    520              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    521              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0: (+1)
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xD106             BNE.N    ??FSMC_NANDCmd_3
    522              {
    523                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
   \       0x2A   0x....             LDR.N    R0,??DataTable15_1
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x....             LDR.N    R0,??DataTable15_15
   \       0x30   0x4001             ANDS     R1,R0,R1
   \       0x32   0x....             LDR.N    R0,??DataTable15_1
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0xE005             B.N      ??FSMC_NANDCmd_2
    524              }
    525              else
    526              {
    527                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
   \                     ??FSMC_NANDCmd_3: (+1)
   \       0x38   0x....             LDR.N    R0,??DataTable15_5
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0x....             LDR.N    R0,??DataTable15_15
   \       0x3E   0x4001             ANDS     R1,R0,R1
   \       0x40   0x....             LDR.N    R0,??DataTable15_5
   \       0x42   0x6001             STR      R1,[R0, #+0]
    528              }
    529            }
    530          }
   \                     ??FSMC_NANDCmd_2: (+1)
   \       0x44   0x4770             BX       LR
    531          
    532          /**
    533            * @brief  Enables or disables the PCCARD Memory Bank.
    534            * @param  NewState: new state of the PCCARD Memory Bank.  
    535            *   This parameter can be: ENABLE or DISABLE.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void FSMC_PCCARDCmd(FunctionalState NewState)
    539          {
    540            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    541            
    542            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??FSMC_PCCARDCmd_0
    543            {
    544              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    545              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
   \        0x6   0x....             LDR.N    R0,??DataTable15_9
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF050 0x0004      ORRS     R0,R0,#0x4
   \        0xE   0x....             LDR.N    R1,??DataTable15_9
   \       0x10   0x6008             STR      R0,[R1, #+0]
   \       0x12   0xE005             B.N      ??FSMC_PCCARDCmd_1
    546            }
    547            else
    548            {
    549              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    550              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
   \                     ??FSMC_PCCARDCmd_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable15_9
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x....             LDR.N    R0,??DataTable15_15
   \       0x1A   0x4001             ANDS     R1,R0,R1
   \       0x1C   0x....             LDR.N    R0,??DataTable15_9
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    551            }
    552          }
   \                     ??FSMC_PCCARDCmd_1: (+1)
   \       0x20   0x4770             BX       LR
    553          
    554          /**
    555            * @brief  Enables or disables the FSMC NAND ECC feature.
    556            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    557            *   This parameter can be one of the following values:
    558            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    559            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    560            * @param  NewState: new state of the FSMC NAND ECC feature.  
    561            *   This parameter can be: ENABLE or DISABLE.
    562            * @retval None
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    565          {
    566            //assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    567            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    568            
    569            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00F             BEQ.N    ??FSMC_NANDECCCmd_0
    570            {
    571              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    572              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD106             BNE.N    ??FSMC_NANDECCCmd_1
    573              {
    574                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
   \        0xA   0x....             LDR.N    R0,??DataTable15_1
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x12   0x....             LDR.N    R1,??DataTable15_1
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0xE015             B.N      ??FSMC_NANDECCCmd_2
    575              }
    576              else
    577              {
    578                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
   \                     ??FSMC_NANDECCCmd_1: (+1)
   \       0x18   0x....             LDR.N    R0,??DataTable15_5
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x20   0x....             LDR.N    R1,??DataTable15_5
   \       0x22   0x6008             STR      R0,[R1, #+0]
   \       0x24   0xE00E             B.N      ??FSMC_NANDECCCmd_2
    579              }
    580            }
    581            else
    582            {
    583              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    584              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0: (+1)
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xD106             BNE.N    ??FSMC_NANDECCCmd_3
    585              {
    586                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
   \       0x2A   0x....             LDR.N    R0,??DataTable15_1
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x....             LDR.N    R0,??DataTable15_16
   \       0x30   0x4001             ANDS     R1,R0,R1
   \       0x32   0x....             LDR.N    R0,??DataTable15_1
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0xE005             B.N      ??FSMC_NANDECCCmd_2
    587              }
    588              else
    589              {
    590                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
   \                     ??FSMC_NANDECCCmd_3: (+1)
   \       0x38   0x....             LDR.N    R0,??DataTable15_5
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0x....             LDR.N    R0,??DataTable15_16
   \       0x3E   0x4001             ANDS     R1,R0,R1
   \       0x40   0x....             LDR.N    R0,??DataTable15_5
   \       0x42   0x6001             STR      R1,[R0, #+0]
    591              }
    592            }
    593          }
   \                     ??FSMC_NANDECCCmd_2: (+1)
   \       0x44   0x4770             BX       LR
    594          
    595          /**
    596            * @brief  Returns the error correction code register value.
    597            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    598            *   This parameter can be one of the following values:
    599            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    600            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    601            * @retval The Error Correction Code (ECC) value.
    602            */

   \                                 In section .text, align 2, keep-with-next
    603          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    604          {
    605            uint32_t eccval = 0x00000000;
   \                     FSMC_GetECC: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    606            
    607            if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x2   0x2810             CMP      R0,#+16
   \        0x4   0xD102             BNE.N    ??FSMC_GetECC_0
    608            {
    609              /* Get the ECCR2 register value */
    610              eccval = FSMC_Bank2->ECCR2;
   \        0x6   0x....             LDR.N    R0,??DataTable15_17
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xE001             B.N      ??FSMC_GetECC_1
    611            }
    612            else
    613            {
    614              /* Get the ECCR3 register value */
    615              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable15_18
   \        0xE   0x6800             LDR      R0,[R0, #+0]
    616            }
    617            /* Return the error correction code value */
    618            return(eccval);
   \                     ??FSMC_GetECC_1: (+1)
   \       0x10   0x4770             BX       LR
    619          }
    620          
    621          /**
    622            * @brief  Enables or disables the specified FSMC interrupts.
    623            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    624            *   This parameter can be one of the following values:
    625            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    626            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    627            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    628            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    629            *   This parameter can be any combination of the following values:
    630            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    631            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    632            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    633            * @param  NewState: new state of the specified FSMC interrupts.
    634            *   This parameter can be: ENABLE or DISABLE.
    635            * @retval None
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    638          {
    639            //assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    640            //assert_param(IS_FSMC_IT(FSMC_IT));
    641            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    642            
    643            if (NewState != DISABLE)
   \                     FSMC_ITConfig: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD016             BEQ.N    ??FSMC_ITConfig_0
    644            {
    645              /* Enable the selected FSMC_Bank2 interrupts */
    646              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD105             BNE.N    ??FSMC_ITConfig_1
    647              {
    648                FSMC_Bank2->SR2 |= FSMC_IT;
   \        0xA   0x....             LDR.N    R0,??DataTable15_2
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x4301             ORRS     R1,R1,R0
   \       0x10   0x....             LDR.N    R0,??DataTable15_2
   \       0x12   0x6001             STR      R1,[R0, #+0]
   \       0x14   0xE027             B.N      ??FSMC_ITConfig_2
    649              }
    650              /* Enable the selected FSMC_Bank3 interrupts */
    651              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1: (+1)
   \       0x16   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x1A   0xD105             BNE.N    ??FSMC_ITConfig_3
    652              {
    653                FSMC_Bank3->SR3 |= FSMC_IT;
   \       0x1C   0x....             LDR.N    R0,??DataTable15_6
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x4301             ORRS     R1,R1,R0
   \       0x22   0x....             LDR.N    R0,??DataTable15_6
   \       0x24   0x6001             STR      R1,[R0, #+0]
   \       0x26   0xE01E             B.N      ??FSMC_ITConfig_2
    654              }
    655              /* Enable the selected FSMC_Bank4 interrupts */
    656              else
    657              {
    658                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_3: (+1)
   \       0x28   0x....             LDR.N    R0,??DataTable15_10
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x4301             ORRS     R1,R1,R0
   \       0x2E   0x....             LDR.N    R0,??DataTable15_10
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0xE018             B.N      ??FSMC_ITConfig_2
    659              }
    660            }
    661            else
    662            {
    663              /* Disable the selected FSMC_Bank2 interrupts */
    664              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0: (+1)
   \       0x34   0x2810             CMP      R0,#+16
   \       0x36   0xD106             BNE.N    ??FSMC_ITConfig_4
    665              {
    666                
    667                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \       0x38   0x....             LDR.N    R0,??DataTable15_2
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0xEA30 0x0101      BICS     R1,R0,R1
   \       0x40   0x....             LDR.N    R0,??DataTable15_2
   \       0x42   0x6001             STR      R1,[R0, #+0]
   \       0x44   0xE00F             B.N      ??FSMC_ITConfig_2
    668              }
    669              /* Disable the selected FSMC_Bank3 interrupts */
    670              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_4: (+1)
   \       0x46   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x4A   0xD106             BNE.N    ??FSMC_ITConfig_5
    671              {
    672                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \       0x4C   0x....             LDR.N    R0,??DataTable15_6
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0xEA30 0x0101      BICS     R1,R0,R1
   \       0x54   0x....             LDR.N    R0,??DataTable15_6
   \       0x56   0x6001             STR      R1,[R0, #+0]
   \       0x58   0xE005             B.N      ??FSMC_ITConfig_2
    673              }
    674              /* Disable the selected FSMC_Bank4 interrupts */
    675              else
    676              {
    677                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_5: (+1)
   \       0x5A   0x....             LDR.N    R0,??DataTable15_10
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xEA30 0x0101      BICS     R1,R0,R1
   \       0x62   0x....             LDR.N    R0,??DataTable15_10
   \       0x64   0x6001             STR      R1,[R0, #+0]
    678              }
    679            }
    680          }
   \                     ??FSMC_ITConfig_2: (+1)
   \       0x66   0x4770             BX       LR
    681          
    682          /**
    683            * @brief  Checks whether the specified FSMC flag is set or not.
    684            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    685            *   This parameter can be one of the following values:
    686            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    687            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    688            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    689            * @param  FSMC_FLAG: specifies the flag to check.
    690            *   This parameter can be one of the following values:
    691            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    692            *     @arg FSMC_FLAG_Level: Level detection Flag.
    693            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    694            *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    695            * @retval The new state of FSMC_FLAG (SET or RESET).
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    698          {
    699            FlagStatus bitstatus = RESET;
   \                     FSMC_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    700            uint32_t tmpsr = 0x00000000;
   \        0x2   0x2200             MOVS     R2,#+0
    701            
    702            /* Check the parameters */
    703            //assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    704            //assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    705            
    706            if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD102             BNE.N    ??FSMC_GetFlagStatus_0
    707            {
    708              tmpsr = FSMC_Bank2->SR2;
   \        0x8   0x....             LDR.N    R0,??DataTable15_2
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0xE007             B.N      ??FSMC_GetFlagStatus_1
    709            }  
    710            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_0: (+1)
   \        0xE   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x12   0xD102             BNE.N    ??FSMC_GetFlagStatus_2
    711            {
    712              tmpsr = FSMC_Bank3->SR3;
   \       0x14   0x....             LDR.N    R0,??DataTable15_6
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xE001             B.N      ??FSMC_GetFlagStatus_1
    713            }
    714            /* FSMC_Bank4_PCCARD*/
    715            else
    716            {
    717              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_2: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable15_10
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
    718            } 
    719            
    720            /* Get the flag status */
    721            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_1: (+1)
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD001             BEQ.N    ??FSMC_GetFlagStatus_3
    722            {
    723              bitstatus = SET;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE000             B.N      ??FSMC_GetFlagStatus_4
    724            }
    725            else
    726            {
    727              bitstatus = RESET;
   \                     ??FSMC_GetFlagStatus_3: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
    728            }
    729            /* Return the flag status */
    730            return bitstatus;
   \                     ??FSMC_GetFlagStatus_4: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x4770             BX       LR
    731          }
    732          
    733          /**
    734            * @brief  Clears the FSMC's pending flags.
    735            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    736            *   This parameter can be one of the following values:
    737            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    738            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    739            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    740            * @param  FSMC_FLAG: specifies the flag to clear.
    741            *   This parameter can be any combination of the following values:
    742            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    743            *     @arg FSMC_FLAG_Level: Level detection Flag.
    744            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    745            * @retval None
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    748          {
    749           /* Check the parameters */
    750            //assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    751            //assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    752              
    753            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD106             BNE.N    ??FSMC_ClearFlag_0
    754            {
    755              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \        0x4   0x....             LDR.N    R0,??DataTable15_2
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0xEA30 0x0101      BICS     R1,R0,R1
   \        0xC   0x....             LDR.N    R0,??DataTable15_2
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE00F             B.N      ??FSMC_ClearFlag_1
    756            }  
    757            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0: (+1)
   \       0x12   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x16   0xD106             BNE.N    ??FSMC_ClearFlag_2
    758            {
    759              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \       0x18   0x....             LDR.N    R0,??DataTable15_6
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xEA30 0x0101      BICS     R1,R0,R1
   \       0x20   0x....             LDR.N    R0,??DataTable15_6
   \       0x22   0x6001             STR      R1,[R0, #+0]
   \       0x24   0xE005             B.N      ??FSMC_ClearFlag_1
    760            }
    761            /* FSMC_Bank4_PCCARD*/
    762            else
    763            {
    764              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_2: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable15_10
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xEA30 0x0101      BICS     R1,R0,R1
   \       0x2E   0x....             LDR.N    R0,??DataTable15_10
   \       0x30   0x6001             STR      R1,[R0, #+0]
    765            }
    766          }
   \                     ??FSMC_ClearFlag_1: (+1)
   \       0x32   0x4770             BX       LR
    767          
    768          /**
    769            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    770            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    771            *   This parameter can be one of the following values:
    772            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    773            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    774            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    775            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    776            *   This parameter can be one of the following values:
    777            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    778            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    779            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    780            * @retval The new state of FSMC_IT (SET or RESET).
    781            */

   \                                 In section .text, align 2, keep-with-next
    782          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    783          {
    784            ITStatus bitstatus = RESET;
   \                     FSMC_GetITStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    785            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    786            
    787            /* Check the parameters */
    788            //assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    789            //assert_param(IS_FSMC_GET_IT(FSMC_IT));
    790            
    791            if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x8   0x2810             CMP      R0,#+16
   \        0xA   0xD102             BNE.N    ??FSMC_GetITStatus_0
    792            {
    793              tmpsr = FSMC_Bank2->SR2;
   \        0xC   0x....             LDR.N    R0,??DataTable15_2
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0xE007             B.N      ??FSMC_GetITStatus_1
    794            }  
    795            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_0: (+1)
   \       0x12   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x16   0xD102             BNE.N    ??FSMC_GetITStatus_2
    796            {
    797              tmpsr = FSMC_Bank3->SR3;
   \       0x18   0x....             LDR.N    R0,??DataTable15_6
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0xE001             B.N      ??FSMC_GetITStatus_1
    798            }
    799            /* FSMC_Bank4_PCCARD*/
    800            else
    801            {
    802              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_2: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable15_10
   \       0x20   0x6802             LDR      R2,[R0, #+0]
    803            } 
    804            
    805            itstatus = tmpsr & FSMC_IT;
   \                     ??FSMC_GetITStatus_1: (+1)
   \       0x22   0xEA11 0x0002      ANDS     R0,R1,R2
    806            
    807            itenable = tmpsr & (FSMC_IT >> 3);
   \       0x26   0xEA12 0x02D1      ANDS     R2,R2,R1, LSR #+3
    808            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ.N    ??FSMC_GetITStatus_3
   \       0x2E   0x2A00             CMP      R2,#+0
   \       0x30   0xD001             BEQ.N    ??FSMC_GetITStatus_3
    809            {
    810              bitstatus = SET;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE000             B.N      ??FSMC_GetITStatus_4
    811            }
    812            else
    813            {
    814              bitstatus = RESET;
   \                     ??FSMC_GetITStatus_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
    815            }
    816            return bitstatus; 
   \                     ??FSMC_GetITStatus_4: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x4770             BX       LR
    817          }
    818          
    819          /**
    820            * @brief  Clears the FSMC's interrupt pending bits.
    821            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    822            *   This parameter can be one of the following values:
    823            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    824            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    825            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    826            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    827            *   This parameter can be any combination of the following values:
    828            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    829            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    830            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    831            * @retval None
    832            */

   \                                 In section .text, align 2, keep-with-next
    833          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    834          {
    835            /* Check the parameters */
    836            //assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    837            //assert_param(IS_FSMC_IT(FSMC_IT));
    838              
    839            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD106             BNE.N    ??FSMC_ClearITPendingBit_0
    840            {
    841              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \        0x4   0x....             LDR.N    R0,??DataTable15_2
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \        0xC   0x....             LDR.N    R1,??DataTable15_2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   \       0x10   0xE00F             B.N      ??FSMC_ClearITPendingBit_1
    842            }  
    843            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0: (+1)
   \       0x12   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x16   0xD106             BNE.N    ??FSMC_ClearITPendingBit_2
    844            {
    845              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \       0x18   0x....             LDR.N    R0,??DataTable15_6
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \       0x20   0x....             LDR.N    R1,??DataTable15_6
   \       0x22   0x6008             STR      R0,[R1, #+0]
   \       0x24   0xE005             B.N      ??FSMC_ClearITPendingBit_1
    846            }
    847            /* FSMC_Bank4_PCCARD*/
    848            else
    849            {
    850              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_2: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable15_10
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \       0x2E   0x....             LDR.N    R1,??DataTable15_10
   \       0x30   0x6008             STR      R0,[R1, #+0]
    851            }
    852          }
   \                     ??FSMC_ClearITPendingBit_1: (+1)
   \       0x32   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xA000'0104        DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xA000'0060        DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0xA000'0064        DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0xA000'0068        DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0xA000'006C        DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0xA000'0080        DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0xA000'0084        DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0xA000'0088        DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0xA000'008C        DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0xA000'00A0        DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0xA000'00A4        DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0xA000'00A8        DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0xA000'00AC        DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0xA000'00B0        DC32     0xa00000b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x000F'FFFE        DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x000F'FFFB        DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x000F'FFBF        DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \        0x0   0xA000'0074        DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \        0x0   0xA000'0094        DC32     0xa0000094
    853          
    854          /**
    855            * @}
    856            */ 
    857          
    858          /**
    859            * @}
    860            */
    861          
    862          /**
    863            * @}
    864            */
    865          
    866          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FSMC_ClearFlag
       0   FSMC_ClearITPendingBit
       0   FSMC_GetECC
       0   FSMC_GetFlagStatus
       0   FSMC_GetITStatus
       0   FSMC_ITConfig
       0   FSMC_NANDCmd
       0   FSMC_NANDDeInit
       0   FSMC_NANDECCCmd
       4   FSMC_NANDInit
       0   FSMC_NANDStructInit
       0   FSMC_NORSRAMCmd
       0   FSMC_NORSRAMDeInit
       0   FSMC_NORSRAMInit
       0   FSMC_NORSRAMStructInit
       0   FSMC_PCCARDCmd
       0   FSMC_PCCARDDeInit
       0   FSMC_PCCARDInit
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      52  FSMC_ClearFlag
      52  FSMC_ClearITPendingBit
      18  FSMC_GetECC
      44  FSMC_GetFlagStatus
      60  FSMC_GetITStatus
     104  FSMC_ITConfig
      70  FSMC_NANDCmd
      80  FSMC_NANDDeInit
      70  FSMC_NANDECCCmd
     142  FSMC_NANDInit
      78  FSMC_NANDStructInit
      50  FSMC_NORSRAMCmd
      58  FSMC_NORSRAMDeInit
     226  FSMC_NORSRAMInit
     142  FSMC_NORSRAMStructInit
      34  FSMC_PCCARDCmd
      48  FSMC_PCCARDDeInit
     128  FSMC_PCCARDInit
      86  FSMC_PCCARDStructInit

 
 1'618 bytes in section .text
 
 1'618 bytes of CODE memory

Errors: none
Warnings: none
